#include "SzlFileLoader.h"
#include <algorithm>
#include <fstream>
#include "exportSubzonePlt.h"
#include "IntervalTree.h"
#include "writeValueArray.h"
using namespace std; namespace tecplot { namespace ___3931 { ___372 IntervalTree::addInterval(double minValue, double maxValue) { REQUIRE(m_minimums.size() == m_maximums.size()); REQUIRE(m_minimums.size() == m_curNumIntervals); ___372 ___2037 = ___4224; m_minimums.push_back(minValue); m_maximums.push_back(maxValue); m_curNumIntervals++; return ___2037; } ___372 IntervalTree::addIntervalsMinMaxArray(TreeIndex_t numMinMaxes, ___2479 const& arrayMinMaxes) { REQUIRE( arrayMinMaxes.size() == numMinMaxes );
 #ifndef NO_ASSERTS
for ( size_t ___1839 = 0; ___1839 < numMinMaxes; ___1839++ ) REQUIRE(arrayMinMaxes[___1839].___2065());
 #endif
___372 ___2037 = ___4224; for (TreeIndex_t ___1839=0; ___1839<numMinMaxes; ___1839++) { ___2477 const& MinMaxatii = arrayMinMaxes[___1839]; double const min = MinMaxatii.minValue(); double const max = MinMaxatii.maxValue(); ___2037 = IntervalTree::addInterval(min, max); } return ___2037; } void IntervalTree::queryNode( TreeIndex_t nodeOffset, double ___4296, TreeIndexVector& intervalList) { IntervalTree::TreeNode const& treeNode = m_treeNodes[nodeOffset]; if (___4296 <= treeNode.strikeValue) { TreeIndex_t list_start = treeNode.___3679; TreeIndex_t list_end   = list_start + treeNode.size; for (TreeIndex_t i = list_start; i < list_end; i++) { TreeIndex_t intervalNum = m_alEntries[i]; double minOfInterval = m_minimums[intervalNum]; if (___4296 >= minOfInterval) intervalList.push_back(intervalNum); else break; } if (treeNode.left != BAD_ANY_INDEX) { queryNode(treeNode.left, ___4296, intervalList); } } if (___4296 >= treeNode.strikeValue) { TreeIndex_t list_start = treeNode.___3679; TreeIndex_t list_end   = list_start + treeNode.size; ___372 NotEnd = true; for (TreeIndex_t i = list_start; i < list_end && NotEnd; i++) { TreeIndex_t IntervalNum = m_dhEntries[i]; double MaxOfInterval = m_maximums[IntervalNum]; if (___4296 <= MaxOfInterval) { intervalList.push_back(IntervalNum); } else { NotEnd = false; } } if (treeNode.right != BAD_ANY_INDEX) { queryNode(treeNode.right, ___4296, intervalList); } } } void IntervalTree::queryIntervals( double value, TreeIndexVector& intervalList) { if (m_root == BAD_ANY_INDEX || m_treeNodes.empty() ) { ___476(size_t(m_curNumIntervals) == m_minimums.size() && size_t(m_curNumIntervals) == m_maximums.size()); TreeIndex_t const size = m_curNumIntervals; for (TreeIndex_t ___1839 = 0; ___1839 < size; ++___1839) { if (m_minimums[___1839] <= value && m_maximums[___1839] >= value) intervalList.push_back(___1839); } } else { queryNode(m_root, value, intervalList); } } double IntervalTree::medianOfVector(vector<double>& arrayValues, TreeIndex_t ___2793) { REQUIRE(arrayValues.size()==___2793); REQUIRE(___2793>0); double median; if (___2793 > 1) { vector<double>::iterator medianPos = arrayValues.begin()+___2793/2; std::nth_element(arrayValues.begin(), medianPos, arrayValues.end()); median = *medianPos; } else median = arrayValues[0]; return median; } ___372 IntervalTree::minAscendingCompare(TreeIndex_t i, TreeIndex_t ___2103) { ___372 isAscending = m_minimums[i] < m_minimums[___2103]; return isAscending; } ___372 IntervalTree::maxDescendingCompare(TreeIndex_t i, TreeIndex_t ___2103) { ___372 isDescending = (m_maximums[i] > m_maximums[___2103]); return isDescending; }
 #ifdef WIN32
 #pragma warning(disable:4512) 
 #endif
class ALIncreasing { private: vector<double> const& m_Minimums; public: ALIncreasing(vector<double> const& Minimums) : m_Minimums(Minimums) { } ___372 operator()(IntervalTree::TreeIndex_t a, IntervalTree::TreeIndex_t b) const { double const valA = m_Minimums[a]; double const valB = m_Minimums[b]; return valA < valB; } };
 #ifdef WIN32
 #pragma warning(disable:4512) 
 #endif
class DHDecreasing { private: vector<double> const& m_Maximums; public: DHDecreasing(vector<double> const& Maximums) : m_Maximums(Maximums) { } ___372 operator()(IntervalTree::TreeIndex_t a, IntervalTree::TreeIndex_t b) const { double const valA = m_Maximums[a]; double const valB = m_Maximums[b]; return valA > valB; } }; IntervalTree::TreeIndex_t IntervalTree::constructNode(TreeIndexVector const& list, TreeIndex_t ___2810) { TreeIndex_t left = BAD_ANY_INDEX; TreeIndex_t right = BAD_ANY_INDEX; TreeIndex_t numLeftItems = 0; TreeIndexVector leftList; TreeIndex_t numRightItems = 0; TreeIndexVector rightList; TreeIndex_t const alDHStartSize = m_numAlDhEntries; vector<double> combinedArray; for (TreeIndex_t ___1839=0; ___1839<___2810; ___1839++) { TreeIndex_t const interval = list[___1839]; combinedArray.push_back(m_minimums[interval]); combinedArray.push_back(m_maximums[interval]); } double const strikeValue = medianOfVector(combinedArray, ___2810*2); for (TreeIndex_t ___1839=0; ___1839<___2810; ___1839++) { TreeIndex_t const interval = list[___1839]; if (m_minimums[interval] <= strikeValue && strikeValue <= m_maximums[interval]) { m_alEntries.push_back(interval); m_dhEntries.push_back(interval); m_numAlDhEntries++; } else if (m_maximums[interval] < strikeValue) { leftList.push_back(interval); numLeftItems++; } else { ___476(m_minimums[interval] > strikeValue); rightList.push_back(interval); numRightItems++; } } ALIncreasing alIncreasing(m_minimums); std::sort(m_alEntries.begin()+alDHStartSize, m_alEntries.begin()+m_numAlDhEntries, alIncreasing); DHDecreasing dhDecreasing(m_maximums); std::sort(m_dhEntries.begin()+alDHStartSize, m_dhEntries.begin()+m_numAlDhEntries, dhDecreasing); TreeIndex_t const alDHListSize = m_numAlDhEntries - alDHStartSize; if (numLeftItems > 0) left = constructNode(leftList, numLeftItems); if (numRightItems > 0) right = constructNode(rightList, numRightItems); TreeNode currentNode; currentNode.left = left; currentNode.right = right; currentNode.strikeValue = strikeValue; currentNode.___3679 = alDHStartSize; currentNode.size  = alDHListSize; m_treeNodes.push_back(currentNode); m_numTreeNodes++; TreeIndex_t offsetToCurrentNode = m_numTreeNodes - 1; ENSURE(currentNode==m_treeNodes[offsetToCurrentNode]); return offsetToCurrentNode; } ___372 IntervalTree::constructTree() { TreeIndexVector list; ___372 ___2037 = resizeVector(list,m_curNumIntervals); if ( ___2037 ) { for ( TreeIndex_t ___1839 = 0; ___1839 < m_curNumIntervals; ___1839++ ) list[___1839] = ___1839; m_root = constructNode(list, m_curNumIntervals); } return ___2037; }
 #ifdef SCOTT
___372 IntervalTree::encodeAsciiTreeNodeValue(char*           str, TreeNode const& treeNode) { ___372 ___2037 = (sprintf(str, "%*.7e" " %*" PRIu32 " %*" PRIu32 " %*" PRIu32 " %*" PRIu32, -___196, treeNode.strikeValue, -___209, treeNode.___3679, -___209, treeNode.size, -___209, treeNode.left, -___209, treeNode.right) > 0); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 IntervalTree::___4547( FileWriterInterface& file, char const*          ___970, ___4633          ___1249) { INVARIANT(sizeof(TreeNode)==24); REQUIRE(file.___2039()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE("extraID could have any value. NO_EXTRA_ID shows only the description"); REQUIRE(m_numTreeNodes > 0); REQUIRE(m_treeNodes.size() == m_numTreeNodes); return ___4560<TreeNode>(file, ___970, ___1249, m_numTreeNodes, m_treeNodes.data(), encodeAsciiTreeNodeValue, ___944/5); } ___372 IntervalTree::___4476( FileWriterInterface& file, char const*          ___970, ___4633          ___1249) { INVARIANT(sizeof(TreeIndex_t)==4); REQUIRE(file.___2039()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE("extraID could have any value. NO_EXTRA_ID shows only the description"); REQUIRE(m_numAlDhEntries > 0); REQUIRE(m_alEntries.size() == m_numAlDhEntries); return ___4560<uint32_t, false, 0>(file, ___970, ___1249, m_numAlDhEntries, m_alEntries.data(), ___1161); } ___372 IntervalTree::___4502( FileWriterInterface& file, char const*          ___970, ___4633          ___1249) { INVARIANT(sizeof(TreeIndex_t)==4); REQUIRE(file.___2039()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE("extraID could have any value. NO_EXTRA_ID shows only the description"); REQUIRE(m_numAlDhEntries > 0); REQUIRE(m_dhEntries.size() == m_numAlDhEntries); return ___4560<uint32_t, false, 0>(file, ___970, ___1249, m_numAlDhEntries, m_dhEntries.data(), ___1161); }
 #endif
___372 IntervalTree::writeTreeToFile( FileWriterInterface& file, ___1170           zone) { ___372 ___2037 = true; REQUIRE(file.___2039()); REQUIRE(m_numTreeNodes > 0); REQUIRE(m_treeNodes.size() == m_numTreeNodes); REQUIRE(m_alEntries.size() == m_curNumIntervals); REQUIRE(m_dhEntries.size() == m_curNumIntervals);
 #ifdef SCOTT
___4547(file, "TreeNodesForZone", zone); ___4476(file, "TreeALForZone", zone); ___4502(file, "TreeDHForZone", zone);
 #else
___4276(file); ___4276(zone);
 #endif
 #if 0 
INVARIANT(sizeof(___2477)==8); return ___4560<___2477>(file, ___970, ___1249, ___2793, ___2478.data(), ___1157, ___944/2);
 #endif
return ___2037; }
 #if 0 
___372 IntervalTree::writeTreeToFile() { ___372 ___2037 = true; ofstream outfile("xvar.tree", ios::out | ios::binary); outfile.write((const char*)&m_numTreeNodes, sizeof(TreeIndex_t)); outfile.write((const char*)&m_curNumIntervals, sizeof(TreeIndex_t)); outfile.write((const char *)m_treeNodes.data(), m_numTreeNodes*sizeof(TreeNode)); outfile.write((const char *)m_minimums.data(), m_curNumIntervals*sizeof(double)); outfile.write((const char *)m_maximums.data(), m_curNumIntervals*sizeof(double)); return ___2037; }
 #endif
___372 IntervalTree::readTreeFromFile(FileWriterInterface& file) { ___4276(file); ___372 ___2037 = true; ifstream infile("xvar.tree", ios::in | ios::binary); TreeIndex_t ___2819; infile.read((char*)&___2819, sizeof(TreeIndex_t)); TreeIndex_t numIntervals; infile.read((char*)&numIntervals, sizeof(TreeIndex_t)); ___2037 = ___2037 && resizeVector(m_treeNodes, ___2819); ___2037 = ___2037 && resizeVector(m_minimums, numIntervals); ___2037 = ___2037 && resizeVector(m_maximums, numIntervals); if ( ___2037 ) { infile.read((char *)m_treeNodes.data(), ___2819*sizeof(TreeNode)); infile.read((char *)m_minimums.data(), numIntervals*sizeof(double)); infile.read((char *)m_maximums.data(), numIntervals*sizeof(double)); } return ___2037; } }}
