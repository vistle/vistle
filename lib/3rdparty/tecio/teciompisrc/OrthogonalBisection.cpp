#include "SzlFileLoader.h"
#include "OrthogonalBisection.h"
#include "AltTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cmath>
#include <fstream>
#include <utility>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "zoneUtil.h"
using namespace std; namespace tecplot { namespace ___3931 { OrthogonalBisection::OrthogonalBisection( ___4633                    zone, ItemAddress64::SectionOffset_t section, BisectionType_e                bisectionType, ItemAddress64::ItemOffset_t    maxDomainSize) : ___2675(zone) , m_section(section) , m_bisectionType(bisectionType) , m_maxDomainSize(maxDomainSize) , m_baseItem(0) , m_numItems(0) , m_numGhostItems(0) , m_numRecursionDepths(0) { REQUIRE(bisectionType == OrthogonalBisection::BisectionType_ZoneCells || (bisectionType == OrthogonalBisection::BisectionType_ZoneNodes && m_section == 0)); ___935(); } OrthogonalBisection::~OrthogonalBisection(void) { } OrthogonalBisection::BisectionType_e OrthogonalBisection::bisectionType() const { return m_bisectionType; } void OrthogonalBisection::___935(void) { m_baseItem = 0; m_numItems = 0; m_numGhostItems = 0; m_numRecursionDepths = 0; m_numDomains = 0; m_itemList.___935(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); m_reducedPrecisionSortDataArrays.___935(); } namespace {
 #ifdef WIN32
 #pragma warning(disable:4512) 
 #endif
class ZoneCellOrNodeSorter { private: ___1350 const&  m_fieldData; ___81 const  m_baseItem; UInt8Array const& m_reducedPrecisionSortData; public: ZoneCellOrNodeSorter( ___1350&        ___1349, ___81        baseItem, UInt8Array const& reducedPrecisionSortData) : m_fieldData(___1349) , m_baseItem(baseItem) , m_reducedPrecisionSortData(reducedPrecisionSortData) { } bool operator()(___81 aIndex, ___81 bIndex) const { if ( m_reducedPrecisionSortData[aIndex] != m_reducedPrecisionSortData[bIndex] ) { return m_reducedPrecisionSortData[aIndex] < m_reducedPrecisionSortData[bIndex]; } else { double const aVal = m_fieldData.___1778(m_baseItem+aIndex+1); double const bVal = m_fieldData.___1778(m_baseItem+bIndex+1); if ( aVal == bVal ) return aIndex < bIndex; else return aVal < bVal; } } }; } namespace { void executeBoostFunction(___90 ___2121) { boost::function<void(void)> *___1436 = reinterpret_cast<boost::function<void(void)>* >(___2121); (*___1436)(); delete ___1436; } } ___372 OrthogonalBisection::splitDomain( ___37&                    ___36, ___81                     domainStart, ___81                     domainSize, ___4349                     axisDirToSplit, ItemAddress64::SubzoneOffset_t recursionDepth, ___2118                  ___2117) { ___372 ___2037 = ___4224; REQUIRE(IMPLICATION(m_numItems > 0, domainStart < m_numItems)); REQUIRE(IMPLICATION(m_numItems > 0, domainStart+domainSize <= m_numItems)); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth <= m_numRecursionDepths); REQUIRE(VALID_REF(___2117)); if ( domainSize > m_maxDomainSize ) { ___2037 = calcReducedPrecisionValues(___36, domainStart, domainSize, axisDirToSplit, recursionDepth); ___81 leftOffset; ___81 leftSize; ___81 rightOffset; ___81 rightSize; getSubdomainInfo(domainStart, domainSize, leftOffset, leftSize, rightOffset, rightSize); if ( m_bisectionType == BisectionType_ZoneCells ) { ZoneCellOrNodeSorter zoneCellSorter(*m_ccFieldDataPtrs[axisDirToSplit], m_baseItem, m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneCellSorter); } else { ___476(m_bisectionType == BisectionType_ZoneNodes); ZoneCellOrNodeSorter zoneNodeSorter(*m_nodalFieldDataPtrs[axisDirToSplit], m_baseItem, m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneNodeSorter); } ___4349 const nextDirection = (axisDirToSplit+1) % NUM_BISECTION_DIRECTIONS; ItemAddress64::SubzoneOffset_t const nextRecursionDepth = recursionDepth+1; if ( recursionDepth < m_maxRecursion && leftSize > m_maxDomainSize ) { boost::function<void(void)>* leftFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2117));
___36.___4154( executeBoostFunction, reinterpret_cast<___90>(leftFunction), ___2117); boost::function<void(void)>* rightFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2117)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(rightFunction), ___2117); } else { ___2037 = ___2037 && splitDomain(___36, leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2117); ___2037 = ___2037 && splitDomain(___36, rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2117); }
 #if 0 
if ( rightOffset+rightSize == m_numItems ) { boost::function<void(void)>* updateStatusLineFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::updateStatusLine, this, nextRecursionDepth)); TecUtilMainlineInvoke( executeBoostFunction, reinterpret_cast<___90>(updateStatusLineFunction)); }
 #endif
} else { std::sort(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+domainSize); } return ___2037; } ___372 OrthogonalBisection::updateStatusLine(___37& ___36, ItemAddress64::SubzoneOffset_t recursionDepth) { REQUIRE(m_numRecursionDepths>0); ___372 ___2037 = ___36.___3767(100*recursionDepth/m_numRecursionDepths); return ___2037; } ___372 OrthogonalBisection::loadCoordinateVarZoneFieldData(___37& ___36, char axis) { REQUIRE(axis=='X' || axis=='Y' || axis=='Z'); REQUIRE(m_nodalFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS) && m_ccFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS)); ___4349 dir = ___4349(axis - 'X'); ___476(dir < NUM_BISECTION_DIRECTIONS); if (___36.___908(___2675 + 1, dir + 1) == ___4327) { m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1); m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1, false  , true /* ___962 */); } else { m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1); m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1, false  , true /* ___962 */); } ___372 ___2037 = (m_nodalFieldDataPtrs[dir] != NULL && m_nodalFieldDataPtrs[dir]->___2065() && m_ccFieldDataPtrs[dir] != NULL && m_ccFieldDataPtrs[dir]->___2065()); return ___2037; } void OrthogonalBisection::getMinMaxWeightOverRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ___4349                     axisDirToSplit, ___2477&                        weightMinMax) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE("weightMinMax isn't required to be initialized"); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; ___2477 minMax; for (___81 ___2083 = jobStart; ___2083 < jobEnd; ___2083++) { double const weight = ___1349.___1778(m_baseItem + m_itemList[___2083] + 1); minMax.include(weight); } weightMinMax = minMax; } void OrthogonalBisection::rescaleWeightsOverRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ___4349                     axisDirToSplit, double                         scale, double                         ___2863) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0);
REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(scale >= 0.0); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; UInt8Array& reducedPrecisionSortData = m_reducedPrecisionSortDataArrays[axisDirToSplit]; ___476(static_cast<___81>(reducedPrecisionSortData.size()) == m_numItems + m_numGhostItems); for (___81 ___2083 = jobStart; ___2083 < jobEnd; ___2083++) { ___2716 const index = ___2716( m_itemList[___2083] ); double const weight = ___1349.___1778(m_baseItem + index + 1); double const scaledVal = scale*(weight + ___2863); ___476(0.0 <= scaledVal && scaledVal < 256.0); uint8_t const int8Val = int8_t(scaledVal); reducedPrecisionSortData[index] = int8Val; } } ___372 OrthogonalBisection::calcReducedPrecisionValues( ___37&                    ___36, ___81                     rangeStart, ___81                     ___3266, ___4349                     axisDirToSplit, ItemAddress64::SubzoneOffset_t recursionDepth) { ___372 ___2037 = ___4224; REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth < m_numRecursionDepths); static ItemAddress64::SubzoneOffset_t const REDUCED_PRECISION_RECALC_FREQUENCY = 3; if ( recursionDepth % (REDUCED_PRECISION_RECALC_FREQUENCY*NUM_BISECTION_DIRECTIONS) == ItemAddress64::SubzoneOffset_t(axisDirToSplit) ) { ___1350& ___1349 = *m_nodalFieldDataPtrs[axisDirToSplit]; static double const maxNewRange = 255.99; ___476(uint8_t(maxNewRange)==255); ___2477 itemWeightMinMax; if ( recursionDepth < ItemAddress64::SubzoneOffset_t(NUM_BISECTION_DIRECTIONS) ) { double minVal; double maxVal; ___1349.___1757(&minVal, &maxVal); itemWeightMinMax.___3497(minVal, maxVal); } else { ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3266/MIN_THREADED_ITEM_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); ___2479 jobMinMaxes; if ( ___2117 && jobMinMaxes.alloc(numJobs) ) { try { for ( ItemAddress64::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* getMinMaxFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getMinMaxWeightOverRange, this, rangeStart, ___3266, ___2116, numJobs, axisDirToSplit, boost::ref(jobMinMaxes[___2116]))); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(getMinMaxFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117);
___36.___4157(&___2117); } if ( ___2037 ) { for ( ItemAddress64::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) itemWeightMinMax.include(jobMinMaxes[___2116]); } } else { getMinMaxWeightOverRange(rangeStart, ___3266, 0 , 1/*numJobs*/, axisDirToSplit, itemWeightMinMax); } } if ( ___2037 ) { double const ___2863 = -itemWeightMinMax.minValue(); double const scale = (itemWeightMinMax.maxValue() > itemWeightMinMax.minValue()+___3626) ? maxNewRange / ( itemWeightMinMax.maxValue() - itemWeightMinMax.minValue() ) : 0.; ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3266/MIN_THREADED_ITEM_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { for ( ItemAddress64::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* rescaleFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::rescaleWeightsOverRange, this, rangeStart, ___3266, ___2116, numJobs, axisDirToSplit, scale, ___2863)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(rescaleFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117); ___36.___4157(&___2117); } } else { rescaleWeightsOverRange(rangeStart, ___3266, 0 , 1/*numJobs*/, axisDirToSplit, scale, ___2863); } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 OrthogonalBisection::performBisection(___37& ___36) { ___372 ___2037 = ___4224; ___36.___856(); double maxThreads = ___36.___4155() * MAX_THREADS_PER_CORE; m_maxRecursion = static_cast<ItemAddress64::SubzoneOffset_t>(std::max(1.0, log(maxThreads) / log(2.0))); m_maxThreadedJobs = 1 << m_maxRecursion; ___2682 = ___36.___4617(___2675 + 1); std::tie(m_baseItem,m_numItems) = bisectionSize(___36, ___2675, m_section, ___2682, m_bisectionType); GhostInfo_pa ghostInfo = m_bisectionType == BisectionType_ZoneCells ? ___36.zoneGhostCellInfoGetRef(___2675+1) : ___36.zoneGhostNodeInfoGetRef(___2675+1); ItemAddress64::SectionOffset_t const sectionIndex = m_bisectionType == BisectionType_ZoneCells ? m_section+1 : 1; m_numGhostItems = ghostInfo ? ___36.ghostInfoGetNumItemsByRef(ghostInfo,sectionIndex) : 0; m_numItems -= m_numGhostItems; m_numRecursionDepths = calcNumRecursionDepths(); m_numDomains = calcNumDomains(); ___2037 = ___2037 && m_nodalFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2037 = ___2037 && m_ccFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'X'); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'Y'); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'Z'); ___2037 = ___2037 && m_itemList.alloc(m_numItems + m_numGhostItems);
if ( ___2037 ) { if ( m_numGhostItems > 0 ) { boost::unordered_set<___81> ghostItemSet; for(___81 ___1839 = 0; ___1839 < m_numGhostItems; ++___1839) ghostItemSet.insert(___36.ghostInfoGetItemByRef(ghostInfo, sectionIndex, ___1839+1) - 1); ___81 realIndex = 0; ___81 ghostIndex = m_numItems; for (___81 ___1839 = 0; ___1839 < m_numItems + m_numGhostItems; ___1839++) { if (ghostItemSet.find(___1839) != ghostItemSet.end()) m_itemList[ghostIndex++] = ___1839; else m_itemList[realIndex++] = ___1839; } ___476(realIndex == static_cast<___81>(m_numItems)); ___476(ghostIndex == m_numItems + m_numGhostItems); } else { for (___81 ___1839 = 0; ___1839 < m_numItems; ___1839++) m_itemList[___1839] = ___1839; } } ___2037 = ___2037 && m_reducedPrecisionSortDataArrays.alloc(NUM_BISECTION_DIRECTIONS); for ( ___4349 dir = 0; ___2037 && dir < NUM_BISECTION_DIRECTIONS; dir++ ) ___2037 = ___2037 && m_reducedPrecisionSortDataArrays[dir].alloc(m_numItems + m_numGhostItems); if (___2037 && m_numItems > 0) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { boost::function<void(void)>* splitFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), 0 , m_numItems/*size*/, 0/*axisDir*/, 0/*recursionDepth*/, ___2117)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(splitFunction), ___2117); } catch (...) { ___2037 = ___1303; } } ___36.___4159(___2117); ___36.___4157(&___2117); } m_reducedPrecisionSortDataArrays.___935(); ___36.___857(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); return ___2037; } void OrthogonalBisection::getSzCoordsByRange( ___81                     rangeStart, ___81                     ___3266, ItemAddress64::SubzoneOffset_t ___2116, ItemAddress64::SubzoneOffset_t numJobs, ItemAddressArray&              szCoordArray) { REQUIRE(IMPLICATION(m_numItems > 0, rangeStart < m_numItems)); REQUIRE(IMPLICATION(m_numItems > 0, ___3266 > 0 && rangeStart+___3266 <= m_numItems)); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); REQUIRE(szCoordArray.size()==size_t(m_numItems + m_numGhostItems)); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); ItemAddress64::SubzoneOffset_t const szStart = ItemAddress64::SubzoneOffset_t(jobStart); ItemAddress64::SubzoneOffset_t const szEnd = ItemAddress64::SubzoneOffset_t(jobEnd); ___81 newItem = jobStart*___81(m_maxDomainSize); for (ItemAddress64::SubzoneOffset_t ___3878 = szStart; ___3878 < szEnd; ++___3878) { ItemAddress64::ItemOffset_t subzoneSize = getDomainSize(___3878); for (ItemAddress64::ItemOffset_t ___2863 = 0; ___2863 < subzoneSize; ++___2863) { ___81 const orgItem = queryPositionbyOffset(newItem); szCoordArray[orgItem] = ItemAddress64(___2675, m_section, ___3878, ___2863); ++newItem; } } } ___372 OrthogonalBisection::getSzCoordByOriginalItemArray(___37& ___36, ItemAddressArray& szCoordByOriginalItem)
{ REQUIRE(szCoordByOriginalItem.empty()); REQUIRE(m_numItems >= 0); ___372 ___2037 = szCoordByOriginalItem.alloc(m_numItems + m_numGhostItems); if ( ___2037 ) { ___81 const maxThreadsAvailable = m_maxThreadedJobs; ___81 const maxPossibleJobs = m_numDomains/MIN_THREADED_SUBZONE_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { for ( ItemAddress64::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* updateFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getSzCoordsByRange, this, 0 , m_numDomains/*size*/, ___2116, numJobs, boost::ref(szCoordByOriginalItem))); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(updateFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117); ___36.___4157(&___2117); } } else { getSzCoordsByRange(0 , m_numDomains/*___3266*/, 0/*___2116*/, 1/*numJobs*/, szCoordByOriginalItem); } } return ___2037; } std::pair<___81,___81> bisectionSize( ___37 const&                    ___36, ___4633                          zone, ItemAddress64::SectionOffset_t       section, ZoneType_e                           ___4689, OrthogonalBisection::BisectionType_e bisectionType) { REQUIRE(zone >= 0); REQUIRE(VALID_ENUM(___4689, ZoneType_e)); REQUIRE(bisectionType == OrthogonalBisection::BisectionType_ZoneCells || (bisectionType == OrthogonalBisection::BisectionType_ZoneNodes && section == 0)); ___1842 ___4629; ___36.___4612(zone + 1, ___4629); if (bisectionType == OrthogonalBisection::BisectionType_ZoneCells) { ___476(___3892(___4689, ___36.zoneGetDimension( ___36.datasetGetUniqueID(),zone + 1))); if (___4689 == ___4701) { return std::pair<___81,___81>(0,___4629.___1666()); } else { ___476(___4689 != ___4695 || ___4689 != ___4696); FECellShape_e         cellShape = FECellShape_Invalid; ___1170            gridOrder = 0; FECellBasisFunction_e basisFn = FECellBasisFunction_Invalid; ___4262 const datasetID = ___36.datasetGetUniqueID(); ___2225 baseSectionElem = 0; ___2225 numElements = 0; ___1170 numCornersPerElem = 0; ___1170 numNodesPerElem = 0; for (ItemAddress64::SectionOffset_t sec = 0; sec <= section; ++sec) { baseSectionElem += numElements; if (!___36.zoneGetSectionMetrics( datasetID, zone+1, sec+1, &cellShape, &gridOrder, &basisFn, &numElements, &numCornersPerElem, &numNodesPerElem)) throw std::runtime_error("Failed to acquire zone section metrics"); } return std::pair<___81,___81>(baseSectionElem,numElements); } } else { return std::pair<___81,___81>(0,___4629.___1668()); } } }}
