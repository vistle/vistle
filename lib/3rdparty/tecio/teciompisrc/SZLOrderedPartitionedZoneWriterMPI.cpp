#include "SZLOrderedPartitionedZoneWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <limits>
#include <boost/functional/hash.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicationCache.h"
#include "MPICommunicator.h"
#include "MPIFileWriter.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "MPIUtil.h"
#include "SZLOrderedPartitionWriter.h"
#include "TecioMPI.h"
#include "ZoneInfoCache.h"
using namespace tecplot::___3931; namespace tecplot { namespace ___3931 { std::size_t hash_value(___1842 const& ___1841) { std::size_t seed = 0; boost::hash_combine(seed, ___1841.i()); boost::hash_combine(seed, ___1841.___2103()); boost::hash_combine(seed, ___1841.___2132()); return seed; } }} namespace tecplot { namespace teciompi { struct SZLOrderedPartitionedZoneWriterMPI::Impl { typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, std::vector<___2477> > SubzoneMinMaxMap; struct NeighborExtents { SimpleVector<ItemAddress64::___2978> neighborPartitions; SimpleVector<uint64_t> neighborMinNodeNumbers; SimpleVector<uint64_t> neighborMaxNodeNumbers; }; typedef boost::unordered_map<ItemAddress64::___2978, NeighborExtents> NeighborExtentsMap; struct IJKExtents { ___1842 ___2472; ___1842 ___2362; IJKExtents() {} IJKExtents(___1842 const& ___2472, ___1842 const& ___2362) : ___2472(___2472) , ___2362(___2362) {} }; boost::unordered_map<ItemAddress64::___2978, IJKExtents> partitionExtentsMap; struct PartitionIntersection { ItemAddress64::___2978 ___2975; ItemAddress64::___2978 neighborPartition; IJKExtents extents; PartitionIntersection( ItemAddress64::___2978 ___2975, ItemAddress64::___2978 neighborPartition, ___1842 const& ___2472, ___1842 const& ___2362) : ___2975(___2975) , neighborPartition(neighborPartition) , extents(___2472, ___2362) {} }; struct SendOrder { bool operator() (PartitionIntersection const& a, PartitionIntersection const& b) { if (a.___2975 < b.___2975) return true; else if (a.___2975 == b.___2975 && a.neighborPartition < b.neighborPartition) return true; return false; } }; struct ReceiveOrder { bool operator() (PartitionIntersection const& a, PartitionIntersection const& b) { if (a.neighborPartition < b.neighborPartition) return true; else if (a.neighborPartition == b.neighborPartition && a.___2975 < b.___2975) return true; return false; } }; struct SubzoneMinMaxes { SimpleVector<ItemAddress64::SubzoneOffset_t> subzones; SimpleVector<___2477> varMinMaxes; }; typedef boost::unordered_map<ItemAddress64::___2978, SubzoneMinMaxes> NeighborMinMaxMap; typedef boost::unordered_map<ItemAddress64::___2978, NeighborMinMaxMap> PartitionMinMaxMap; SZLOrderedPartitionedZoneWriterMPI& m_outer; MPI_Comm m_comm; int m_mainProcess; int m_localProcess; bool m_useCollectiveRoutines; Impl( SZLOrderedPartitionedZoneWriterMPI& outer, MPI_Comm comm, int mainProcess, ___37& ___36, ___4633 zone) : m_outer(outer) , m_comm(comm) , m_mainProcess(mainProcess) , m_useCollectiveRoutines(everyRankOwnsOnePartition(comm, ___36, zone)) { MPI_Comm_rank(m_comm, &m_localProcess); createPartitionWriters(); } typedef std::map<ItemAddress64::___2978, boost::shared_ptr<___3931::___1879> > PartitionIJKInfoMap; void createPartitionWriters(); void sendLocalPartitionExtentsToMainProcess(PartitionIJKInfoMap& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection); void collectAllPartitionExtents(MPINonBlockingCommunicationCollection& communicationCollection);
void distributePartitionNeighborExtents(MPINonBlockingCommunicationCollection& communicationCollection); void receiveNeighborPartitionExtents( PartitionIJKInfoMap const& partitionijkInfoMap, MPINonBlockingCommunicationCollection& communicationCollection, NeighborExtentsMap& neighborExtentsMap); void calculateNeighborIntesections( NeighborExtentsMap const& neighborExtentsMap, std::vector<PartitionIntersection>& partitionIntersections); void applyCellMinMaxToNodeSubzones( ___2225 cellI, ___2225 cellJ, ___2225 cellK, boost::unordered_set<___1842> const& nodeSet, IJKSubzoneInfo const& subzoneInfo, ___1842 const& partitionMinIJK, std::vector<___2477> const& cellMinMaxes, SubzoneMinMaxMap& nszMinMaxMap); void sendMinMaxesToNeighbors( std::vector<PartitionIntersection>& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection); void receiveMinMaxesFromNeighbors( std::vector<PartitionIntersection> const& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection, PartitionMinMaxMap& partitionMinMaxMap); void applyReceivedMinMaxesToSubzones( PartitionMinMaxMap const& partitionMinMaxMap, size_t ___2841, PartitionIJKInfoMap& partitionIJKInfoMap); void exchangeGhostInfo(PartitionIJKInfoMap& partitionIJKInfoMap); }; SZLOrderedPartitionedZoneWriterMPI::SZLOrderedPartitionedZoneWriterMPI( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4633                   zone, ___4633                   ___341, std::vector<___372> const& ___4561, ___372                     ___4496, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache, MPI_Comm                      communicator, int                           mainProcess) : SZLOrderedPartitionedZoneWriter(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36, zoneInfoCache) , m_impl(new Impl(*this, communicator, mainProcess, ___36, zone)) {} SZLOrderedPartitionedZoneWriterMPI::~SZLOrderedPartitionedZoneWriterMPI() {} ___2477 SZLOrderedPartitionedZoneWriterMPI::varMinMax(___3931::___4349 datasetVar) { REQUIRE(m_varIter.baseItem() <= datasetVar && datasetVar < m_varIter.___2810()); ___2477 ___3356; ___4349 const baseVar = m_varIter.baseItem(); for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) ___3356.include(m_varPartitionMinMaxes[datasetVar - baseVar][___2975]); return ___3356; } namespace { std::vector<___1862> gatherPartitionTreeItems( UInt64Array const& minNodeNumbers, UInt64Array const& maxNodeNumbers, ___1842 const& zoneSize, ItemAddress64::___2978 numPartitions) { std::vector<___1862> ___2979; ___2979.reserve(numPartitions); for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { ___1842 partitionMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(minNodeNumbers[___2975])); ___1842 partitionMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(maxNodeNumbers[___2975])) + 1).minOp(zoneSize - 1);
___1851 ___2476(partitionMinIJK.i(), partitionMinIJK.___2103(), partitionMinIJK.___2132()); ___1851 ___2370(partitionMaxIJK.i(), partitionMaxIJK.___2103(), partitionMaxIJK.___2132()); ___2979.push_back(std::make_pair(___1853(___2476, ___2370), ___2975)); } return ___2979; } } void SZLOrderedPartitionedZoneWriterMPI::Impl::sendLocalPartitionExtentsToMainProcess( PartitionIJKInfoMap& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection) { ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); for (PartitionIJKInfoMap::iterator infoPair = partitionIJKInfoMap.begin(); infoPair != partitionIJKInfoMap.end(); ++infoPair) { communicationCollection.sendScalar(m_outer.m_partitionMinNodeNumbers[infoPair->first], m_mainProcess, TecioMPI::PARTITION_MIN_NODE_NUMBER); communicationCollection.sendScalar(m_outer.m_partitionMaxNodeNumbers[infoPair->first], m_mainProcess, TecioMPI::PARTITION_MAX_NODE_NUMBER); } } void SZLOrderedPartitionedZoneWriterMPI::Impl::collectAllPartitionExtents(MPINonBlockingCommunicationCollection& communicationCollection) { for (ItemAddress64::___2978 ___2975 = 0; ___2975 < static_cast<ItemAddress64::___2978>(m_outer.___2335.zoneGetNumPartitions(m_outer.___2675 + 1)); ++___2975) { int32_t owner = m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, ___2975 + 1); if (owner != m_localProcess) { communicationCollection.receiveScalar(m_outer.m_partitionMinNodeNumbers[___2975], owner, TecioMPI::PARTITION_MIN_NODE_NUMBER); communicationCollection.receiveScalar(m_outer.m_partitionMaxNodeNumbers[___2975], owner, TecioMPI::PARTITION_MAX_NODE_NUMBER); } } communicationCollection.___4443(); } void SZLOrderedPartitionedZoneWriterMPI::Impl::distributePartitionNeighborExtents(MPINonBlockingCommunicationCollection& communicationCollection) { ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); ItemAddress64::___2978 numPartitions = m_outer.___2335.zoneGetNumPartitions(m_outer.___2675 + 1); ___1861 partitionTree(gatherPartitionTreeItems(m_outer.m_partitionMinNodeNumbers, m_outer.m_partitionMaxNodeNumbers, zoneSize, numPartitions)); std::vector<ItemAddress64::___2978> neighborPartitions; std::vector<uint64_t> neighborMinNodes; std::vector<uint64_t> neighborMaxNodes; std::vector<___1862> neighborItems; for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { ___1842 partitionMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(m_outer.m_partitionMinNodeNumbers[___2975])); ___1842 partitionMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(m_outer.m_partitionMaxNodeNumbers[___2975])) + 1).minOp(zoneSize - 1); neighborItems.clear(); partitionTree.find(partitionMinIJK, partitionMaxIJK, neighborItems); neighborPartitions.clear(); neighborMinNodes.clear(); neighborMaxNodes.clear(); neighborPartitions.reserve(neighborItems.size()); neighborMinNodes.reserve(neighborItems.size());
neighborMaxNodes.reserve(neighborItems.size()); int32_t owner = m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, ___2975 + 1); for (std::vector<___1862>::const_iterator neighborItem = neighborItems.begin(); neighborItem != neighborItems.end(); ++neighborItem) { ItemAddress64::___2978 neighborPartition = neighborItem->second; if (neighborPartition != ___2975) { neighborPartitions.push_back(neighborPartition); neighborMinNodes.push_back(m_outer.m_partitionMinNodeNumbers[neighborPartition]); neighborMaxNodes.push_back(m_outer.m_partitionMaxNodeNumbers[neighborPartition]); } } communicationCollection.sendVectorCopy(neighborPartitions, owner, TecioMPI::PARTITION_NEIGHBORS_SIZE, TecioMPI::PARTITION_NEIGHBORS_VEC); communicationCollection.sendVectorCopy(neighborMinNodes, owner, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_VEC); communicationCollection.sendVectorCopy(neighborMaxNodes, owner, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_VEC); } } void SZLOrderedPartitionedZoneWriterMPI::Impl::receiveNeighborPartitionExtents( PartitionIJKInfoMap const& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection, NeighborExtentsMap& neighborExtentsMap) { for (PartitionIJKInfoMap::const_iterator infoPair = partitionIJKInfoMap.begin(); infoPair != partitionIJKInfoMap.end(); ++infoPair) { ItemAddress64::___2978 ___2975 = infoPair->first; communicationCollection.receiveVector(neighborExtentsMap[___2975].neighborPartitions, m_mainProcess, TecioMPI::PARTITION_NEIGHBORS_SIZE, TecioMPI::PARTITION_NEIGHBORS_VEC); communicationCollection.receiveVector(neighborExtentsMap[___2975].neighborMinNodeNumbers, m_mainProcess, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_VEC); communicationCollection.receiveVector(neighborExtentsMap[___2975].neighborMaxNodeNumbers, m_mainProcess, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_VEC); } communicationCollection.___4443(); } void SZLOrderedPartitionedZoneWriterMPI::Impl::calculateNeighborIntesections( NeighborExtentsMap const& neighborExtentsMap, std::vector<PartitionIntersection>& partitionIntersections) { REQUIRE(partitionIntersections.empty()); ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); for (NeighborExtentsMap::const_iterator neighborPair = neighborExtentsMap.begin(); neighborPair != neighborExtentsMap.end(); ++neighborPair) { ItemAddress64::___2978 ___2975 = neighborPair->first; ___1842 partitionMinIJK; ___1842 partitionMaxIJK; m_outer.getPartitionExtentsWithGhostNodes(___2975, partitionMinIJK, partitionMaxIJK); partitionExtentsMap[___2975] = IJKExtents(partitionMinIJK, partitionMaxIJK); NeighborExtents const& neighborExtents = neighborPair->second; for (int i = 0; i < neighborExtents.neighborPartitions.size(); ++i) { ItemAddress64::___2978 neighborPartition = neighborExtents.neighborPartitions[i];
___1842 neighborMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(neighborExtents.neighborMinNodeNumbers[i])); ___1842 neighborMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(neighborExtents.neighborMaxNodeNumbers[i])) + 1).minOp(zoneSize - 1); partitionExtentsMap[neighborPartition] = IJKExtents(neighborMinIJK, neighborMaxIJK); ___1851 partitionMinCorner(partitionMinIJK.i(), partitionMinIJK.___2103(), partitionMinIJK.___2132()); ___1851 partitionMaxCorner(partitionMaxIJK.i(), partitionMaxIJK.___2103(), partitionMaxIJK.___2132()); ___1853 partitionRange(partitionMinCorner, partitionMaxCorner); ___1851 neighborMinCorner(neighborMinIJK.i(), neighborMinIJK.___2103(), neighborMinIJK.___2132()); ___1851 neighborMaxCorner(neighborMaxIJK.i(), neighborMaxIJK.___2103(), neighborMaxIJK.___2132()); ___1853 neighborRange(neighborMinCorner, neighborMaxCorner); ___1853 intersectionRange; boost::geometry::intersection(partitionRange, neighborRange, intersectionRange); m_outer.throwIfBadIntersectionRange(intersectionRange, ___2975, neighborPartition); partitionIntersections.push_back( PartitionIntersection( ___2975, neighborPartition, ___1842(static_cast<___81>(intersectionRange.min_corner().get<0>()), static_cast<___81>(intersectionRange.min_corner().get<1>()), static_cast<___81>(intersectionRange.min_corner().get<2>())), ___1842(static_cast<___81>(intersectionRange.max_corner().get<0>()), static_cast<___81>(intersectionRange.max_corner().get<1>()), static_cast<___81>(intersectionRange.max_corner().get<2>())))); } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::applyCellMinMaxToNodeSubzones( ___2225 cellI, ___2225 cellJ, ___2225 cellK, boost::unordered_set<___1842> const& nodeSet, IJKSubzoneInfo const& subzoneInfo, ___1842 const& partitionMinIJK, std::vector<___2477> const& cellMinMaxes, SubzoneMinMaxMap& nszMinMaxMap) { for (___2225 ___2132 = 0; ___2132 <= 1; ++___2132) { for (___2225 ___2103 = 0; ___2103 <= 1; ++___2103) { for (___2225 i = 0; i <= 1; ++i) { ___1842 nodeIJK(static_cast<___81>(cellI + i), static_cast<___81>(cellJ + ___2103), static_cast<___81>(cellK + ___2132)); if (nodeSet.find(nodeIJK) != nodeSet.end()) { ___1842 partitionNodeIJK = nodeIJK - partitionMinIJK; ItemAddress64::SubzoneOffset_t ___3878 = subzoneInfo.szAddressAtItemIJK(partitionNodeIJK).subzoneOffset(); if (nszMinMaxMap[___3878].empty()) nszMinMaxMap[___3878].resize(cellMinMaxes.size()); for (size_t m = 0; m < cellMinMaxes.size(); ++m) { nszMinMaxMap[___3878][m].include(cellMinMaxes[m]); } } } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::sendMinMaxesToNeighbors( std::vector<PartitionIntersection>& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection) { ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); PartitionTecUtilDecorator partitionTecUtilDecorator(m_outer.___2335, m_outer.___2675 + 1); ___4349 const numVarsToWrite = m_outer.m_varIter.___2810(); for (size_t iPartition = 0; iPartition < partitionIntersections.size(); ++iPartition) { ItemAddress64::___2978 ___2975 = partitionIntersections[iPartition].___2975;
ItemAddress64::___2978 neighborPartition = partitionIntersections[iPartition].neighborPartition; IJKExtents intersectionExtents = partitionIntersections[iPartition].extents; IJKExtents const& partitionExtents = partitionExtentsMap[___2975]; IJKExtents const& neighborExtents = partitionExtentsMap[neighborPartition]; if (intersectionExtents.___2472.i() == partitionExtents.___2362.i() || intersectionExtents.___2472.___2103() == partitionExtents.___2362.___2103() || intersectionExtents.___2472.___2132() == partitionExtents.___2362.___2132()) { if (intersectionExtents.___2362.i() == neighborExtents.___2362.i() && intersectionExtents.___2362.i() < zoneSize.i() - 1) intersectionExtents.___2362.setI(intersectionExtents.___2362.i() - 1); if (intersectionExtents.___2362.___2103() == neighborExtents.___2362.___2103() && intersectionExtents.___2362.___2103() < zoneSize.___2103() - 1) intersectionExtents.___2362.setJ(intersectionExtents.___2362.___2103() - 1); if (intersectionExtents.___2362.___2132() == neighborExtents.___2362.___2132() && intersectionExtents.___2362.___2132() < zoneSize.___2132() - 1) intersectionExtents.___2362.___3495(intersectionExtents.___2362.___2132() - 1); if (intersectionExtents.___2472 <= intersectionExtents.___2362) { std::vector<___1350> nodalFieldDatas(numVarsToWrite); m_outer.retrieveNodalFieldDataPtrsForPartition(partitionTecUtilDecorator, ___2975, nodalFieldDatas); int32_t owner = m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, neighborPartition + 1); boost::unordered_set<___1842> nodeSet; for (___2225 ___2132 = intersectionExtents.___2472.___2132(); ___2132 <= intersectionExtents.___2362.___2132(); ++___2132) { for (___2225 ___2103 = intersectionExtents.___2472.___2103(); ___2103 <= intersectionExtents.___2362.___2103(); ++___2103) { for (___2225 i = intersectionExtents.___2472.i(); i <= intersectionExtents.___2362.i(); ++i) { ___1842 nodeIJK(static_cast<___81>(i), static_cast<___81>(___2103), static_cast<___81>(___2132)); nodeSet.insert(nodeIJK); } } } SubzoneMinMaxMap neighborMinMaxMap; ___1842 cellMinIJK( std::max(partitionExtents.___2472.i(), intersectionExtents.___2472.i() == 0 ? 0 : intersectionExtents.___2472.i() - 1), std::max(partitionExtents.___2472.___2103(), intersectionExtents.___2472.___2103() == 0 ? 0 : intersectionExtents.___2472.___2103() - 1), std::max(partitionExtents.___2472.___2132(), intersectionExtents.___2472.___2132() == 0 ? 0 : intersectionExtents.___2472.___2132() - 1)); ___1842 cellMaxIJK( std::min(partitionExtents.___2362.i() - 1, intersectionExtents.___2362.i()), std::min(partitionExtents.___2362.___2103() - 1, intersectionExtents.___2362.___2103()), std::min(partitionExtents.___2362.___2132() - 1, intersectionExtents.___2362.___2132())); std::vector<___2477> cellMinMaxes(nodalFieldDatas.size()); ___1842 partitionDimensionsIJK = partitionExtents.___2362 - partitionExtents.___2472 + 1; ___1842 neighborDimensionsIJK = neighborExtents.___2362 - neighborExtents.___2472 + 1; if (neighborExtents.___2362.i() < zoneSize.i() - 1) neighborDimensionsIJK.setI(neighborDimensionsIJK.i() - 1); if (neighborExtents.___2362.___2103() < zoneSize.___2103() - 1)
neighborDimensionsIJK.setJ(neighborDimensionsIJK.___2103() - 1); if (neighborExtents.___2362.___2132() < zoneSize.___2132() - 1) neighborDimensionsIJK.___3495(neighborDimensionsIJK.___2132() - 1); IJKSubzoneInfo neighborSubzoneInfo(neighborDimensionsIJK, DEFAULT_SUBZONE_MAX_IJK_DIM, neighborPartition, true); for (___2225 cellK = cellMinIJK.___2132(); cellK <= cellMaxIJK.___2132(); ++cellK) { for (___2225 cellJ = cellMinIJK.___2103(); cellJ <= cellMaxIJK.___2103(); ++cellJ) { for (___2225 cellI = cellMinIJK.i(); cellI <= cellMaxIJK.i(); ++cellI) { ___2225 ___460 = ((cellK - partitionExtents.___2472.___2132()) * partitionDimensionsIJK.___2103() + cellJ - partitionExtents.___2472.___2103()) * partitionDimensionsIJK.i() + cellI - partitionExtents.___2472.i(); m_outer.getCellMinMaxes(cellMinMaxes, ___460, partitionDimensionsIJK, nodalFieldDatas); applyCellMinMaxToNodeSubzones(cellI, cellJ, cellK, nodeSet, neighborSubzoneInfo, neighborExtents.___2472, cellMinMaxes, neighborMinMaxMap); } } } std::vector<ItemAddress64::SubzoneOffset_t> nodeSubzones; std::vector<___2477> minMaxValues; nodeSubzones.reserve(neighborMinMaxMap.size()); minMaxValues.reserve(neighborMinMaxMap.size() * nodalFieldDatas.size()); for (SubzoneMinMaxMap::const_iterator valuePair = neighborMinMaxMap.begin(); valuePair != neighborMinMaxMap.end(); ++valuePair) { nodeSubzones.push_back(valuePair->first); for (size_t i = 0; i < nodalFieldDatas.size(); ++i) minMaxValues.push_back(valuePair->second[i]); } communicationCollection.sendVectorCopy(nodeSubzones, owner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); communicationCollection.sendVectorCopy(minMaxValues, owner, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_SIZE, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_VEC); } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::receiveMinMaxesFromNeighbors( std::vector<PartitionIntersection> const& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection, PartitionMinMaxMap& partitionMinMaxMap) { ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); for (size_t i = 0; i < partitionIntersections.size(); ++i) { ItemAddress64::___2978 const ___2975 = partitionIntersections[i].___2975; ItemAddress64::___2978 const neighborPartition = partitionIntersections[i].neighborPartition; IJKExtents intersectionExtents = partitionIntersections[i].extents; IJKExtents const& partitionExtents = partitionExtentsMap[___2975]; if (intersectionExtents.___2362.i() == partitionExtents.___2362.i() && intersectionExtents.___2362.i() < zoneSize.i() - 1) intersectionExtents.___2362.setI(intersectionExtents.___2362.i() - 1); if (intersectionExtents.___2362.___2103() == partitionExtents.___2362.___2103() && intersectionExtents.___2362.___2103() < zoneSize.___2103() - 1) intersectionExtents.___2362.setJ(intersectionExtents.___2362.___2103() - 1); if (intersectionExtents.___2362.___2132() == partitionExtents.___2362.___2132() && intersectionExtents.___2362.___2132() < zoneSize.___2132() - 1) intersectionExtents.___2362.___3495(intersectionExtents.___2362.___2132() - 1);
if (intersectionExtents.___2472 <= intersectionExtents.___2362) { int32_t owner = m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, neighborPartition + 1); communicationCollection.receiveVector(partitionMinMaxMap[___2975][neighborPartition].subzones, owner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); communicationCollection.receiveVector(partitionMinMaxMap[___2975][neighborPartition].varMinMaxes, owner, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_SIZE, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_VEC); } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::applyReceivedMinMaxesToSubzones( PartitionMinMaxMap const& partitionMinMaxMap, size_t ___2841, PartitionIJKInfoMap& partitionIJKInfoMap) { for (PartitionMinMaxMap::const_iterator partitionNeighborPair = partitionMinMaxMap.begin(); partitionNeighborPair != partitionMinMaxMap.end(); ++partitionNeighborPair) { ItemAddress64::___2978 ___2975 = partitionNeighborPair->first; boost::shared_ptr<___1879> const& partitionIJKInfoPtr = partitionIJKInfoMap[___2975]; for (NeighborMinMaxMap::const_iterator neighborMinMaxPair = partitionNeighborPair->second.begin(); neighborMinMaxPair != partitionNeighborPair->second.end(); ++neighborMinMaxPair) { ItemAddress64::___2978 neighborPartition = neighborMinMaxPair->first; SubzoneMinMaxes const& subzoneMinMaxes = neighborMinMaxPair->second; if (subzoneMinMaxes.varMinMaxes.size() != static_cast<int>(___2841) * subzoneMinMaxes.subzones.size()) { std::ostringstream ___2890; ___2890 << "Mismatched var minmax array sizes (internal error)." << " Partition: " << ___2975 << " Neighbor partition: " << neighborPartition << " # subzones: " << subzoneMinMaxes.subzones.size() << " # vars: " << ___2841 << " # varMinMaxes: " << subzoneMinMaxes.varMinMaxes.size() << ". Please contact technical support."; throw std::runtime_error(___2890.str()); } std::vector<___2477> minMaxesForNode(___2841); for (int i = 0; i < subzoneMinMaxes.subzones.size(); ++i) { if (!partitionIJKInfoPtr->validNodeSubzone(subzoneMinMaxes.subzones[i])) { std::ostringstream ___2890; ___2890 << "Invalid node subzone (" << subzoneMinMaxes.subzones[i] << ") passed from partition " << neighborPartition << " to partition " << ___2975 << " (internal error). Please contact technical support."; throw std::runtime_error(___2890.str()); } for (size_t ___2103 = 0; ___2103 < ___2841; ++___2103) { ___476(i * ___2841 + ___2103 <= static_cast<size_t>(std::numeric_limits<int32_t>::max())); int ind = static_cast<int>(i * ___2841 + ___2103); minMaxesForNode[___2103] = subzoneMinMaxes.varMinMaxes[ind]; } partitionIJKInfoPtr->includeNszVarMinMax(subzoneMinMaxes.subzones[i], minMaxesForNode); } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::exchangeGhostInfo(PartitionIJKInfoMap& partitionIJKInfoMap) { MPINonBlockingCommunicationCollection communicationCollection(m_comm); if (m_localProcess == m_mainProcess) { collectAllPartitionExtents(communicationCollection); distributePartitionNeighborExtents(communicationCollection);
} else { sendLocalPartitionExtentsToMainProcess(partitionIJKInfoMap, communicationCollection); } NeighborExtentsMap neighborExtentsMap; receiveNeighborPartitionExtents(partitionIJKInfoMap, communicationCollection, neighborExtentsMap); std::vector<PartitionIntersection> partitionIntersections; calculateNeighborIntesections(neighborExtentsMap, partitionIntersections); std::sort(partitionIntersections.begin(), partitionIntersections.end(), SendOrder()); sendMinMaxesToNeighbors(partitionIntersections, communicationCollection); std::sort(partitionIntersections.begin(), partitionIntersections.end(), ReceiveOrder()); PartitionMinMaxMap partitionMinMaxMap; receiveMinMaxesFromNeighbors(partitionIntersections, communicationCollection, partitionMinMaxMap); communicationCollection.___4443(); applyReceivedMinMaxesToSubzones(partitionMinMaxMap, m_outer.m_varIter.___2810(), partitionIJKInfoMap); } void SZLOrderedPartitionedZoneWriterMPI::Impl::createPartitionWriters() { PartitionIJKInfoMap partitionIJKInfoMap; ItemAddress64::___2978 numPartitions = static_cast<ItemAddress64::___2978>(m_outer.___2335.zoneGetNumPartitions(m_outer.___2675 + 1)); ___1842 zoneSize; m_outer.___2335.___4612(m_outer.___2675 + 1, zoneSize); for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { if (m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, ___2975 + 1) == m_localProcess) { partitionIJKInfoMap[___2975] = m_outer.___2678.getIJKZonePartitionInfo(m_outer.___2675, ___2975); ___1842 partitionMinIJK; ___1842 partitionMaxIJK; m_outer.getPartitionExtentsWithoutGhostNodes(___2975, partitionMinIJK, partitionMaxIJK); m_outer.m_partitionMinNodeNumbers[___2975] = static_cast<uint64_t>(zoneSize.offsetAtIJK(partitionMinIJK)); m_outer.m_partitionMaxNodeNumbers[___2975] = static_cast<uint64_t>(zoneSize.offsetAtIJK(partitionMaxIJK)); } } exchangeGhostInfo(partitionIJKInfoMap); for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { if (m_outer.___2335.zonePartitionGetOwnerProcess(m_outer.___2675 + 1, ___2975 + 1) == m_localProcess) m_outer.m_partitionWriters[___2975] = boost::make_shared<SZLOrderedPartitionWriter>( m_outer.m_fileVersion, boost::ref(m_outer.m_varIter), m_outer.___2675, m_outer.m_baseZone, ___2975, boost::ref(m_outer.m_writeVariables), m_outer.m_writeConnectivity, boost::ref(m_outer.m_partitionTecUtil), partitionIJKInfoMap[___2975]); } } uint64_t SZLOrderedPartitionedZoneWriterMPI::zoneDataFileSize(bool ___2000) { uint64_t ___3356 = 0; MPICommunicator communicator(m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { uint64_t partitionFileSize; int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(___2000);
else communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); ___3356 += partitionFileSize; } } else { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { uint64_t partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(___2000); communicator.sendScalar(partitionFileSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); } } } return ___3356; } uint64_t SZLOrderedPartitionedZoneWriterMPI::zoneHeaderFileSize(bool ___2000) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLOrderedPartitionedZoneWriter::zoneHeaderFileSize(___2000); else return 0; } ___372 SZLOrderedPartitionedZoneWriterMPI::writeZoneData(___3931::FileWriterInterface& szpltFile) { ___1391 fileLoc = szpltFile.fileLoc(); boost::unordered_map<___4633, ___1391> partitionFileLocMap; uint64_t localPartitionFileSize = 0; if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1); ___4633 localPartition = m_partitionWriters.begin()->first; localPartitionFileSize = m_partitionWriters[localPartition]->zoneFileSize(szpltFile.___2000() == ___4224); gatherScatterPartitionFileLocs(fileLoc, partitionFileLocMap[localPartition], ___2335, ___2675, m_impl->m_localProcess, localPartitionFileSize, m_impl->m_mainProcess, m_impl->m_comm); } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { uint64_t partitionFileSize; int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { partitionFileLocMap[___2975] = fileLoc; partitionFileSize = m_partitionWriters[___2975]->zoneFileSize(szpltFile.___2000() == ___4224); } else { communicator.sendScalar(fileLoc, partitionOwner, TecioMPI::PARTITION_FILE_LOC); communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); } fileLoc += partitionFileSize; } } else { MPINonBlockingCommunicationCollection communicationCollection(m_impl->m_comm); for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { if (___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1) == m_impl->m_localProcess) { uint64_t partitionSize = m_partitionWriters[___2975]->zoneFileSize(szpltFile.___2000() == ___4224); communicationCollection.sendScalarCopy(partitionSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); communicationCollection.receiveScalar(partitionFileLocMap[___2975], m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_LOC); } } communicationCollection.___4443(); } if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1 && localPartitionFileSize > 0);
___4633 localPartition = m_partitionWriters.begin()->first; MPIFileWriter& fileWriter = dynamic_cast<MPIFileWriter&>(szpltFile); boost::scoped_ptr<MPIFileWriter::ScopedCaching> scopedCaching; try { scopedCaching.reset(new MPIFileWriter::ScopedCaching(fileWriter, localPartitionFileSize)); } catch (...) { } m_partitionWriters[localPartition]->writeZone(szpltFile, partitionFileLocMap[localPartition]); m_partitionHeaderFilePositions[localPartition] = m_partitionWriters[localPartition]->getZoneHeaderFilePosition(); MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[localPartition], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.addScalar(m_partitionMinNodeNumbers[localPartition], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.addScalar(m_partitionMaxNodeNumbers[localPartition], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2477> minMaxValues(m_varIter.___2810()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[localPartition]->varMinMax(datasetVar); } cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); SimpleVector<uint8_t> cachedData = cache.data(); int bytesPerPartition = cachedData.size(); std::vector<uint8_t> serializedCaches(static_cast<size_t>(bytesPerPartition) * ___2335.zoneGetNumPartitions(___2675 + 1)); MPI_Gather(&cachedData[0], bytesPerPartition, MPI_UINT8_T, serializedCaches.data(), bytesPerPartition, MPI_UINT8_T, m_impl->m_mainProcess, m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { MPICommunicationCache partitionCache(&serializedCaches[___2975 * bytesPerPartition], bytesPerPartition); int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); partitionCache.retrieveScalar(m_partitionHeaderFilePositions[partitionOwner], TecioMPI::PARTITION_HEADER_FILE_LOC); partitionCache.retrieveScalar(m_partitionMinNodeNumbers[partitionOwner], TecioMPI::PARTITION_MIN_NODE_NUMBER); partitionCache.retrieveScalar(m_partitionMaxNodeNumbers[partitionOwner], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2477> partitionMinMaxValues; partitionCache.retrieveVector(partitionMinMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(partitionMinMaxValues.size() == m_varIter.___2810()); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][partitionOwner] = partitionMinMaxValues[fileVar]; } } } } else { for (___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { int32_t partitionOwner = ___2335.zonePartitionGetOwnerProcess(___2675 + 1, ___2975 + 1); if (partitionOwner == m_impl->m_localProcess) { m_partitionWriters[___2975]->writeZone(szpltFile, partitionFileLocMap[___2975]);
m_partitionHeaderFilePositions[___2975] = m_partitionWriters[___2975]->getZoneHeaderFilePosition(); if (m_impl->m_localProcess == m_impl->m_mainProcess) { m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); m_varPartitionMinMaxes[datasetVar - baseVar][___2975] = m_partitionWriters[___2975]->varMinMax(datasetVar); } } else { MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[___2975], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.addScalar(m_partitionMinNodeNumbers[___2975], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.addScalar(m_partitionMaxNodeNumbers[___2975], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2477> minMaxValues(m_varIter.___2810()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[___2975]->varMinMax(datasetVar); } cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); MPICommunicator(m_impl->m_comm).sendVector(cache.data(), m_impl->m_mainProcess, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); } } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); SimpleVector<uint8_t> cachedData; communicator.receiveVector(cachedData, partitionOwner, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); MPICommunicationCache cache(cachedData); cache.retrieveScalar(m_partitionHeaderFilePositions[___2975], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.retrieveScalar(m_partitionMinNodeNumbers[___2975], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.retrieveScalar(m_partitionMaxNodeNumbers[___2975], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2477> minMaxValues; cache.retrieveVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(minMaxValues.size() == m_varIter.___2810()); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][___2975] = minMaxValues[fileVar]; } } } } if (m_impl->m_localProcess == m_impl->m_mainProcess) szpltFile.___3457(fileLoc);
 #if !defined NO_ASSERTS
if (m_impl->m_localProcess != m_impl->m_mainProcess) szpltFile.___3457(0);
 #endif
return ___4224; } ___372 SZLOrderedPartitionedZoneWriterMPI::writeZoneHeader(___3931::FileWriterInterface& szpltFile) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLOrderedPartitionedZoneWriter::writeZoneHeader(szpltFile); else return ___4224; } } }
