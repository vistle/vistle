#include "ThirdPartyHeadersBegin.h"
#include <float.h>
#include <algorithm>
#include <cctype>
#include <limits>
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include <set>
 #endif
#include <sstream>
#include <stdexcept>
#include <string>
#include <boost/assign.hpp>
 #if !defined TECIOMPI
#include <boost/atomic.hpp>
 #endif
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "exportSubzonePlt.h"
#include "AltTecUtil.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileStreamWriter.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include "FileSystem.h"
#include "ItemAddress.h"
#include "NodeMap.h"
 #endif
#include "TecplotVersion.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
#include "zoneUtil.h"
#include "ZoneVarMetadata.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactory.h"
 #define HEADER_STRING_FORMAT "%-14s"
 #define SZPLT_REVISION "$Revision: " ___4022 " $"
namespace tecplot { namespace ___3931 { namespace { char ___847(DataFileType_e ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); if (___842 == ___843) return 'F'; else if (___842 == ___844) return 'G'; else return 'S'; } } ___372 ___4513( FileWriterInterface& file, char const*          ___1405, uint32_t const       fileVersion, ___372            includeRevisionNumber, uint64_t             dataSetHeaderLocation) { REQUIRE(VALID_NON_ZERO_LEN_STR(___1405) && strlen(___1405) <= 7); REQUIRE(fileVersion <= 999); ___372 ___2037 = ___4224; try { size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; ___2037 = snprintf(headerBuffer, headerBufferSize, "#!%s %3.3" PRIu32 "%c%c", ___1405, fileVersion, file.___2000() ? 'T' : 'B', ___847(file.___842())) < static_cast<int>(headerBufferSize); std::string header(headerBuffer); if (includeRevisionNumber) header.append(" ").append(SZPLT_REVISION); ___2037 = ___2037 && file.fprintf(HEADER_STRING_FORMAT"\r\n", header.c_str()) >= SZPLT_FILE_HEADER_MIN_SIZE      && writeValue<uint64_t, true, 0>(file, ___1384, ___1383) && writeValue<uint64_t, true, 0>(file, ___893, dataSetHeaderLocation); } catch (std::bad_alloc const&) { ___2037 = ___1303; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 writeInitialDataSetHeader( FileWriterInterface& file, ___3943 const&   headerTagMap) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); ___3940 tagDescriptionMap = DATASET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___2837, static_cast<uint16_t>(headerTagMap.size())); UInt16Array tagArray; ___2037 = ___2037 && tagArray.alloc(headerTagMap.size()); if (___2037) { size_t numTags = 0; for (___3943::const_iterator value = headerTagMap.begin(); value != headerTagMap.end(); ++value) tagArray[numTags++] = value->first; ___2037 = ___2037 && ___4560<uint16_t, false, 0>(file, ___3941, ___2743, numTags, tagArray.data()); } for (___3943::const_iterator value = headerTagMap.begin(); value != headerTagMap.end(); ++value) ___2037 = ___2037 && writeValue<uint64_t, true, 0>(file, tagDescriptionMap[value->first].c_str(), value->second); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 writePerDataSetFileHeader( FileWriterInterface& szpltFile, ___3943&         ___3942, char const*          dataSetTitle) { REQUIRE(szpltFile.___2039()); REQUIRE(VALID_REF(dataSetTitle)); ___3942[DATA_SET_TITLE_TAG] = szpltFile.fileLoc(); uint32_t dataSetTitleLength = static_cast<uint32_t>(strlen(dataSetTitle)); ___372 ___2037 = writeValue<uint32_t, false, 0>(szpltFile, DATA_SET_TITLE_LENGTH, dataSetTitleLength) && ___4541(szpltFile, DATA_SET_TITLE_DESCRIPTION, dataSetTitle); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4542( FileWriterInterface& file,
char const*          ___970, size_t               ___2810, ___3814 const&   itemNames) { REQUIRE(file.___2039()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE(___2810>0); REQUIRE(itemNames.size() == ___2810); uint64_t totalStringListSize = 0; if (file.___2000()) totalStringListSize = ___206 + 2; for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) { totalStringListSize += itemNames[___2083].size(); if (file.___2000()) totalStringListSize += 2; else totalStringListSize += 1; } if (___970) { char ___1416[___206 + 1]; sprintf(___1416, "%sTotalSize", ___970); writeValue<uint64_t, false, 0>(file, ___1416, totalStringListSize); } else writeValue<uint64_t, false, 0>(file, NULL , totalStringListSize); ___372 ___2037 = ___4224; if (file.___2000()) { ___2037 = ___2037 && (file.fprintf("%*s\r\n", -___206, ___970) != 0); for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) ___2037 = ___2037 && (file.fprintf("%s\r\n", itemNames[___2083].c_str()) != 0); } else { for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) ___2037 = ___2037 && (file.fprintf("%s\r", itemNames[___2083].c_str()) != 0); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4538( FileWriterInterface&   file, ___3943&           ___3942, ___4349 const       ___2841, ___4704 const& ___4703) { REQUIRE(file.___2039()); REQUIRE(___4703.m_varNames.size() == size_t(___2841)); ___372 ___2037 = ___4224; if (___2841 > 0) { ___3942[___4362] = file.fileLoc(); ___2037 = ___4542(file, ___4361, ___2841, ___4703.m_varNames); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template <typename T> ___372 writeZoneSecTaggedArray( FileWriterInterface&                            file, ___3943&                                    ___3942, uint16_t                                        fileLocTag, char const*                                     ___970, ___4633                                     ___2844, ___2238<uint8_t> const&               zoneNumSections, ___2238<___2238<T> > const& zoneSecArray) { REQUIRE(file.___2039()); REQUIRE(VALID_REF(___970)); REQUIRE(___2844 == checked_numeric_cast<___4633>(zoneNumSections.size())); REQUIRE(zoneNumSections.size() == zoneSecArray.size()); ___372 ___2037 = ___4224; ___3942[fileLocTag] = file.fileLoc(); for (___4633 zone = 0; ___2037 && zone < ___2844; ++zone) { ___476(zoneNumSections[zone] == checked_numeric_cast<uint8_t>(zoneSecArray[zone].size())); if (zoneNumSections[zone] > 0) ___2037 = ___4560<T, false, 0>( file, ___970, ___2743, zoneNumSections[zone], zoneSecArray[zone].data()); } return ___2037; } } namespace { ___372 ___4540( FileWriterInterface&   file, uint32_t               fileVersion, ___3943&           ___3942, ___4633 const      ___2844, ___1390 const&    ___4626,
___4704 const& ___4703) { REQUIRE(file.___2039()); REQUIRE(fileVersion == 105 || fileVersion == 231 || fileVersion == 232); REQUIRE(___4703.m_zoneNames.size() == size_t(___2844)); ___372 ___2037 = ___4224; if (___2844 > 0) { ___3942[___4648] = file.fileLoc(); ___2037 = ___4542(file, ___4647, ___2844, ___4703.m_zoneNames); ___3942[ZONE_TYPE_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4560<char, false, 0>(file, ___4691, ___2743, ___2844, ___4703.m_zoneTypes.data()); ___3942[___4607] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, ___4606, ___2743, ___2844, ___4703.m_zoneFaceNeighborModes.data()); ___3942[___4673] = file.fileLoc(); ___2037 = ___2037 && ___4560<double, false, 0>(file, ___4672, ___2743, ___2844, ___4703.m_zoneSolutionTimes.data()); ___3942[___4683] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint32_t, false, 0>(file, ___4682, ___2743, ___2844, ___4703.m_zoneStrandIDs.data()); ___3942[___4667] = file.fileLoc(); ___2037 = ___2037 && ___4560<int32_t, false, 0>(file, ___4666, ___2743, ___2844, ___4703.m_zoneParentZones.data()); ___3942[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint64_t, false, 0>(file, ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION, ___2743, ___2844, ___4703.m_zoneIMaxOrNumNodes.data()); ___3942[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint64_t, false, 0>(file, ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION, ___2743, ___2844, ___4703.m_zoneJMaxOrNumCells.data()); ___3942[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint64_t, false, 0>(file, ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION, ___2743, ___2844, ___4703.m_zoneKMaxOrNumCorners.data()); ___3942[___4671] = file.fileLoc(); ___2037 = ___2037 && ___4560<int32_t, false, 0>(file, ___4670, ___2743, ___2844, ___4703.m_zoneShareConnectivityWithZone.data()); if (fileVersion >= 231) { ___3942[ZONE_NUM_SECTIONS_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, ZONE_NUM_SECTIONS_ARRAY_DESCRIPTION, ___2743, ___2844, ___4703.m_zoneNumSections.data()); if (fileVersion < 232) { ___476(fileVersion == 231); ___2238<UInt32Array> zoneNumElemsPerSec_uint32; ___2037 = zoneNumElemsPerSec_uint32.alloc(___2844); for (___4633 zone = 0; ___2037 && zone < ___2844; ++zone) { ___2037 = zoneNumElemsPerSec_uint32[zone].alloc(___4703.m_zoneNumSections[zone]);
for (uint8_t section = 0; section < ___4703.m_zoneNumSections[zone]; ++section) zoneNumElemsPerSec_uint32[zone][section] = checked_numeric_cast<uint32_t>( ___4703.m_zoneNumElemsPerSec[zone][section]); } ___2037 = ___2037 && writeZoneSecTaggedArray<uint32_t>(file, ___3942, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, zoneNumElemsPerSec_uint32); } else { ___2037 = ___2037 && writeZoneSecTaggedArray<int64_t>(file, ___3942, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneNumElemsPerSec); } ___2037 = ___2037 && writeZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_SHAPE_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneCellShapePerSec); ___2037 = ___2037 && writeZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG, ZONE_GRID_ORDER_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneGridOrderPerSec); ___2037 = ___2037 && writeZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_BASIS_FUNC_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneCellBasisFuncPerSec); } ___3942[___4627] = file.fileLoc(); ___2037 = ___2037 && ___4560<uint64_t, true, 0>(file, ___4625, ___2743, ___2844, ___4626.data()); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4539( FileWriterInterface&   file, ___3943&           ___3942, ___4349 const       ___2841, ___4633 const      ___2844, ___4704 const& ___4703) { REQUIRE(file.___2039()); if (___2844 == 0 || ___2841 == 0) return ___4224; REQUIRE(___4703.m_vzMinMaxes.size() == size_t(___2841)); REQUIRE(___4703.m_vzMinMaxes[0].size() == size_t(___2844) && ___4703.m_vzMinMaxes[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzMinMaxes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzValueLocations.size() == size_t(___2841)); REQUIRE(___4703.m_vzValueLocations[0].size() == size_t(___2844) && ___4703.m_vzValueLocations[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzValueLocations[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzFieldDataTypes.size() == size_t(___2841)); REQUIRE(___4703.m_vzFieldDataTypes[0].size() == size_t(___2844) && ___4703.m_vzFieldDataTypes[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzFieldDataTypes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzIsPassive.size() == size_t(___2841)); REQUIRE(___4703.m_vzIsPassive[0].size() == size_t(___2844) && ___4703.m_vzIsPassive[___2841 / 2].size() == size_t(___2844) &&
___4703.m_vzIsPassive[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzShareVarWithZone.size() == size_t(___2841)); REQUIRE(___4703.m_vzShareVarWithZone[0].size() == size_t(___2844) && ___4703.m_vzShareVarWithZone[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzShareVarWithZone[___2841 - 1].size() == size_t(___2844)); ___372 ___2037 = ___4224; ___3942[VAR_ZONE_MIN_MAX_FILE_LOC_TAG] = file.fileLoc(); bool minMaxesMustBeDouble = false; for (___4349 ___4333 = 0; !minMaxesMustBeDouble && ___4333 < ___2841; ++___4333) { for (___4633 zone = 0; !minMaxesMustBeDouble && zone < ___2844; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4703.m_vzFieldDataTypes[___4333][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32) minMaxesMustBeDouble = true; } } for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ++___4333) { if (minMaxesMustBeDouble) ___2037 = ___2037 && ___4525<double>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4333, ___2844, &___4703.m_vzMinMaxes[___4333][0], ___944 / 2); else ___2037 = ___2037 && ___4525<float>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4333, ___2844, &___4703.m_vzMinMaxes[___4333][0], ___944 / 2); } ___3942[___4390] = file.fileLoc(); for (___4349 ___4333 = 0; ___4333 < ___2841; ___4333++) ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, ___4389, ___4333, ___2844, &___4703.m_vzValueLocations[___4333][0]); ___3942[___4381] = file.fileLoc(); for (___4349 ___4333 = 0; ___4333 < ___2841; ___4333++) ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, ___4380, ___4333, ___2844, &___4703.m_vzFieldDataTypes[___4333][0]); ___3942[___4384] = file.fileLoc(); for (___4349 ___4333 = 0; ___4333 < ___2841; ___4333++) ___2037 = ___2037 && ___4560<uint8_t, false, 0>(file, ___4383, ___4333, ___2844, &___4703.m_vzIsPassive[___4333][0]); ___3942[___4387] = file.fileLoc(); for (___4349 ___4333 = 0; ___4333 < ___2841; ___4333++) ___2037 = ___2037 && ___4560<int32_t, false, 0>(file, ___4386, ___4333, ___2844, &___4703.m_vzShareVarWithZone[___4333][0]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 writeDataSetHeaders( FileWriterInterface&          szpltFile, uint32_t                      fileVersion, ___372                     dataSetIsAvailable, std::string const&            dataSetTitle, ___4349                    ___2841, ___4633                   ___2844, ___3943&                  headerTagMap, ___4704 const&        ___4703, ___1390 const&           szpltZoneHeaderFileLocs, ___934& ___933) { REQUIRE(szpltFile.___2039()); if (dataSetIsAvailable) { REQUIRE(___2841>0); REQUIRE(___4703.m_varNames.size() == size_t(___2841));
REQUIRE(___4703.m_varNames[0].size() > 0 && ___4703.m_varNames[___2841 / 2].size() > 0 && ___4703.m_varNames[___2841 - 1].size() > 0); REQUIRE(___2844>0); REQUIRE(___4703.m_zoneNames.size() == size_t(___2844)); REQUIRE(___4703.m_zoneNames[0].size() > 0 && ___4703.m_zoneNames[___2844 / 2].size() > 0 && ___4703.m_zoneNames[___2844 - 1].size() > 0); REQUIRE(szpltZoneHeaderFileLocs.size() == size_t(___2844)); REQUIRE(VALID_FILE_LOC(szpltZoneHeaderFileLocs[0]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2844 / 2]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2844 - 1])); REQUIRE(___4703.m_vzMinMaxes.size() == size_t(___2841)); REQUIRE(___4703.m_vzMinMaxes[0].size() == size_t(___2844) && ___4703.m_vzMinMaxes[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzMinMaxes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzValueLocations.size() == size_t(___2841)); REQUIRE(___4703.m_vzValueLocations[0].size() == size_t(___2844) && ___4703.m_vzValueLocations[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzValueLocations[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzValueLocations[0][0] < ___4326 && ___4703.m_vzValueLocations[___2841 / 2][___2844 / 2] < ___4326 && ___4703.m_vzValueLocations[___2841 - 1][___2844 - 1] < ___4326); REQUIRE(___4703.m_vzFieldDataTypes.size() == size_t(___2841)); REQUIRE(___4703.m_vzFieldDataTypes[0].size() == size_t(___2844) && ___4703.m_vzFieldDataTypes[___2841 / 2].size() == size_t(___2844) && ___4703.m_vzFieldDataTypes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4703.m_vzFieldDataTypes[0][0] < ___1367 && ___4703.m_vzFieldDataTypes[___2841 / 2][___2844 / 2] < ___1367 && ___4703.m_vzFieldDataTypes[___2841 - 1][___2844 - 1] < ___1367); } ___372 ___2037 = ___4224; try { uint64_t initialFileHeaderLoc = szpltFile.fileLoc(); ___2037 = ___2037 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2037 = ___2037 && writePerDataSetFileHeader(szpltFile, headerTagMap, dataSetTitle.c_str()); ___2037 = ___2037 && ___4540(szpltFile, fileVersion, headerTagMap, ___2844, szpltZoneHeaderFileLocs, ___4703); ___2037 = ___2037 && ___4538(szpltFile, headerTagMap, ___2841, ___4703); ___2037 = ___2037 && ___4539(szpltFile, headerTagMap, ___2841, ___2844, ___4703); uint64_t finalFileLoc = szpltFile.fileLoc(); ___2037 = ___2037 && szpltFile.___3457(initialFileHeaderLoc); ___2037 = ___2037 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2037 = ___2037 && szpltFile.___3457(finalFileLoc);
 #ifdef PROFILE_FILE_ACCESS
if (___2037) { FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778); }
 #else
___4276(___933);
 #endif
} catch(std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while writing file header."); } return ___2037; } ___372 ___4481( FileWriterInterface& file, uint32_t             numAuxData) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_AUX_DATA_MARKER_DESCRIPTION, SZPLT_AUX_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___233, numAuxData); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeAuxDataItem( FileWriterInterface& file, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, char const*          itemName, AuxDataType_e        itemType, char const*          itemValueString) { return writeValue<uint8_t, false, 0>(file, ___252, static_cast<uint8_t>(auxDataLocation)) && writeValue<uint32_t, false, 0>(file, ___239, static_cast<uint32_t>(auxDataEntity)) && writeValue<uint32_t, false, 0>(file, ___262, static_cast<uint32_t>(strlen(itemName))) && ___4541(file, ___261, itemName) && writeValue<uint8_t, false, 0>(file, ___268, static_cast<uint8_t>(itemType)) && writeValue<uint32_t, false, 0>(file, ___272, static_cast<uint32_t>(strlen(itemValueString))) && ___4541(file, ___271, itemValueString); } namespace { uint32_t countRetainedAuxDataItems(___264 auxData, ___37& ___36) { uint32_t ___3356 = 0; if (auxData) { int32_t ___2810 = ___36.___247(auxData); for (int32_t index = 1; index <= ___2810; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3359; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3359); if (___3359) ++___3356; ___36.___3815(&itemName); ___36.___3815(reinterpret_cast<char**>(&itemValue)); } } return ___3356; } uint32_t countAuxData( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter) { uint32_t numAuxData = 0; if (___36.___894()) { numAuxData = countRetainedAuxDataItems(___36.___235(), ___36); varIter.reset(); while (varIter.hasNext()) { ___4349 const datasetVar = varIter.next(); if (!___36.___4350(datasetVar + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___273(datasetVar + 1), ___36); } zoneIter.reset(); while (zoneIter.hasNext()) { ___4633 const ___902 = zoneIter.next(); if (!___36.___4635(___902 + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___274(___902 + 1), ___36); } } return numAuxData; } ___372 ___4480( FileWriterInterface& file, ___37&          ___36, ___264           auxData, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, uint32_t&            numItemsWritten)
{ REQUIRE(file.___2039()); REQUIRE(VALID_REF(auxData)); REQUIRE(VALID_ENUM(auxDataLocation, AuxDataLocation_e)); REQUIRE(auxDataEntity >= 0); int32_t ___2810 = ___36.___247(auxData); numItemsWritten = 0; ___372 ___2037 = ___4224; for (int32_t index = 1; ___2037 && index <= ___2810; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3359; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3359); ___476(itemType == ___270); if (___3359) { ++numItemsWritten; char const* itemValueString = reinterpret_cast<char const*>(itemValue); ___2037 = writeAuxDataItem(file, auxDataLocation, auxDataEntity, itemName, itemType, itemValueString); } ___36.___3815(&itemName); ___36.___3815(reinterpret_cast<char**>(&itemValue)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 writeAuxDataItems( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, ___4633          fileZoneOffset) { ___372 ___2037 = ___4224; if (___36.___894()) { ___264 auxData = ___36.___235(); uint32_t numItemsWritten = 0; if (auxData) { ___2037 = ___2037 && ___4480( file, ___36, auxData, ___253, 0, numItemsWritten); } varIter.reset(); ___4349 const baseVar = varIter.baseItem(); while (___2037 && varIter.hasNext()) { ___4349 const datasetVar = varIter.next(); ___4633 const fileVar = datasetVar - baseVar; auxData = ___36.___273(datasetVar + 1); if (auxData) { ___2037 = ___2037 && ___4480( file, ___36, auxData, ___258, fileVar + 1, numItemsWritten); } } zoneIter.reset(); while (___2037 && zoneIter.hasNext()) { ___4633 const ___902 = zoneIter.next(); ___4633 const fileZone = ___902 + fileZoneOffset; if (!___36.___4635(___902 + 1)) continue; auxData = ___36.___274(___902 + 1); if (auxData) { ___2037 = ___2037 && ___4480( file, ___36, auxData, ___259, fileZone + 1, numItemsWritten); } } } return ___2037; } ___372 ___4479( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___241] = file.fileLoc(); uint32_t numAuxData = countAuxData(___36, varIter, zoneIter); ___372 ___2037 = ___4481(file, numAuxData); ___2037 = ___2037 && writeAuxDataItems(file, ___36, varIter, zoneIter, -zoneIter.baseItem()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4519( FileWriterInterface& file, uint32_t             numGeoms) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_GEOMETRY_MARKER_DESCRIPTION, SZPLT_GEOMETRY_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, NUM_GEOMS_DESCRIPTION, numGeoms);
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4520( FileWriterInterface& file, ___37&          ___36, GeomID_t             geomID) { REQUIRE(file.___2039()); uint32_t ___2833 = (uint32_t)___36.___1618(geomID); bool is3D = (___36.___1601(geomID) == CoordSys_Grid3D); ___372 ___2037 = writeValue<uint32_t, false, 0>(file, ___1621, ___2833); for(uint32_t segment = 0; ___2037 && segment < ___2833; ++segment) { uint32_t numPts = (uint32_t)___36.___1617(geomID, static_cast<int32_t>(segment + 1)); ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1620, numPts) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2037 = ___2037 && zPts.alloc(static_cast<uint64_t>(numPts)); for(uint32_t i = 0; i < numPts; ++i) { if (is3D) ___36.___1558(geomID, static_cast<int32_t>(segment + 1), static_cast<___2225>(i + 1), &xPts[i], &yPts[i], &zPts[i]); else ___36.___1555(geomID, static_cast<int32_t>(segment + 1), static_cast<___2225>(i + 1), &xPts[i], &yPts[i]); } ___2037 = ___2037 && ___4560<double, false, 0>(file, ___1652, segment, static_cast<size_t>(numPts), xPts.data()) && ___4560<double, false, 0>(file, ___1654, segment, static_cast<size_t>(numPts), yPts.data()); if (is3D) ___2037 && ___4560<double, false, 0>(file, ___1657, segment, static_cast<size_t>(numPts), zPts.data()); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countGeoms(___37& ___36) { uint32_t numGeoms = 0; for (GeomID_t geomID = ___36.___1590(); geomID != ___4033; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ++numGeoms; } return numGeoms; } ___372 ___4518( FileWriterInterface& file, ___37&          ___36, GeomID_t             geomID, int32_t              fileZoneOffset) { REQUIRE(file.___2039()); double ___4571; double ___4588; double ___4712; ___36.___1589(geomID, &___4571, &___4588, &___4712); ___372 ___2037 = writeValue<double, false, 0>(file, ___1651, ___4571) && writeValue<double, false, 0>(file, ___1653, ___4588) && writeValue<double, false, 0>(file, ___1656, ___4712); uint8_t ___3157 = (uint8_t)___36.___1601(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1625, ___3157); uint8_t ___2002 = ___36.___1608(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1609, ___2002); ___4633 zone = ___36.___1605(geomID); ___2037 = ___2037 && writeValue<int32_t, false, 0>(file, ___1655, zone + fileZoneOffset); uint16_t color = (uint16_t)___36.___1592(geomID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1569, color); uint16_t ___1409 = (uint16_t)___36.___1594(geomID);
___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1580, ___1409); uint8_t ___2020 = (uint8_t)___36.___1595(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1610, ___2020); uint8_t ___1649 = (uint8_t)___36.___1604(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, GEOM_GEOM_TYPE, ___1649); uint8_t ___2261 = (uint8_t)___36.___1596(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1611, ___2261); double ___2984 = ___36.___1600(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1623, ___2984); double ___2287 = ___36.___1597(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1612, ___2287); if (___1649 == (uint8_t)GeomType_Circle || ___1649 == (uint8_t)GeomType_Ellipse) { uint16_t ___2791 = static_cast<uint16_t>(___36.___1574(geomID)); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1619, ___2791); } else { ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1619, 0); } if (___1649 == (uint8_t)GeomType_LineSegs) { uint8_t arrowheadStyle = (uint8_t)___36.___1565(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1567, arrowheadStyle); uint8_t arrowheadAttachment = (uint8_t)___36.___1563(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1561, arrowheadAttachment); double arrowheadSize = ___36.___1564(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1566, arrowheadSize); double arrowheadAngle = ___36.___1562(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1560, arrowheadAngle); } else { ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1567, 0); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1561, 0); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1566, 0); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1560, 0); } uint8_t geomScope = (uint8_t)___36.___1603(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1631, geomScope); uint8_t geomClipping = (uint8_t)___36.___1591(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, GEOM_CLIPPING, geomClipping); char* ___2328 = 0; if (___36.___1598(geomID, &___2328) && ___2328 != 0) { uint32_t length = static_cast<uint32_t>(strlen(___2328)); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1614, length); if (length > 0) ___4541(file, ___1613, ___2328); ___36.___3815(&___2328); } else { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1614, 0);
} switch (___36.___1604(geomID)) { case GeomType_LineSegs: { ___2037 = ___2037 && ___4520(file, ___36, geomID); } break; case GeomType_Rectangle: { double ___4455; double ___1824; ___36.___1626(geomID, &___4455, &___1824); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1628, ___4455) && writeValue<double, false, 0>(file, ___1627, ___1824); } break; case GeomType_Square: { ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1647, ___36.___1646(geomID)); } break; case GeomType_Circle: { ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1606, ___36.___1568(geomID)); } break; case GeomType_Ellipse: { double horizontalAxis; double verticalAxis; ___36.___1575(geomID, &horizontalAxis, &verticalAxis); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1576, horizontalAxis) && writeValue<double, false, 0>(file, ___1577, verticalAxis); } break; default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeGeomItems( FileWriterInterface& file, ___37&          ___36, int32_t              fileZoneOffset) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; for(GeomID_t geomID = ___36.___1590(); ___2037 && geomID != ___4033; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ___2037 = ___4518(file, ___36, geomID, fileZoneOffset); } return ___2037; } ___372 ___4521( FileWriterInterface& file, ___37&          ___36, ___4633          ___341, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___1579] = file.fileLoc(); uint32_t numGeoms = countGeoms(___36); ___372 ___2037 = ___4519(file, numGeoms); ___2037 = ___2037 && writeGeomItems(file, ___36, -___341); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countTexts(___37& ___36) { uint32_t numTexts = 0; for (TextID_t textID = ___36.___4085(); textID != ___4033; textID = ___36.___4091(textID)) ++numTexts; return numTexts; } ___372 ___4544( FileWriterInterface& file, uint32_t             numTexts) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_TEXT_MARKER_DESCRIPTION, SZPLT_TEXT_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, NUM_TEXTS_DESCRIPTION, numTexts); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4543( FileWriterInterface& file, ___37&          ___36, TextID_t             textID, int32_t              fileZoneOffset) { REQUIRE(file.___2039()); double ___4571 = 0.0; double ___4588 = 0.0; double ___4712 = 0.0; ___36.___4083(textID, &___4571, &___4588, &___4712); ___372 ___2037 = writeValue<double, false, 0>(file, ___4134, ___4571) && writeValue<double, false, 0>(file, ___4135, ___4588) &&
writeValue<double, false, 0>(file, ___4138, ___4712); uint16_t ___4078 = (uint16_t)___36.___4087(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4080, ___4078); uint16_t ___4057 = (uint16_t)___36.___4062(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4058, ___4057); uint16_t ___4059 = (uint16_t)___36.___4063(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4060, ___4059); double ___4069 = ___36.___4064(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4070, ___4069); double ___4071 = ___36.___4065(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4072, ___4071); uint8_t ___4076 = (uint8_t)___36.___4066(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, TEXT_BOX_TYPE, ___4076); uint8_t ___4041 = (uint8_t)___36.___4082(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4042, ___4041); double ___4054 = ___36.___4084(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4055, ___4054); uint8_t ___4077 = (uint8_t)___36.___4086(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, TEXT_CLIPPING, ___4077); double ___4101 = ___36.___4088(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, TEXT_HEIGHT, ___4101); double ___4105 = ___36.___4089(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4106, ___4105); uint8_t ___4113 = (uint8_t)___36.___4092(textID); ___2037 = ___2037 &&  writeValue<uint8_t, false, 0>(file, ___4114, ___4113); uint8_t ___4117 = (uint8_t)___36.___4094(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4118, ___4117); uint8_t ___4122 = (uint8_t)___36.___4095(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4123, ___4122); char* ___4124 = 0; ___36.___4096(textID, &___4124); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4126, static_cast<uint32_t>(strlen(___4124))); if (strlen(___4124) > 0) ___2037 = ___2037 && ___4541(file, ___4125, ___4124); ___36.___3815(&___4124); char* ___4127 = ___36.___4097(textID); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4129, static_cast<uint32_t>(strlen(___4127))); if (strlen(___4127) > 0) ___2037 = ___2037 && ___4541(file, ___4128, ___4127); ___36.___3815(&___4127); uint8_t ___4130 = (uint8_t)___36.___4098(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4131, ___4130); uint8_t ___4132 = (uint8_t)___36.___4099(textID);
___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4133, ___4132); int32_t ___4136 = (int32_t)___36.___4100(textID); ___2037 = ___2037 && writeValue<int32_t, false, 0>(file, ___4137, ___4136 + fileZoneOffset); uint8_t ___4103 = (uint8_t)___36.___4103(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4104, ___4103); char* ___4107 = 0; if (___36.___4090(textID, &___4107) && ___4107 != 0) { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4109, static_cast<uint32_t>(strlen(___4107))); if (strlen(___4107) > 0) ___2037 = ___2037 && ___4541(file, ___4108, ___4107); ___36.___3815(&___4107); } else { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4109, 0); } ___36.___3815(&___4107); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeTextItems( FileWriterInterface& file, ___37&          ___36, int32_t              fileZoneOffset) { ___372 ___2037 = ___4224; for (TextID_t textID = ___36.___4085(); ___2037 && textID != ___4033; textID = ___36.___4091(textID)) ___2037 = ___4543(file, ___36, textID, fileZoneOffset); return ___2037; } ___372 ___4545( FileWriterInterface& file, ___37&          ___36, ___4633          ___341, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___4081] = file.fileLoc(); uint32_t numTexts = countTexts(___36); ___372 ___2037 = ___4544(file, numTexts); ___2037 = ___2037 && writeTextItems(file, ___36, -___341); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countCustomLabelSets(___37& ___36) { uint32_t numCustomLabelSets = 0; if (___36.___894()) numCustomLabelSets = ___36.___795(); return numCustomLabelSets; } ___372 ___4501( FileWriterInterface& file, uint32_t             numCustomLabelSets) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION, SZPLT_CUSTOM_LABELS_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___791, numCustomLabelSets); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4500( FileWriterInterface& file, ___37&          ___36, int32_t              customLabelNum) { REQUIRE(file.___2039()); ___3837 ___2169 = 0; ___3814 customLabels; ___372 ___2037 = ___36.___794(&___2169, customLabelNum); int32_t numLabels = 0; if (___2037) { numLabels = (int32_t)___36.___3830(___2169); ___2037 = ___2037 && customLabels.alloc(static_cast<uint64_t>(numLabels)) && writeValue<uint32_t, false, 0>(file, ___2818, numLabels);
} for(int32_t i = 1; ___2037 && i <= ___36.___3830(___2169); ++i) { char* label = ___36.___3831(___2169, i); customLabels[i - 1] = label; ___36.___3815(&label); } ___2037 = ___2037 && ___4542(file, ___792, (size_t)numLabels, customLabels); if (___2169) ___36.___3825(&___2169); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeCustomLabelSets( FileWriterInterface& file, ___37&          ___36) { ___372 ___2037 = ___4224; uint32_t numCustomLabelSets = countCustomLabelSets(___36); for (uint32_t customLabelNum = 1; ___2037 && customLabelNum <= numCustomLabelSets; ++customLabelNum) ___2037 = ___4500(file, ___36, static_cast<int32_t>(customLabelNum)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4499( FileWriterInterface& file, ___37&          ___36, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___793] = file.fileLoc(); uint32_t numCustomLabelSets = countCustomLabelSets(___36); ___372 ___2037 = ___4501(file, numCustomLabelSets); ___2037 = ___2037 && writeCustomLabelSets(file, ___36); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
namespace { ___372 ___2879( std::string const& pltFileName, ___4633        zone, char const*        ___2502, FILE*&             fileHandle) { REQUIRE(!pltFileName.empty()); REQUIRE(zone>=0); REQUIRE(VALID_NON_ZERO_LEN_STR(___2502)); REQUIRE(fileHandle==NULL); char histogramFileName[1000]; sprintf(histogramFileName, "%s.zone%" PRIu64 ".histogram.csv", pltFileName.c_str(), uint64_t(zone+1)); ___372 ___2037 = ___4224; fileHandle = tecplot::filesystem::fileOpen(histogramFileName, ___2502); if (fileHandle == NULL) ___2037 = ___1184("Cannot open histogram file %s", histogramFileName); return ___2037; } }
 #endif
 #ifdef DO_SUBZONE_HISTOGRAM
___372 OutputSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4633       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2037 = ___4224; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ItemAddress64::SubzoneOffset_t const ___2781 = ___1347->___2781(); ItemAddress64::SubzoneOffset_t const ___2821 = ___1347->___2821(); SubzoneOffsetArray cszRefsByNszHistogram; SubzoneOffsetArray nszRefsByCszHistogram; ___2037 = ___2037 && cszRefsByNszHistogram.alloc(___2781+1, ItemAddress64::SubzoneOffset_t(0)); ___2037 = ___2037 && nszRefsByCszHistogram.alloc(___2821+1, ItemAddress64::SubzoneOffset_t(0)); SubzoneOffsetSetArray cszRefsByNsz; ___2037 = ___2037 && cszRefsByNsz.alloc(___2821); if (___2037) { ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone+1); if (!___2721->___2065()) return ___1303; CellNodeIndex_t const numNodesPerCell = ___1347->getNumNodesPerCell(section); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) { SubzoneOffsetSet nszRefs; ItemAddress64::ItemOffset_t const ___2780 = ___1347->___2780(___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ItemAddress64 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4605(___686); ___476(datasetCell<___1347->___1764()); for (CellNodeIndex_t nOffset = 0; nOffset < numNodesPerCell; nOffset++) { ___2716 const datasetNode = ___2721->___1761(datasetCell+1, nOffset+1) - 1; ___476(datasetNode<___1347->___1766()); ItemAddress64 const ___2757 = ___1347->___3922(datasetNode); ItemAddress64::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); nszRefs.insert(___2732); cszRefsByNsz[___2732].insert(___467); } } if (___2037) { size_t const numNszRefs = nszRefs.size(); ___476(numNszRefs<nszRefsByCszHistogram.size()); nszRefsByCszHistogram[numNszRefs]++; } } for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) { size_t const numCszRefs = cszRefsByNsz[___2732].size(); ___476(numCszRefs<cszRefsByNszHistogram.size()); cszRefsByNszHistogram[numCszRefs]++; } } if (___2037) { FILE* histogramFile = NULL; ___2037 = ___2879(szpltFileName, zone, "wt", histogramFile); if (___2037) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1764()), uint64_t(___2781), uint64_t(___1347->___1766()), uint64_t(___2821)); fprintf(histogramFile,"\nNszs per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodeSubzonesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2821; nodeSubzoneCount++)
if (nszRefsByCszHistogram[nodeSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nszRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCszs per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellSubzonesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2781; cellSubzoneCount++) if (cszRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cszRefsByNszHistogram[cellSubzoneCount])); } ___4193(histogramFile); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif
 #ifdef DO_ITEMANDSUBZONE_HISTOGRAM
___372 OutputItemAndSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4633       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2037 = ___4224; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ___463 const ___2779 = ___1347->___1764(); ___2716 const ___2819 = ___1347->___1766(); ___462 cellRefsByNszHistogram; ___2715 nodeRefsByCszHistogram; ___2037 = ___2037 && cellRefsByNszHistogram.alloc(___2779+1, ___463(0)); ___2037 = ___2037 && nodeRefsByCszHistogram.alloc(___2819+1, ___2716(0)); typedef std::set<___463> CellIndexSet; ___2238<CellIndexSet> cellsRefsByNsz; ___2037 = ___2037 && cellsRefsByNsz.alloc(___2819); if (___2037) { ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone+1); if (!___2721->___2065()) return ___1303; CellNodeIndex_t const numNodesPerCell = ___1347->getNumNodesPerCell(section); ItemAddress64::SubzoneOffset_t const ___2781 = ___1347->___2781(); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) { CellIndexSet nodeRefs; ItemAddress64::ItemOffset_t const ___2780 = ___1347->___2780(___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ItemAddress64 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4605(___686); ___476(datasetCell < ___2779); for (CellNodeIndex_t nOffset = 0; nOffset < numNodesPerCell; nOffset++) { ___2716 const datasetNode = ___2721->___1761(datasetCell+1, nOffset+1) - 1; ___476(datasetNode<___2819); ItemAddress64 const ___2757 = ___1347->___3922(datasetNode); ItemAddress64::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); nodeRefs.insert(datasetNode); cellsRefsByNsz[___2732].insert(datasetCell); } } if (___2037) { size_t const numNodeRefs = nodeRefs.size(); ___476(numNodeRefs < nodeRefsByCszHistogram.size()); nodeRefsByCszHistogram[numNodeRefs]++; } } ItemAddress64::SubzoneOffset_t const ___2821 = ___1347->___2821(); for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) { size_t const numCellRefs = cellsRefsByNsz[___2732].size(); ___476(numCellRefs < cellRefsByNszHistogram.size()); cellRefsByNszHistogram[numCellRefs]++; } } if (___2037) { FILE* histogramFile = NULL; ___2037 = ___2879(szpltFileName, zone, "at", histogramFile); if (___2037) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1764()), uint64_t(___2779), uint64_t(___1347->___1766()), uint64_t(___2819)); fprintf(histogramFile,"\nNodes per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2819; nodeSubzoneCount++)
if (nodeRefsByCszHistogram[nodeSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nodeRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCells per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellsReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2779; cellSubzoneCount++) if (cellRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cellRefsByNszHistogram[cellSubzoneCount])); } ___4193(histogramFile); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif
namespace { inline ___372 ___477(___37& ___36) { ___372 ___2037 = ___4224; if (!___36.___894() && ___36.___1590() == ___4033 && ___36.___4085() == ___4033) ___2037 = ___1184("Cannot export dataset: The active frame has no data, texts or geoms to export."); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline ___372 ___479(___37& ___36, ___4349  ___4333) { REQUIRE(___36.___894()); REQUIRE(___4333<___36.___888()); ___372 ___2037 = ___4224; if (!___36.___4350(___4333 + 1)) ___2037 = ___1184("Cannot export dataset: Variable %" PRIu64 " is disabled and cannot be exported.", uint64_t(___4333 + 1)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline ___372 ___481(___37& ___36, ___4633 zone) { REQUIRE(___36.___894()); REQUIRE(zone < ___36.___889()); ___372 ___2037 = ___4224; if (!___36.___4635(zone + 1)) ___2037 = ___1184("Cannot export dataset: Zone %" PRIu64 " is disabled and cannot be exported.", uint64_t(zone + 1)); else if ((___4643(___36, zone) || ___4640(___36, zone)) && !___4639(___36, zone) && !___4641(___36, zone)) ___2037 = ___1184("Cannot export dataset: Zone %" PRIu64 " is unsupported type", uint64_t(zone + 1)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___478( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, DataFileType_e   ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); ___372 ___2037 = ___477(___36); if (___2037) { ___4349 const numVarsToWrite = varIter.___2810(); varIter.reset(); while (___2037 && varIter.hasNext()) ___2037 = ___479(___36, varIter.next()); ___372 hasVolumeZones     = ___1303; ___372 atLeastOneZoneIsFE = ___1303; zoneIter.reset(); while (___2037 && zoneIter.hasNext()) { ___4633 const ___902 = zoneIter.next(); if (___4643(___36, ___902)) hasVolumeZones = ___4224; if (___36.___4637(___902 + 1)) atLeastOneZoneIsFE = ___4224; ___2037 = ___481(___36, ___902); } if (___2037 && hasVolumeZones) { if ((___842 != ___846) && (numVarsToWrite < 3                 || !___36.___4350(1) || !___36.___4350(2) || !___36.___4350(3))) { ___2037 = ___1303; ___1184("Err:  Variables 1,2 and 3 are needed to calculate subzones and must be enabled to export a szplt file"); } else if (___36.___1511() == ___3113) { if (___842 != ___846 && atLeastOneZoneIsFE && (___36.___4342('X') != 1 || ___36.___4342('Y') != 2 || ___36.___4342('Z') != 3)) { ___1929("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n"
"The X,Y,Z axis assignments in the current frame are not the first 3 variables and thus the resulting subzone distribution may not be optimal"); } } else if (___842 != ___846) { ___1929("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n" "If the first 3 variables in the current dataset do not represent X,Y, and Z the resulting subzone distribution may not be optimal"); } } } return ___2037; } } namespace { ___372 ___25( ___1390& szpltZoneHeaderFileLocs, ___37&   ___36, ___4633   ___2844, bool          fillWithValidValues) { szpltZoneHeaderFileLocs.___935(); return IMPLICATION(___36.___894(), szpltZoneHeaderFileLocs.alloc( ___2844, fillWithValidValues ? ___1391(0): ___330)); } } namespace { ___3943 initializedHeaderTagMap( uint32_t                    fileVersion, ___4633                 numZonesToWrite, ___4349                  numVarsToWrite, uint64_t                    numPartitionFiles, ___1842 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t maxFESubzoneSize) { REQUIRE(fileVersion == 105 || fileVersion == 231 || fileVersion == 232); ___3943 headerTagMap = DATASET_HEADER_TAG_MAP_V105_INITIALIZER; if (fileVersion > 105) { ___3943 const headerTagMap_v231 = DATASET_HEADER_TAG_MAP_V231_INITIALIZER; headerTagMap.insert(headerTagMap_v231.begin(), headerTagMap_v231.end()); } headerTagMap[___2847]           = static_cast<uint64_t>(numZonesToWrite); headerTagMap[___2843]            = static_cast<uint64_t>(numVarsToWrite); headerTagMap[SUBZONE_MAX_I_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.i()); headerTagMap[SUBZONE_MAX_J_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2103()); headerTagMap[SUBZONE_MAX_K_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2132()); headerTagMap[SUBZONE_MAX_FE_SIZE_TAG] = static_cast<uint64_t>(maxFESubzoneSize); if (numPartitionFiles > 0) headerTagMap[NUM_PARTITION_FILES_TAG] = numPartitionFiles; return headerTagMap; } } ___372 ___1240( ___37&                   ___36, FileWriterInterface&          szpltFile, ___1386 const&        ___1385, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3499                        vars, ___3499                        ___4668, ___934& ___933) { REQUIRE(szpltFile.___2039()); REQUIRE(___1385.getFileVersion() == 105 || ___1385.getFileVersion() == 231 || ___1385.getFileVersion() == 232); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4668));
 #if !defined TECIOMPI
REQUIRE(boost::atomic<double>().is_lock_free());
 #endif
szpltFile.___3492(___1385.___2000()); szpltFile.setDataFileType(___1385.___842()); ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4668); ___372 ___2037 = ___478(___36, varIter, zoneIter, szpltFile.___842()); if (___2037) { ___36.___3777("Exporting szplt file...", ___4224 , ___4224/*___3578*/); ___2037 = ___2037 && ___36.___3767(0); ___4349 numVarsToWrite = 0; ___4633 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2810(); numZonesToWrite = zoneIter.___2810(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } ___1390 szpltZoneHeaderFileLocs; ___2037 = ___2037 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, true); try { ___3943 headerTagMap = initializedHeaderTagMap( ___1385.getFileVersion(), numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1755(), ___1385.___1754()); ___2037 = ___2037 && ___4513(szpltFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, 0); ___4479(szpltFile, ___36, varIter, zoneIter, headerTagMap) && ___4521(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4545(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4499(szpltFile, ___36, headerTagMap); ___2037 = ___2037 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && dataSetWriter.writeDataSet(szpltFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs) && szpltFile.seekToFileEnd(); if (___2037) { uint64_t dataSetHeaderLocation = szpltFile.fileLoc(); ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4175 = 0; ___36.datasetGetTitle(&___4175); dataSetTitle = ___4175; ___36.___3815(&___4175); } ___2037 = ___2037 && writeDataSetHeaders(szpltFile, ___1385.getFileVersion(), dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4703(), szpltZoneHeaderFileLocs, ___933) && szpltFile.___3458() && ___4513(szpltFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, dataSetHeaderLocation); }
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778);
 #endif
} catch (std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2890; ___2890 << "Error encountered while writing file: " << e.what(); ___2037 = ___1184(___2890.str().c_str()); } catch (...) { ___2037 = ___1184("Unrecoverable error while writing file."); } ___36.___3768(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeIntermediateFiles( ___37&                   ___36, FileWriterInterface&          headerFile, FileWriterInterface&          zoneFile, FileWriterInterface&          auxDataFile, FileWriterInterface&          geometryFile, FileWriterInterface&          textFile, FileWriterInterface&          customLabelsFile, ___1386 const&        ___1385, uint64_t                      numHeadersInFile, uint32_t                      numAuxDataInFile, uint32_t                      numGeomsInFile, uint32_t                      numTextsInFile, uint32_t                      numCustomLabelsInFile, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3499                        vars, ___3499                        ___4668, int32_t                       fileZoneOffset, ___934& ___933) { REQUIRE(headerFile.___2039()); REQUIRE(zoneFile.___2039()); REQUIRE(auxDataFile.___2039()); REQUIRE(geometryFile.___2039()); REQUIRE(textFile.___2039()); REQUIRE(customLabelsFile.___2039()); REQUIRE(___1385.getFileVersion() == 105 || ___1385.getFileVersion() == 231 || ___1385.getFileVersion() == 232); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4668));
 #if !defined TECIOMPI
REQUIRE(boost::atomic<double>().is_lock_free());
 #endif
ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4668); ___372 ___2037 = ___478(___36, varIter, zoneIter, ___1385.___842()); if (___2037) { ___36.___3777("Exporting szplt temp files...", ___4224 , ___4224/*___3578*/); ___2037 = ___2037 && ___36.___3767(0); ___4349 numVarsToWrite = 0; ___4633 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2810(); numZonesToWrite = zoneIter.___2810(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } if (numHeadersInFile == 0) ___2037 = ___2037 && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, numHeadersInFile); ___2037 = ___2037 && zoneFile.___3458() && ___4513(zoneFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, 1); try { ___3943 headerTagMap = initializedHeaderTagMap( ___1385.getFileVersion(), numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1755(), ___1385.___1754()); ___1390 szpltZoneHeaderFileLocs; ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4175 = 0; ___36.datasetGetTitle(&___4175); dataSetTitle = ___4175; ___36.___3815(&___4175); } uint64_t headersCount = numHeadersInFile + 1; uint32_t auxDataCount = numAuxDataInFile + countAuxData(___36, varIter, zoneIter); uint32_t geomCount = numGeomsInFile + countGeoms(___36); uint32_t textCount = numTextsInFile + countTexts(___36); uint32_t customLabelsCount = numCustomLabelsInFile + countCustomLabelSets(___36); ___2037 = ___2037 && headerFile.seekToFileEnd(); ___2037 = ___2037 && auxDataFile.seekToFileEnd(); ___2037 = ___2037 && textFile.seekToFileEnd(); ___2037 = ___2037 && geometryFile.seekToFileEnd(); ___2037 = ___2037 && customLabelsFile.seekToFileEnd(); ___2037 = ___2037 && auxDataFile.___3458() && ___4481(auxDataFile, auxDataCount) && auxDataFile.seekToFileEnd() && writeAuxDataItems(auxDataFile, ___36, varIter, zoneIter, fileZoneOffset) && geometryFile.___3458() && ___4519(geometryFile, geomCount) && geometryFile.seekToFileEnd() && writeGeomItems(geometryFile, ___36, fileZoneOffset) && textFile.___3458() && ___4544(textFile, textCount) && textFile.seekToFileEnd() && writeTextItems(textFile, ___36, fileZoneOffset) && customLabelsFile.___3458() && ___4501(customLabelsFile, customLabelsCount) && customLabelsFile.seekToFileEnd() && writeCustomLabelSets(customLabelsFile, ___36) && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && zoneFile.seekToFileEnd() && dataSetWriter.writeDataSet(zoneFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs) &&
headerFile.___3458() && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, headersCount) && headerFile.seekToFileEnd() && writeDataSetHeaders(headerFile, ___1385.getFileVersion(), dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4703(), szpltZoneHeaderFileLocs, ___933);
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778);
 #endif
} catch (std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2890; ___2890 << "Error encountered while writing file: " << e.what(); ___2037 = ___1184(___2890.str().c_str()); } catch (...) { ___2037 = ___1184("Unrecoverable error while writing file."); } ___36.___3768(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
