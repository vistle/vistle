#include "ThirdPartyHeadersBegin.h"
#include <exception>
#include <iostream>
#include <limits>
#include <new>
#include <numeric>
#include <set>
#include <sstream>
#include <stdlib.h>
#include <string>
#include <utility>
#include <boost/algorithm/string.hpp>
#include <boost/assign.hpp>
#include <boost/foreach.hpp>
#include <boost/make_shared.hpp>
#include <boost/scoped_array.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/static_assert.hpp>
#include <boost/tokenizer.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
 #if defined TECIOMPI
#include <iomanip>
#include <vector>
#include <mpi.h> 
#include "mpiDatatype.h"
#include "MPIUtil.h"
#include "TecioMPI.h"
 #endif 
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CHARTYPE.h"
#include "CodeContract.h"
#include "CszConnectivity.h"
#include "DataSetWriter.h"
#include "DataWriteStatisticsInterface.h"
#include "exportSubzonePlt.h"
#include "fileio.h"
#include "fileStuff.h"
#include "FileStreamReader.h"
#include "FileStreamWriter.h"
#include "FileSystem.h"
#include "importSzPltFile.h"
 #if defined TECIOMPI
#include "DataSetWriterMPI.h"
#include "MPICommunicator.h"
#include "MPIFileReader.h"
#include "MPIFileWriter.h"
#include "MPINonBlockingCommunicationCollection.h"
 #endif
#include "NonSzFEZoneConnectivityWriter.h"
#include "NonSzZoneVariableWriter.h"
#include "RawArray.h"
#include "readValueArray.h"
#include "SZLFEZoneWriter.h"
#include "SZLOrderedZoneWriter.h"
#include "TecioData.h"
#include "TecioSZL.h"
#include "TecioTecUtil.h"
#include "writeValueArray.h"
#include "ZoneMetadata.h"
#include "zoneUtil.h"
#include "TecplotVersion.h"
 #if defined MSWIN && defined _DEBUG
 #define ___3182(s) do { OutputDebugStringA(s); printf(s); } while (0)
 #define ___3183(s,a1) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define ___3184(s,a1,a2) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define ___3185(s,a1,a2,a3) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define PRINT4(s,a1,a2,a3,a4) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3,a4); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define PRINT5(s,a1,a2,a3,a4,a5) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3,a4,a5); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #else
 #define ___3182(s) printf(s)
 #define ___3183(s,a1) printf(s,a1)
 #define ___3184(s,a1,a2) printf(s,a1,a2)
 #define ___3185(s,a1,a2,a3) printf(s,a1,a2,a3)
 #define PRINT4(s,a1,a2,a3,a4) printf(s,a1,a2,a3,a4)
 #define PRINT5(s,a1,a2,a3,a4,a5) printf(s,a1,a2,a3,a4,a5)
 #endif
 #define ___23(n, T, s) (new T[n])
 #define ___1528(a, s) (delete[] a);
 #define ___2378 10
using namespace tecplot::___3931;
 #if defined TECIOMPI
using namespace tecplot::teciompi;
 #endif
bool _showMessage( MessageBoxType_e messageBoxType, char const*      ___2430) { switch(messageBoxType) { case ___2441: ___3183(___2430,"%s\n"); ___3182("...aborting.\n"); return false; case ___2445: case ___2446: ___3182("Warning: "); ___3183(___2430,"%s\n"); ___3182("...continuing.\n"); return true; case ___2442: ___3182("Information: "); ___3183(___2430,"%s\n"); ___3182("...continuing.\n"); return true; case ___2444: case ___2447: case ___2448: ___3182("Encountered question: "); ___3183(___2430,"%s\n"); ___3182("...assuming Yes and continuing.\n"); return true; default: return false; } } namespace tecplot { namespace tecioszl { namespace { size_t const SZPLT_READ_BUFFER_SIZE = 1048576; struct OutputInfo { OutputInfo() : m_numValuesWritten(0) , m_numErrs(0) , m_geom(tecioszl::___1554::invalidGeom()) , m_text(tecioszl::Text::invalidText()) {} OutputInfo( std::string const& ___4175, std::string const& ___4347, std::string const& ___1392, std::string const& ___3445, int32_t            ___1405, int32_t            debugLevel, int32_t            defaultVarType, OutputInfo*        gridOutputInfo) : ___2647(___4175) , m_variables(___4347) , ___2459(___1392) , ___2618(___3445) , m_fileType(___1405) , m_debugLevel(debugLevel) , m_defaultVarType(defaultVarType) , m_gridOutputInfo(gridOutputInfo) , m_numValuesWritten(0) , m_numErrs(0) , m_tecioData(___4175, ___4347, defaultVarType) , m_geom(tecioszl::___1554::invalidGeom()) , m_text(tecioszl::Text::invalidText()) , m_hasBeenFlushedToDisk(false) { size_t extensionPos = ___2459.find_last_of('.'); if (extensionPos == std::string::npos || (___2459.substr(extensionPos) != std::string(".szplt") && ___2459.substr(extensionPos) != std::string(".szptn"))) { ___2459 += ".szplt"; } } std::string       ___2647; std::string       m_variables; std::string       ___2459; std::string       ___2618; int32_t           m_fileType; int32_t           m_debugLevel; int32_t           m_defaultVarType; OutputInfo*       m_gridOutputInfo; uint64_t          m_numValuesWritten; int               m_numErrs; ___3968         m_tecioData; tecioszl::___1554    m_geom; tecioszl::Text    m_text; bool              m_hasBeenFlushedToDisk; int32_t           m_previousNumZones; boost::shared_ptr<___4014>  m_tecioTecUtil; boost::shared_ptr<DataSetWriter> m_dataSetWriter;
 #if defined TECIOMPI
MPI_Comm m_comm; boost::scoped_ptr<MPICommunicator> m_communicator; boost::scoped_ptr<MPINonBlockingCommunicationCollection> ___2394; int m_mainProcess; int m_localProcess; MPI_Info m_info{MPI_INFO_NULL};
 #endif
}; std::vector<boost::shared_ptr<OutputInfo> > outputInfos; boost::shared_ptr<OutputInfo> ___1810; class DataWriteStatistics : public ___934 { public: DataWriteStatistics() {} virtual ~DataWriteStatistics() {} virtual void addWriteTime(uint64_t  ) {} virtual void ___7(uint64_t  ) {} virtual void addTreeBytesWritten(uint64_t  ) {} virtual void setMemoryInfoString(std::string const&  ) {} }; bool getOutputInfo(OutputInfo** outputInfo, void* fileHandle, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(routineName)); *outputInfo = (OutputInfo*)fileHandle; if (!*outputInfo) { ___3183("Error in %s : invalid parameter fileHandle.\n", routineName); return false; } return true; } bool zoneOrPartitionDataAreComplete( OutputInfo*   outputInfo, Zone_s* const zonePtr, int32_t       zone, int32_t       ___2975, bool          checkConnectivity, char const*   routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zonePtr)); REQUIRE(zone > 0); REQUIRE(___2975 >= 0); REQUIRE(VALID_REF(routineName));
 #if defined TECIOMPI
bool thisProcessOwnsUnpartitionedZone = zonePtr->m_partitionOwners.size() == 1 && zonePtr->m_partitionOwners[0] == outputInfo->m_localProcess && zonePtr->m_partitionMap.empty(); if (!thisProcessOwnsUnpartitionedZone && !zonePtr->m_partitionOwners.empty()) { for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { if (zonePtr->m_partitionOwners[i] == outputInfo->m_localProcess) { int32_t partitionI = static_cast<int32_t>(i); Zone_s::ZoneMap::const_iterator it = zonePtr->m_partitionMap.find(partitionI); if (it == zonePtr->m_partitionMap.end()) { std::ostringstream ___2890; ___2890 << routineName << ": Partition " << partitionI << " of zone " << zone << " is owned by process " << outputInfo->m_localProcess << " but was never created." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; } else if (!zoneOrPartitionDataAreComplete(outputInfo, it->second.get(), zone, partitionI, checkConnectivity, routineName)) { return false; } } } return true; }
 #else
if (___2975 == 0 && !zonePtr->m_partitionMap.empty()) { for (Zone_s::ZoneMap::iterator valuePair = zonePtr->m_partitionMap.begin(); valuePair != zonePtr->m_partitionMap.end(); ++valuePair) { int32_t localPartition = valuePair->first; Zone_s* partitionPtr = valuePair->second.get(); if (!zoneOrPartitionDataAreComplete(outputInfo, partitionPtr, zone, localPartition, checkConnectivity, routineName)) return false; } return true; }
 #endif
bool ___3356 = true; for (size_t ___4333 = 0; ___4333 < zonePtr->___2494.size(); ++___4333) { if (!zonePtr->m_passiveVars[___4333] && !zonePtr->m_shareVarFromZone[___4333] && zonePtr->___2494[___4333]->storedValueCount() < zonePtr->___2494[___4333]->___2666) { std::ostringstream ___2890; int64_t valuesNeeded = zonePtr->___2494[___4333]->___2666 - zonePtr->___2494[___4333]->storedValueCount(); ___2890 << routineName << ": Not all variable values for zone " << zone; if (___2975 > 0) ___2890 << " partition " << ___2975; ___2890 << " have been written." << std::endl << "Currently need " << valuesNeeded << " for variable " << ___4333 + 1 << "." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; ___3356 = false; } } if (checkConnectivity) { if (zonePtr->___2495 && zonePtr->___2495->expectedValueCount() > zonePtr->___2495->storedValueCount()) { int64_t valuesNeeded = zonePtr->___2495->expectedValueCount() - zonePtr->___2495->storedValueCount(); std::ostringstream ___2890; ___2890 << routineName << ": Not all node map values for zone " << zone; if (___2975 > 0) ___2890 << " partition " << ___2975; ___2890 << " have been written." << std::endl << "Currently need " << valuesNeeded << " more values."; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; ___3356 = false; } } return ___3356; } bool dataAreComplete(OutputInfo* outputInfo, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(routineName)); bool checkConnectivity = (outputInfo->m_fileType != 2); bool ___3356 = true; std::set<___3491> const zonesToWrite = outputInfo->m_tecioData.unflushedZoneSet(); for (std::set<___3491>::const_iterator it = zonesToWrite.begin(); it != zonesToWrite.end(); ++it) { int32_t zone = static_cast<int32_t>(*it); Zone_s* zonePtr = outputInfo->m_tecioData.zonePtr(zone); ___476(zonePtr); if (!zoneOrPartitionDataAreComplete(outputInfo, zonePtr, zone, 0, checkConnectivity, routineName)) ___3356 = false; } return ___3356; } ___372 includeRevisionNumber() { ___372 ___3356 = ___4224; char const* envName = "EXCLUDE_SZPLT_REVISION_NUMBER"; char const* envResult = getenv(envName); if (envResult != NULL) { if (boost::iequals(envResult, "TRUE")) ___3356 = ___1303; else if (boost::iequals(envResult, "FALSE")) ___3356 = ___4224; else fprintf(stderr, "Err: %s(%d): If environment variable (%s) is set, its value should be TRUE or FALSE; ignoring setting, (%s).", __FILE__, __LINE__, envName, envResult); } return ___3356; } void writeASCIIFileIndicator(bool const ___4477, FileWriterInterface &fileWriter) { char asciiFileIndicator[3]; if (___4477) asciiFileIndicator[0] = 'T'; else asciiFileIndicator[0] = 'F'; asciiFileIndicator[1] = '\r'; asciiFileIndicator[2] = '\n'; fileWriter.fwrite(asciiFileIndicator, 1, 3); }
 #if defined TECIOMPI
namespace { void renumberZones(OutputInfo& outputInfo) { std::vector<int32_t> sendCounts(1, 0); std::vector<int32_t> offsets(1, 0); std::vector<int32_t> zoneNumbers(1); std::set<___3491> unflushedZoneSet = outputInfo.m_tecioData.unflushedZoneSet(); int32_t receiveCount = 0; if (outputInfo.m_localProcess == outputInfo.m_mainProcess) { int32_t commSize; MPI_Comm_size(outputInfo.m_comm, &commSize); sendCounts.resize(commSize, 0); BOOST_FOREACH(___3491 ___4655, unflushedZoneSet) { Zone_s const* zonePtr = outputInfo.m_tecioData.zonePtr(static_cast<___4633>(___4655)); boost::unordered_set<int32_t> partitionOwners; for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { int32_t const owner = zonePtr->m_partitionOwners[i]; if (partitionOwners.insert(owner).second) { ++sendCounts[owner]; if (owner == outputInfo.m_localProcess) ++receiveCount; } } } int32_t totalSize = 0; offsets.resize(commSize + 1, 0); for (int32_t i = 0; i < commSize; ++i) { totalSize += sendCounts[i]; offsets[i + 1] = totalSize; } zoneNumbers.resize(totalSize); std::vector<int32_t> tempSendCounts(commSize, 0); BOOST_FOREACH(___3491 ___4655, unflushedZoneSet) { Zone_s const* zonePtr = outputInfo.m_tecioData.zonePtr(static_cast<___4633>(___4655)); boost::unordered_set<int32_t> partitionOwners; for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { int32_t owner = zonePtr->m_partitionOwners[i]; if (partitionOwners.insert(owner).second) { zoneNumbers[offsets[owner] + tempSendCounts[owner]++] = static_cast<int32_t>(___4655); } } } ___476(tempSendCounts == sendCounts); } else { receiveCount = static_cast<int32_t>(unflushedZoneSet.size()); } std::vector<int32_t> localZoneNumbers(receiveCount + 1); MPI_Scatterv( zoneNumbers.data(), sendCounts.data(), offsets.data(), MPI_INT32_T, localZoneNumbers.data(), receiveCount, MPI_INT32_T, outputInfo.m_mainProcess, outputInfo.m_comm); localZoneNumbers.resize(receiveCount); if (receiveCount > 0 && outputInfo.m_localProcess != outputInfo.m_mainProcess) outputInfo.m_tecioData.renumberZones(localZoneNumbers); } }
 #endif
namespace { uint32_t surveyZonesForFileVersion( OutputInfo* outputInfo, ___3499      zonesToWrite) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF_OR_NULL(zonesToWrite)); uint32_t fileVersion = 0;
 #if defined TECIOMPI
if (outputInfo->m_mainProcess == outputInfo->m_localProcess)
 #else
___4276(outputInfo);
 #endif
{ fileVersion = ___1386::surveyZonesForFileVersion( *outputInfo->m_tecioTecUtil, zonesToWrite); }
 #if defined TECIOMPI
MPI_Bcast(&fileVersion, 1, MPI_UNSIGNED, outputInfo->m_mainProcess, outputInfo->m_comm);
 #endif
ENSURE(fileVersion == 105 || fileVersion == 231 || fileVersion == 232); return fileVersion; } } int32_t writeAllZonesToSZLFile(OutputInfo* outputInfo, char const* routineName) { if (!dataAreComplete(outputInfo, routineName)) { ++outputInfo->m_numErrs; return -1; } outputInfo->m_tecioData.flattenSinglePartitionZones(); bool const ___4477 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
if (static_cast<DataFileType_e>(outputInfo->m_fileType) == END_DataFileType_e) { try { std::ostringstream ___2890; ___2890 << outputInfo->___2459 << ".test";
 #if defined TECIOMPI
MPIFileWriter fileWriter(___2890.str(), outputInfo->m_comm, outputInfo->m_info);
 #else
FileStreamWriter fileWriter(___2890.str());
 #endif
if (!fileWriter.open(false)) return 1; ___1391 myFileLoc = 0; writeASCIIFileIndicator(___4477, fileWriter);
 #if defined TECIOMPI
MPICommunicator communicator(outputInfo->m_comm); if (outputInfo->m_localProcess == outputInfo->m_mainProcess) { int commSize; MPI_Comm_size(outputInfo->m_comm, &commSize); ___1391 ___2826 = static_cast<___1391>(commSize); ___1391 sizeOfFileLoc = ___4477 ? 2 + ___199<___1391, false>::size : sizeof(___1391); ___1391 processFileLoc = 3 + (___2826 + 1) * sizeOfFileLoc; writeScalar(fileWriter, ___2826, ___4477); for (int i = 0; i < commSize; ++i) { writeScalar(fileWriter, processFileLoc, ___4477); if (i == outputInfo->m_localProcess) { myFileLoc = processFileLoc; processFileLoc += outputInfo->m_tecioData.sizeInFile(___4477); } else { communicator.sendScalar(processFileLoc, i, TecioMPI::ZONE_FILE_LOC); ___1391 zoneSize; communicator.receiveScalar(zoneSize, i, TecioMPI::ZONE_FILE_SIZE); processFileLoc += zoneSize; } } } else { ___1391 zoneSize = outputInfo->m_tecioData.sizeInFile(___4477); communicator.sendScalar(zoneSize, outputInfo->m_mainProcess, TecioMPI::ZONE_FILE_SIZE); communicator.receiveScalar(myFileLoc, outputInfo->m_mainProcess, TecioMPI::ZONE_FILE_LOC); }
 #else
___1391 ___2826 = 1; writeScalar(fileWriter, ___2826, ___4477); ___1391 fileLocLoc = fileWriter.fileLoc(); writeScalar(fileWriter, myFileLoc, ___4477); myFileLoc = fileWriter.fileLoc(); fileWriter.___3457(fileLocLoc); writeScalar(fileWriter, myFileLoc, ___4477);
 #endif
outputInfo->m_tecioData.writeToFile(fileWriter, myFileLoc, ___4477); } catch (...) { return -1; } return 0; } DataFileType_e const ___842 = static_cast<DataFileType_e>(outputInfo->m_fileType); if (___842 == ___846) {
 #if defined TECIOMPI
outputInfo->m_gridOutputInfo->___2394->___4443();
 #endif
try { outputInfo->m_tecioData.copyConnectivity(outputInfo->m_gridOutputInfo->m_tecioData); } catch (std::exception const& e) { ___3184("Error in %s: %s", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } }
 #if defined TECIOMPI
renumberZones(*outputInfo);
 #endif
outputInfo->m_tecioTecUtil = boost::make_shared<___4014>(boost::ref(outputInfo->m_tecioData)); uint32_t const fileVersion = surveyZonesForFileVersion( outputInfo, ___3499(0)); ___1386 ___1385( fileVersion, ___4477, ___842, DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setCodeRevision(1); DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> szpltFile;
 #if defined TECIOMPI
szpltFile.reset(new MPIFileWriter(outputInfo->___2459.c_str(), outputInfo->m_comm, outputInfo->m_info));
 #else
szpltFile.reset(new FileStreamWriter(outputInfo->___2459.c_str()));
 #endif
if (___1385.___842() == ___846) { if (!outputInfo->m_gridOutputInfo || !outputInfo->m_gridOutputInfo->m_dataSetWriter) { ___3184("Error in %s: For SZL solution files (FileType = 2), you must output and call %s\n", routineName, routineName); ___3183("for a grid file (FileType = 1) prior to calling %s for the solution file.\n", routineName); ++outputInfo->m_numErrs; return -1; } outputInfo->m_dataSetWriter = outputInfo->m_gridOutputInfo->m_dataSetWriter; outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0)); } else {
 #if defined TECIOMPI
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriterMPI>( outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754(), outputInfo->m_comm, outputInfo->m_mainProcess, outputInfo->m_localProcess);
 #else
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriter>( outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754());
 #endif
} int32_t ___3356 = 0; if (!szpltFile->open(false)) { ___3356 = -1; ++outputInfo->m_numErrs; } else { szpltFile->___3492(___4477 ? ___4224 : ___1303); szpltFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) { ___1390 szpltZoneHeaderFileLocs; if (outputInfo->m_tecioTecUtil->___894() && (!szpltZoneHeaderFileLocs.alloc(outputInfo->m_tecioTecUtil->___889()) || !outputInfo->m_dataSetWriter->writeDataSet(*szpltFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs))) { ___3356 = -1; ++outputInfo->m_numErrs; } } else
 #endif
{ if (!___1240( *outputInfo->m_tecioTecUtil, *szpltFile, ___1385, includeRevisionNumber(), *outputInfo->m_dataSetWriter, ___3499(0), ___3499(0), ___933)) { ___3356 = -1; ++outputInfo->m_numErrs; } } } szpltFile->close(___3356 == 0); outputInfo->m_dataSetWriter->replaceDataSource(NULL, ___3499(0), ___3499(0)); return ___3356; } ___3499 zoneSetToWrite(OutputInfo* outputInfo) { ___3499 zoneSet = NULL; std::set<___3491> const zonesToWrite = outputInfo->m_tecioData.unflushedZoneSet(); if (!zonesToWrite.empty()) { zoneSet = outputInfo->m_tecioTecUtil->setAlloc(___4224); if (zoneSet) { for (std::set<___3491>::const_iterator it = zonesToWrite.begin(); it != zonesToWrite.end(); ++it) outputInfo->m_tecioTecUtil->setAddMember(zoneSet, *it, ___4224); } } return zoneSet; } void warnIfAppendingToExistingFiles(OutputInfo& outputInfo, FileWriterInterface& headerFile, char const* routineName) { if (headerFile.seekToFileEnd()) { uint64_t fileSize = headerFile.fileLoc(); if (fileSize > 0) { ___3185("Warning in %s: Appending to existing temporary files for file %s (%s, etc.).\n", routineName, outputInfo.___2459.c_str(), headerFile.___1392().c_str()); ___3183("If this is not the intent, you must delete the temporary files prior to calling %s.\n", routineName); ++outputInfo.m_numErrs; } headerFile.___3458(); } else { ___3184("Warning in %s: Error attempting file seek in file %s.\n", routineName, headerFile.___1392().c_str()); } } namespace { int32_t countExistingFlushedZones(___1397& headerFile, ___1386& ___1385, char const* routineName) { REQUIRE(headerFile.___2039()); REQUIRE(VALID_REF(routineName)); int32_t  ___3356 = 0; uint64_t numHeadersInFile = 0; uint64_t totalNumZones = 0; headerFile.___3458(); if (readValue<uint64_t, false>(headerFile, numHeadersInFile, IODescription(SZPLT_NUM_INTERMEDIATE_HEADERS))) { for (uint64_t i = 0; ___3356 == 0 && i < numHeadersInFile; ++i) { ___3943 ___3942; ___4704 ___4703; ___1390 ___4626; ___372 ___2037 = readDataSetHeaderTags(headerFile, ___1385, ___3942); std::string localDataSetTitle; ___2037 = ___2037 && readDataSetHeader(headerFile, ___1385, ___3942, localDataSetTitle, ___4703, ___4626); if (___2037) { totalNumZones += ___3942[___2847]; } else { ___3184("Error in %s reading existing header file %s", routineName, headerFile.___1392().c_str()); ___3356 = -1; } } } if (___3356 == 0) ___3356 = checked_numeric_cast<int32_t>(totalNumZones); ENSURE(___3356 >= 0); return ___3356; } } int32_t flushDataToIntermediateFiles(OutputInfo* outputInfo, int32_t numZonesToRetain, int32_t const* zonesToRetain, char const* routineName) { int32_t ___3356 = 0; if (!dataAreComplete(outputInfo, routineName)) { ++outputInfo->m_numErrs; ___3356 = -1; } outputInfo->m_tecioData.flattenSinglePartitionZones();
 #if defined TECIOMPI
int overallResult; MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #else
if (___3356 == 0 && outputInfo->m_tecioData.empty()) return 0;
 #endif
bool const ___4477 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
DataFileType_e const ___842 = static_cast<DataFileType_e>(outputInfo->m_fileType); if (___3356 == 0 && ___842 == ___846) {
 #if defined TECIOMPI
outputInfo->m_gridOutputInfo->___2394->___4443();
 #endif
try { outputInfo->m_tecioData.copyConnectivity(outputInfo->m_gridOutputInfo->m_tecioData); } catch (std::exception const& e) { ___3184("Error in %s: %s", routineName, e.what()); ++outputInfo->m_numErrs; ___3356 = -1; } } outputInfo->m_tecioTecUtil = boost::make_shared<___4014>(boost::ref(outputInfo->m_tecioData)); ___3499 zonesToWrite = zoneSetToWrite(outputInfo); uint32_t const fileVersion = surveyZonesForFileVersion(outputInfo, zonesToWrite); ___1386 ___1385( fileVersion, ___4477, ___842, DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setCodeRevision(1);
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
uint64_t numHeadersInFile = 0; uint32_t numAuxDataInFile = 0; uint32_t numGeomsInFile = 0; uint32_t numTextsInFile = 0; uint32_t numCustomLabelsInFile = 0; std::string headerFileName = outputInfo->___2459 + HEADER_FILE_SUFFIX; std::string auxDataFileName = outputInfo->___2459 + AUX_DATA_FILE_SUFFIX; std::string geomFileName = outputInfo->___2459 + GEOMETRY_FILE_SUFFIX; std::string textFileName = outputInfo->___2459 + TEXT_FILE_SUFFIX; std::string customLabelsFileName = outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX; boost::scoped_ptr<___1397> headerFileReader(new FileStreamReader(headerFileName.c_str()));
 #if defined TECIOMPI
if (___3356 == 0 && outputInfo->m_localProcess == outputInfo->m_mainProcess) {
 #endif
FILE* testFile = filesystem::fileOpen(headerFileName, "r"); if (testFile) { fclose(testFile); headerFileReader->___3492(___1385.___2000()); if (headerFileReader->open() && !readValue<uint64_t, false>(*headerFileReader, numHeadersInFile, IODescription(SZPLT_NUM_INTERMEDIATE_HEADERS))) { ___3184("Error in %s: Error reading from file %s\n", routineName, headerFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3943 ___3942 = DATASET_HEADER_TAG_MAP_V105_INITIALIZER; if (___1385.getFileVersion() > 105) { ___3943 const tagValueMap_v231 = DATASET_HEADER_TAG_MAP_V231_INITIALIZER; ___3942.insert(tagValueMap_v231.begin(), tagValueMap_v231.end()); } ___3942[___241] = 0; boost::scoped_ptr<___1397> auxDataFileReader(new FileStreamReader(auxDataFileName)); auxDataFileReader->___3492(___1385.___2000()); if (!auxDataFileReader->open() || !readAuxDataCount(*auxDataFileReader, ___3942, numAuxDataInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, auxDataFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___1579] = 0; boost::scoped_ptr<___1397> geomFileReader(new FileStreamReader(geomFileName)); geomFileReader->___3492(___1385.___2000()); if (!geomFileReader->open() || !readGeometriesCount(*geomFileReader, ___3942, numGeomsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, geomFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___4081] = 0; boost::scoped_ptr<___1397> textFileReader(new FileStreamReader(textFileName)); textFileReader->___3492(___1385.___2000()); if (!textFileReader->open() || !readTextsCount(*textFileReader, ___3942, numTextsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, textFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___793] = 0; boost::scoped_ptr<___1397> customLabelsFileReader(new FileStreamReader(customLabelsFileName)); customLabelsFileReader->___3492(___1385.___2000()); if (!customLabelsFileReader->open() || !readCustomLabelsCount(*customLabelsFileReader, ___3942, numCustomLabelsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, customLabelsFileName.c_str()); ++outputInfo->m_numErrs; return -1; } }
 #if defined TECIOMPI
}
 #endif
DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> headerFile; boost::scoped_ptr<FileWriterInterface> zoneDataFile; boost::scoped_ptr<FileWriterInterface> auxDataFile; boost::scoped_ptr<FileWriterInterface> geometryFile; boost::scoped_ptr<FileWriterInterface> textFile; boost::scoped_ptr<FileWriterInterface> customLabelsFile;
 #if defined TECIOMPI
headerFile.reset(new MPIFileWriter((outputInfo->___2459 + HEADER_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info)); zoneDataFile.reset(new MPIFileWriter((outputInfo->___2459 + ZONE_DATA_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info)); auxDataFile.reset(new MPIFileWriter((outputInfo->___2459 + AUX_DATA_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info)); geometryFile.reset(new MPIFileWriter((outputInfo->___2459 + GEOMETRY_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info)); textFile.reset(new MPIFileWriter((outputInfo->___2459 + TEXT_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info)); customLabelsFile.reset(new MPIFileWriter((outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX).c_str(), outputInfo->m_comm, outputInfo->m_info));
 #else
headerFile.reset(new FileStreamWriter((outputInfo->___2459 + HEADER_FILE_SUFFIX).c_str())); zoneDataFile.reset(new FileStreamWriter((outputInfo->___2459 + ZONE_DATA_FILE_SUFFIX).c_str())); auxDataFile.reset(new FileStreamWriter((outputInfo->___2459 + AUX_DATA_FILE_SUFFIX).c_str())); geometryFile.reset(new FileStreamWriter((outputInfo->___2459 + GEOMETRY_FILE_SUFFIX).c_str())); textFile.reset(new FileStreamWriter((outputInfo->___2459 + TEXT_FILE_SUFFIX).c_str())); customLabelsFile.reset(new FileStreamWriter((outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX).c_str()));
 #endif
if (___3356 == 0 && ___1385.___842() == ___846) { if (!outputInfo->m_gridOutputInfo || !outputInfo->m_gridOutputInfo->m_dataSetWriter) { ___3184("Error in %s: For SZL solution files (FileType = 2), you must output and call %s\n", routineName, routineName); ___3183("for a grid file (FileType = 1) prior to calling %s for the solution file.\n", routineName); ++outputInfo->m_numErrs; ___3356 = -1;
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} outputInfo->m_dataSetWriter = outputInfo->m_gridOutputInfo->m_dataSetWriter; outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0)); } else { if (outputInfo->m_dataSetWriter) outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite); else
 #if defined TECIOMPI
outputInfo->m_dataSetWriter = boost::shared_ptr<DataSetWriterMPI>(new DataSetWriterMPI( outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite, ___1385.___1755(), ___1385.___1754(), outputInfo->m_comm, outputInfo->m_mainProcess, outputInfo->m_localProcess, true));
 #else
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriter>( outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite, ___1385.___1755(), ___1385.___1754(), true);
 #endif
} if (___3356 == 0) { if (!headerFile->open(true) || !zoneDataFile->open(true) || !auxDataFile->open(true) || !geometryFile->open(true) || !textFile->open(true) || !customLabelsFile->open(true)) { ++outputInfo->m_numErrs; ___3356 = -1; }
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} if (___3356 == 0) { if (!outputInfo->m_hasBeenFlushedToDisk) { warnIfAppendingToExistingFiles(*outputInfo, *headerFile, routineName); if (headerFileReader->___2039()) outputInfo->m_previousNumZones = countExistingFlushedZones(*headerFileReader, ___1385, routineName); else outputInfo->m_previousNumZones = 0; if (outputInfo->m_previousNumZones == -1) ___3356 = -1; } } if (___3356 == 0) { headerFile->___3492(___4477 ? ___4224 : ___1303); zoneDataFile->___3492(___4477 ? ___4224 : ___1303); auxDataFile->___3492(___4477 ? ___4224 : ___1303); geometryFile->___3492(___4477 ? ___4224 : ___1303); textFile->___3492(___4477 ? ___4224 : ___1303); customLabelsFile->___3492(___4477 ? ___4224 : ___1303); headerFile->setDataFileType(___1385.___842()); zoneDataFile->setDataFileType(___1385.___842()); auxDataFile->setDataFileType(___1385.___842()); geometryFile->setDataFileType(___1385.___842()); textFile->setDataFileType(___1385.___842()); customLabelsFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) { ___1390 szpltZoneHeaderFileLocs; if (outputInfo->m_tecioTecUtil->___894() && (!szpltZoneHeaderFileLocs.alloc(outputInfo->m_tecioTecUtil->___889()) || !outputInfo->m_dataSetWriter->writeDataSet(*zoneDataFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs))) { ___3356 = -1; ++outputInfo->m_numErrs; } } else
 #endif
{ if (outputInfo->m_tecioTecUtil->___894() && !writeIntermediateFiles( *outputInfo->m_tecioTecUtil, *headerFile, *zoneDataFile, *auxDataFile, *geometryFile, *textFile, *customLabelsFile, ___1385, numHeadersInFile, numAuxDataInFile, numGeomsInFile, numTextsInFile, numCustomLabelsInFile, includeRevisionNumber(), *outputInfo->m_dataSetWriter, ___3499(0), zonesToWrite, outputInfo->m_previousNumZones, ___933)) { ___3356 = -1; ++outputInfo->m_numErrs; } }
 #if defined TECIOMPI
outputInfo->___2394->___4443(); MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} bool ___3359 = (___3356 == 0);
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) ___3359 = true;
 #endif
headerFile->close(___3359); zoneDataFile->close(___3359); auxDataFile->close(___3359); geometryFile->close(___3359); textFile->close(___3359); customLabelsFile->close(___3359); if ((DataFileType_e)outputInfo->m_fileType == ___843) outputInfo->m_dataSetWriter->clear(numZonesToRetain, zonesToRetain); outputInfo->m_tecioData.clear(numZonesToRetain, zonesToRetain); outputInfo->m_hasBeenFlushedToDisk = true; outputInfo->m_tecioTecUtil->___3482(&zonesToWrite); return ___3356; } int32_t renameFile(std::string const& currentName, std::string const &newName, char const* routineName) { if (filesystem::fileRename(currentName, newName) != 0) { ___3185("Error in %s: Cannot rename file %s to file %s.\n", routineName, currentName.c_str(), newName.c_str()); return -1; } return 0; } int32_t copyFileContents(std::string const& sourceFileName, FileWriterInterface& szpltFile, char const* routineName) { REQUIRE(!sourceFileName.empty()); REQUIRE(szpltFile.___2039()); REQUIRE(VALID_REF(routineName)); boost::scoped_ptr<___1397>sourceFile(new FileStreamReader(sourceFileName.c_str())); int32_t ___3356 = 0; if (!sourceFile->open()) { ___3356 = -1; } else { try { std::vector<unsigned char> ___416(SZPLT_READ_BUFFER_SIZE); size_t bytesRead = sourceFile->fread(___416.data(), 1, SZPLT_READ_BUFFER_SIZE); while (___3356 == 0 && bytesRead > 0) { if (szpltFile.fwrite(___416.data(), 1, bytesRead) != bytesRead) { ___3184("Error in %s: Error writing to file %s.\n", routineName, szpltFile.___1392().c_str()); ___3356 = -1; } bytesRead = sourceFile->fread(___416.data(), 1, SZPLT_READ_BUFFER_SIZE); } } catch (std::exception const& e) { ___3184("Error in %s: %s.\n", routineName, e.what()); ___3356 = -1; } } return ___3356; } std::vector<std::string> intermediateFileNames(std::string const& intermediateFileBaseName) { std::vector<std::string> fileSuffixes = boost::assign::list_of<std::string> (HEADER_FILE_SUFFIX) (ZONE_DATA_FILE_SUFFIX) (TEXT_FILE_SUFFIX) (GEOMETRY_FILE_SUFFIX) (AUX_DATA_FILE_SUFFIX) (CUSTOM_LABELS_FILE_SUFFIX); std::vector<std::string> ___3356; ___3356.reserve(fileSuffixes.size()); for (std::vector<std::string>::const_iterator it = fileSuffixes.begin(); it != fileSuffixes.end(); ++it) ___3356.push_back(intermediateFileBaseName + *it); return ___3356; } int32_t checkForMissingOrUnreadableIntermediateFiles(std::string const& intermediateFileBaseName, char const* routineName) { REQUIRE(VALID_REF(routineName)); std::string ___3356; std::vector<std::string> fileNames = intermediateFileNames(intermediateFileBaseName); for (std::vector<std::string>::const_iterator it = fileNames.begin(); it != fileNames.end(); ++it) { FILE* testFile = tecplot::filesystem::fileOpen(*it, "r"); if (testFile) fclose(testFile); else if (___3356.empty()) ___3356 = std::string("The following file(s) do not exist or are not readable:\n    ") + *it + "\n"; else ___3356 += std::string("    ") + *it + "\n"; } if (!___3356.empty()) { ___3184("Error(s) detected in %s. Files must exist and be readable.\n%s", routineName,
___3356.c_str()); return -1; } return 0; } int32_t checkForMissingOrUnwritableIntermediateFiles(std::string const& intermediateFileBaseName, char const* routineName) { REQUIRE(VALID_REF(routineName)); std::string readableResult; std::string writableResult; std::vector<std::string> fileNames = intermediateFileNames(intermediateFileBaseName); for (std::vector<std::string>::const_iterator it = fileNames.begin(); it != fileNames.end(); ++it) { FILE* testFile = tecplot::filesystem::fileOpen(*it, "r"); if (testFile) { fclose(testFile); testFile = tecplot::filesystem::fileOpen(*it, "r+"); if (testFile) fclose(testFile); else if (writableResult.empty()) writableResult = std::string("The following file(s) exist but are not writable:\n    ") + *it + "\n"; else writableResult += std::string("    ") + *it + "\n"; } else if (readableResult.empty()) { readableResult = std::string("The following file(s) do not exist or are not readable:\n    ") + *it + "\n"; } else { readableResult += std::string("    ") + *it + "\n"; } } if (!readableResult.empty() || !writableResult.empty()) { ___3184("Error(s) detected in %s. Files must exist and be readable and writable.\n%s", routineName, (readableResult + writableResult).c_str()); return -1; } return 0; } std::string getTempFileName(std::string const& fileBaseName) { std::ostringstream ___2890; ___2890 << fileBaseName << time(NULL); return ___2890.str(); } int32_t moveToTempFileIfExists(std::string const& ___1392, std::string& newFileName, char const* routineName) { FILE* fileHandle = tecplot::filesystem::fileOpen(___1392.c_str(), "r"); if (fileHandle) { fclose(fileHandle); fileHandle = tecplot::filesystem::fileOpen(___1392.c_str(), "rb+"); if (fileHandle) { fclose(fileHandle); newFileName = getTempFileName(___1392); if (renameFile(___1392, newFileName, routineName) != 0) { newFileName.clear(); return -1; } } else { ___3184("Error in %s: File %s is not writable.\n", routineName, ___1392.c_str()); return -1; } } return 0; } struct FileItems { ___3943     ___3942; ___4704 ___4703; ___1390    ___4626; uint64_t        ___2841; uint64_t        ___2844; }; } int32_t convertIntermediateFilesToSZLFile( void*              fileHandle, std::string const& intermediateFileBaseName, bool               cleanup, std::string const& szpltFileName, char const*        routineName) { REQUIRE(VALID_REF_OR_NULL(fileHandle)); REQUIRE(VALID_REF(routineName)); OutputInfo* outputInfo = reinterpret_cast<OutputInfo*>(fileHandle); int32_t ___3356 = 0;
 #if defined TECIOMPI
if (!outputInfo || outputInfo->m_mainProcess == outputInfo->m_localProcess) {
 #else
___4276(outputInfo);
 #endif
try { if (cleanup) ___3356 = checkForMissingOrUnwritableIntermediateFiles(intermediateFileBaseName, routineName); else ___3356 = checkForMissingOrUnreadableIntermediateFiles(intermediateFileBaseName, routineName); ___1386 ___1385; if (___3356 == 0) { std::string filename = intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX; boost::scoped_ptr<___1397> fileReader(new FileStreamReader(filename)); uint64_t byteOrderIndicator; uint64_t dataSetHeaderLocation; if (!fileReader->open()) { ___3184("Error in %s: Cannot open file %s for writing.\n", routineName, filename.c_str()); } else if(!readDataFileHeader(*fileReader, ___1385, byteOrderIndicator, dataSetHeaderLocation)) { ___3356 = -1; fileReader->close(true); } } std::string tempFileName; if (___3356 == 0) { ___3356 = moveToTempFileIfExists(szpltFileName, tempFileName, routineName); } bool datFileMoved = false; if (___3356 == 0 && cleanup) { ___3356 = renameFile(intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX, szpltFileName, routineName); if (___3356 == 0) datFileMoved = true; } boost::scoped_ptr<FileWriterInterface>szpltFile(new FileStreamWriter(szpltFileName)); if (___3356 == 0 && !szpltFile->open(true)) { ___3184("Error in %s: Cannot open file %s for writing.\n", routineName, szpltFile->___1392().c_str()); ___3356 = -1; } else { szpltFile->___3492(___1385.___2000()); szpltFile->setDataFileType(___1385.___842()); } if (___3356 == 0 && !cleanup) { ___3356 = copyFileContents(intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX, *szpltFile, routineName); } std::string headerFileName = intermediateFileBaseName + HEADER_FILE_SUFFIX; boost::scoped_ptr<___1397>headerFile(new FileStreamReader(headerFileName)); if (___3356 == 0) { if (!headerFile->open()) ___3356 = -1; else headerFile->___3492(___1385.___2000()); } uint64_t numHeadersInFile = 0; if (___3356 == 0) { if (!readValue<uint64_t, false>(*headerFile, numHeadersInFile, IODescription(SZPLT_NUM_INTERMEDIATE_HEADERS))) { ___3356 = -1; } else if (numHeadersInFile == 0) { ___3184("Error in %s: The header file (%s) contains no headers.\n", routineName, headerFileName.c_str()); ___3356 = -1; } } ___2238<FileItems> fileItemsArray; if (___3356 == 0 && !fileItemsArray.alloc(numHeadersInFile)) { ___3183("Error in %s: Out of memory while reading files.\n", routineName); ___3356 = -1; } std::string dataSetTitle; uint64_t    totalNumZones = 0; uint64_t    ___2841 = 0; std::vector<uint8_t> zoneNumSections; for (uint64_t i = 0; ___3356 == 0 && i < numHeadersInFile; ++i) { ___372 ___2037 = readDataSetHeaderTags(*headerFile, ___1385, fileItemsArray[i].___3942); std::string localDataSetTitle; ___2037 = ___2037 && readDataSetHeader(*headerFile, ___1385, fileItemsArray[i].___3942, localDataSetTitle, fileItemsArray[i].___4703, fileItemsArray[i].___4626); if (___2037) { fileItemsArray[i].___2844 = fileItemsArray[i].___3942[___2847]; fileItemsArray[i].___2841 = fileItemsArray[i].___3942[___2843];
if (i == 0) { dataSetTitle = localDataSetTitle; ___2841 = fileItemsArray[i].___2841; } else if (fileItemsArray[i].___2841 != ___2841) { ___3183("Error in %s: Inconsistent number of variables between successive file flushes. Cannot continue.", routineName); ___3356 = -1; } totalNumZones += fileItemsArray[i].___2844; zoneNumSections.reserve(zoneNumSections.size() + fileItemsArray[i].___2844); for (uint64_t zone = 0; zone < fileItemsArray[i].___2844; ++zone) zoneNumSections.push_back(fileItemsArray[i].___4703.m_zoneNumSections[zone]); } else { ___3356 = -1; } } ___4704 ___4703; ___1390 ___4626; if (___3356 == 0 && totalNumZones > 0) { if (!___4626.alloc(totalNumZones) || !___4703.alloc(totalNumZones, ___2841, zoneNumSections)) { ___3183("Error in %s: Out of memory allocating data set header arrays.\n", routineName); ___3356 = -1; } uint64_t zoneOffset = 0; for (uint64_t i = 0; ___3356 == 0 && i < numHeadersInFile; ++i) { for (uint64_t zone = 0; zone < fileItemsArray[i].___2844; ++zone) { ___4626[zoneOffset + zone] = fileItemsArray[i].___4626[zone]; if (!___4703.assign(fileItemsArray[i].___4703, zoneOffset)) { ___3183("Error in %s: Out of memory copying data set header arrays.\n", routineName); ___3356 = -1; } } zoneOffset += fileItemsArray[i].___2844; } } ___3943 ___3942 = DATASET_HEADER_TAG_MAP_V105_INITIALIZER; if (___1385.getFileVersion() > 105) { ___3943 const tagValueMap_v231 = DATASET_HEADER_TAG_MAP_V231_INITIALIZER; ___3942.insert(tagValueMap_v231.begin(), tagValueMap_v231.end()); } if (___3356 == 0) { ___3942[___2847] = totalNumZones; ___3942[___2843] = ___2841; ___3942[SUBZONE_MAX_I_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_I_SIZE_TAG]; ___3942[SUBZONE_MAX_J_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_J_SIZE_TAG]; ___3942[SUBZONE_MAX_K_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_K_SIZE_TAG]; ___3942[SUBZONE_MAX_FE_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_FE_SIZE_TAG]; szpltFile->seekToFileEnd(); } std::string auxDataFileName = intermediateFileBaseName + AUX_DATA_FILE_SUFFIX; if (___3356 == 0) { ___3942[___241] = szpltFile->fileLoc(); ___3356 = copyFileContents(auxDataFileName, *szpltFile, routineName); } std::string geometryFileName = intermediateFileBaseName + GEOMETRY_FILE_SUFFIX; if (___3356 == 0) { ___3942[___1579] = szpltFile->fileLoc(); ___3356 = copyFileContents(geometryFileName, *szpltFile, routineName); } std::string textFileName = intermediateFileBaseName + TEXT_FILE_SUFFIX; if (___3356 == 0) { ___3942[___4081] = szpltFile->fileLoc(); ___3356 = copyFileContents(textFileName, *szpltFile, routineName); } std::string customLabelsFileName = intermediateFileBaseName + CUSTOM_LABELS_FILE_SUFFIX; if (___3356 == 0) { ___3942[___793] = szpltFile->fileLoc(); ___3356 = copyFileContents(customLabelsFileName, *szpltFile, routineName);
} if (___3356 == 0) { ___1391 dataSetHeaderLocation = szpltFile->fileLoc(); ___372 dataSetIsAvailable = (totalNumZones > 0); DataWriteStatistics ___933; if (!writeDataSetHeaders(*szpltFile, ___1385.getFileVersion(), dataSetIsAvailable, dataSetTitle, static_cast<___4349>(___2841), static_cast<___4633>(totalNumZones), ___3942, ___4703, ___4626, ___933) || !szpltFile->___3458() || !___4513(*szpltFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber(), dataSetHeaderLocation)) { ___3356 = -1; } } if (___3356 == 0 && !szpltFile->close(true)) { ___3184("Error in %s: Error attempting to close file %s.\n", routineName, szpltFile->___1392().c_str()); ___3356 = -1; } if (___3356 == 0) { if (!tempFileName.empty()) filesystem::fileRemove(tempFileName); headerFile->close(!cleanup); if (cleanup) { filesystem::fileRemove(auxDataFileName); filesystem::fileRemove(geometryFileName); filesystem::fileRemove(textFileName); filesystem::fileRemove(customLabelsFileName); } } else { headerFile->close(true); if (cleanup) { szpltFile->close(true); if (datFileMoved) filesystem::fileRename(szpltFileName, intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX); } else { szpltFile->close(false); } if (!tempFileName.empty()) filesystem::fileRename(tempFileName, szpltFileName); } } catch (std::bad_alloc const&) { ___3183("Error in %s: Out of memory.\n", routineName); ___3356 = -1; }
 #if defined TECIOMPI
} if (outputInfo) MPI_Bcast(&___3356, 1, MPI_INT, outputInfo->m_mainProcess, outputInfo->m_comm);
 #endif
return ___3356; } int32_t tecFileWriterOpen_SZL( char const* ___1392, char const* dataSetTitle, char const* variableList, int32_t     ___1405, int32_t     defaultVarType, void*       gridFileHandle, void**      fileHandle) { try { OutputInfo* gridOutputInfo = (OutputInfo*)gridFileHandle; if (___1405 == 2) { if (!gridOutputInfo) { ___3182("Error in tecFileWriterOpen: You must supply an open grid file (FileType = 1)\nto output a solution file (FileType = 2).\n"); return -1; } if (gridOutputInfo->m_debugLevel) { ___3182("Writing grid file prior to opening first solution file.\n"); } if (!gridOutputInfo->m_dataSetWriter && writeAllZonesToSZLFile(gridOutputInfo, "tecFileWriterOpen") != 0) { return -1; } } OutputInfo* outputInfo = new OutputInfo( dataSetTitle, variableList, ___1392, ".", ___1405, 0, defaultVarType, gridOutputInfo); *fileHandle = outputInfo;
 #if defined TECIOMPI
outputInfo->m_comm = MPI_COMM_SELF; outputInfo->m_communicator.reset(new MPICommunicator(MPI_COMM_SELF)); outputInfo->___2394.reset(new MPINonBlockingCommunicationCollection(MPI_COMM_SELF)); outputInfo->m_localProcess = 0; outputInfo->m_mainProcess = 0;
 #endif
} catch (std::exception const& e) { ___3183("Error in tecFileWriterOpen: %s\n", e.what()); return -1; } return 0; } int32_t tecFileSetDiagnosticsLevel_SZL(void* fileHandle, int32_t level) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecFileSetDiagnosticsLevel")) return -1; outputInfo->m_debugLevel = level; if (outputInfo->m_debugLevel) { ___3183("Enabling diagnostics for file \"%s\"\n", outputInfo->___2459.c_str()); ___3183("NumVars = %d\n", outputInfo->m_tecioData.___2841()); } return 0; }
 #if defined TECIOMPI
namespace {
 #if !defined NO_ASSERTS
size_t mpiSizeof(MPI_Datatype mpiDatatype) { int datatypeSize; if (MPI_Type_size(mpiDatatype, &datatypeSize) != MPI_SUCCESS) return 0; else return static_cast<size_t>(datatypeSize); }
 #endif
bool mpiBroadcastString(std::string& str, OutputInfo& outputInfo) { int length = static_cast<int>(str.size()); if (MPI_Bcast(&length, 1, MPI_INT, outputInfo.m_mainProcess, outputInfo.m_comm) != MPI_SUCCESS) return false; str.resize(static_cast<size_t>(length)); return (MPI_Bcast(&str[0], length, MPI_CHAR, outputInfo.m_mainProcess, outputInfo.m_comm) == MPI_SUCCESS); } int32_t szlMPIInit(OutputInfo* outputInfo, MPI_Comm comm, int mainProcess) { int32_t  ___3356 = 0; int rank; if (MPI_Comm_rank(comm, &rank) != MPI_SUCCESS) ___3356 = -1; if (___3356 == 0) { outputInfo->m_comm = comm; outputInfo->m_communicator.reset(new MPICommunicator(comm)); outputInfo->___2394.reset(new MPINonBlockingCommunicationCollection(comm)); outputInfo->m_mainProcess = mainProcess; outputInfo->m_localProcess = rank; if (!mpiBroadcastString(outputInfo->___2459, *outputInfo)) ___3356 = -1; } return ___3356; } } int32_t tecMPIInitialize_SZL(void* fileHandle, MPI_Comm communicator, int32_t mainRank) { BOOST_STATIC_ASSERT(sizeof(int) == 4); INVARIANT(mpiSizeof(MPI_INT) == 4); OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecMPIInitialize")) return -1; return szlMPIInit(outputInfo, communicator, mainRank); } int32_t tecMPIFileSetInfo_SZL(void* fileHandle, MPI_Info info) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecMPIFileSetInfo")) return -1; outputInfo->m_info = info; return 0; }
 #endif
namespace { char const* zoneTypeStrings[] = { "ORDERED", "FELINESEG", "FETRIANGLE", "FEQUADRILATERAL", "FETETRAHEDRON", "FEBRICK", "FEPOLYGON", "FEPOLYHEDRON", "FEMIXED" }; char const* varTypeStrings[] = { "", "FLOAT", "DOUBLE", "INT32", "INT16", "BYTE" }; void printVarInfo(int32_t const* varTypes, int32_t const* ___3549, int ___2841) { if (___3549) { std::ostringstream ___2890; for (int i = 0; i < ___2841; ++i) { if (i > 0) ___2890 << ","; ___2890 << ___3549[i]; } ___3183("      shareVarFromZone = %s\n", ___2890.str().c_str()); } else if (varTypes) { std::ostringstream ___2890; for (int i = 0; i < ___2841; ++i) { if (i > 0) ___2890 << ","; ___2890 << varTypeStrings[varTypes[i]]; } ___3183("      varTypes = %s\n", ___2890.str().c_str()); } } } int32_t tecZoneCreateIJK_SZL( void*          fileHandle, char const*    ___4687, int64_t        imax, int64_t        jmax, int64_t        kmax, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        shareFaceNeighborsFromZone, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreateIJK")) return -1; try { outputInfo->m_tecioData.___19( ___4687, 0, imax, jmax, kmax, 0, NULL, NULL, NULL, NULL, 0.0, 0, 0, ___2800, ___1282, 0, 0, 0, varTypes, ___2980, valueLocations, ___3549, shareFaceNeighborsFromZone); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4687); ___3182("      Type  = ORDERED\n"); ___3183("      IMax  = %" PRId64 "\n", imax); ___3183("      JMax  = %" PRId64 "\n", jmax); ___3183("      KMax  = %" PRId64 "\n", kmax); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreateIJK: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecZoneCreateFE_SZL( void*          fileHandle, char const*    ___4687, int32_t        ___4689, int64_t        ___2819, int64_t        ___2779, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreateFE")) return -1; try { outputInfo->m_tecioData.___19( ___4687, ___4689, ___2819, ___2779, 0, 0, NULL, NULL, NULL, NULL, 0.0, 0, 0, ___2800, ___1282, 0, 0, 0, varTypes, ___2980, valueLocations, ___3549, ___3547); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844());
outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4687); ___3183("      Type  = %s\n", zoneTypeStrings[___4689]); ___3183("      NumNodes  = %" PRId64 "\n", ___2819); ___3183("      NumCells  = %" PRId64 "\n", ___2779); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreateFE: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecZoneCreateFEMixed_SZL( void*          fileHandle, char const*    ___4687, int64_t        ___2819, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreateFEMixed")) { return -1; } try { int32_t ___4689 = 8; outputInfo->m_tecioData.___19( ___4687, ___4689, ___2819, std::accumulate(numElementsPerSection, numElementsPerSection+numSections, static_cast<int64_t>(0)), 0, numSections, cellShapePerSection, gridOrderPerSection, basisFnPerSection, numElementsPerSection, 0.0, 0, 0, ___2800, ___1282, 0, 0, 0, varTypes, ___2980, valueLocations, ___3549, ___3547); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("  Title = %s\n", ___4687); ___3183("  Type  = %s\n", zoneTypeStrings[___4689]); ___3183("  NumNodes  = %" PRId64 "\n", ___2819); ___3183("  NumSections  = %" PRId32 "\n", numSections); for (int32_t section = 0; section < numSections; ++section) { ___3183("    Section %" PRId32 ":\n", section); ___3183("      NumCells = %" PRId64 "\n", numElementsPerSection[section]); } printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreateFE: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecZoneCreatePoly_SZL( void*          fileHandle, char const*    ___4687, int32_t        ___4689, int64_t        ___2819, int64_t        numFaces, int64_t        ___2779, int64_t        ___4190, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2784, int64_t        ___4186, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreatePoly"))
return -1; try { outputInfo->m_tecioData.___19( ___4687, ___4689, ___2819, ___2779, numFaces, 0, NULL, NULL, NULL, NULL, 0.0, 0, 0, 0, 0, ___4190, ___2784, ___4186, varTypes, ___2980, valueLocations, ___3549, ___3547); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4687); ___3183("      Type  = %s\n", zoneTypeStrings[___4689]); ___3183("      NumNodes  = %" PRId64 "\n", ___2819); ___3183("      NumFaces  = %" PRId64 "\n", numFaces); ___3183("      NumCells  = %" PRId64 "\n", ___2779); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreatePoly: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } namespace { bool getOutputInfoAndZonePtr(OutputInfo** outputInfo, Zone_s** zonePtr, void* fileHandle, int32_t zone, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zonePtr)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(routineName)); if (!getOutputInfo(outputInfo, fileHandle, routineName)) return false; if (zone <= 0 || !(*outputInfo)->m_tecioData.zonePtr(zone)) { ___3184("Error in %s : invalid zone input parameter (%d).\n", routineName, zone); ++(*outputInfo)->m_numErrs; return false; } *zonePtr = (*outputInfo)->m_tecioData.zonePtr(zone); return true; } } int32_t tecZoneSetUnsteadyOptions_SZL( void*   fileHandle, int32_t zone, double  ___3638, int32_t ___3783) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecZoneSetUnsteadyOptions")) return -1; if (___3783 < 0) { ___3183("Error in tecZoneSetUnsteadyOptions : invalid strandID input parameter (%d).\n", ___3783); ++outputInfo->m_numErrs; return -1; } zonePtr->___2619 = ___3638; zonePtr->___2620 = ___3783; return 0; } int32_t tecZoneSetParentZone_SZL(void* fileHandle, int32_t zone, int32_t ___2972) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecZoneSetParentZone")) return -1; if (zone == ___2972 || outputInfo->m_tecioData.___2844() <= ___2972) { ___3183("Error in tecZoneSetParentZone : invalid parentZone input parameter (%d).\n", ___2972); ++outputInfo->m_numErrs; return -1; } zonePtr->___2612 = ___2972; return 0; }
 #if defined TECIOMPI
namespace { int32_t storeZonePartitionInfo( OutputInfo*    outputInfo, int32_t const  npartitions, int32_t const* ptnworkers, char const*    errorMessagePreamble) { try { std::vector<int32_t> partitionOwners(ptnworkers, ptnworkers + npartitions); bool keepZone = false; if (outputInfo->m_localProcess == outputInfo->m_mainProcess) { keepZone = true; } else { BOOST_FOREACH(int32_t owner, partitionOwners) { if (owner == outputInfo->m_localProcess) keepZone = true; } } if (keepZone) outputInfo->m_tecioData.setPartitionOwners(partitionOwners); else outputInfo->m_tecioData.dropLastZone(); } catch (std::exception const& e) { ___3184("%s: %s\n", errorMessagePreamble, e.what()); ++(outputInfo->m_numErrs); return -1; } return 0; } } int32_t tecZoneMapPartitionsToMPIRanks_SZL( void*          fileHandle, int32_t        numPartitions, int32_t const* mpiRanksForPartitions) { REQUIRE(numPartitions > 0); REQUIRE(VALID_REF(mpiRanksForPartitions)); OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneMapPartitionsToMPIRanks")) return -1; return storeZonePartitionInfo(outputInfo, numPartitions, mpiRanksForPartitions, "Error in tecZoneMapPartitionsToMPIRanks"); }
 #endif
namespace { template <typename T> int32_t fePartitionCreate( char const*    routineName, void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t const* numCellsPerSection, int64_t        numGhostNodes, T const*       ghostNodes, int32_t const* neighborPartitions, T const*       neighborPartitionNodes, int64_t const* numGhostCellsPerSection, T const*       ghostCells) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecFEPartitionCreate64")) return -1; if (___2975 < 1) { ___3184("Error in %s: invalid partition input parameter (%d).\n", routineName, ___2975); ++outputInfo->m_numErrs; return -1; } if (!___3892(zonePtr->___2682, zonePtr->m_zoneDimension)) { ___3183("Error in %s: Called for the wrong zone type; can be called only for 3D FE zones.\n", routineName); ++outputInfo->m_numErrs; return -1; } if (___2819 < 1) { ___3184("Error in %s: Invalid numNodes input parameter (%" PRId64 ").\n", routineName, ___2819); ++outputInfo->m_numErrs; return -1; } int32_t const numSections = zonePtr->___2682 == ZoneType_FEMixed ? checked_numeric_cast<int32_t>(zonePtr->m_cellShapes.size()) : int32_t(1); int64_t const totalNumCells = std::accumulate(numCellsPerSection, numCellsPerSection+numSections, int64_t(0)); if (totalNumCells < 1) { ___3184("Error in %s: Invalid numCells or numCellsPerSection input parameter (%" PRId64 ").\n", routineName, totalNumCells); ++outputInfo->m_numErrs; return -1; } if (numGhostNodes < 0) { ___3184("Error in %s: Invalid numGhostNodes input parameter (%" PRId64 ").\n", routineName, numGhostNodes); ++outputInfo->m_numErrs; return -1; } if (numGhostNodes > 0) { if (!ghostNodes) { ___3183("Error in %s: Invalid ghostNodes input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } else if (!neighborPartitions) { ___3183("Error in %s: Invalid neighborPartitions input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } else if (!neighborPartitionNodes) { ___3183("Error in %s: Invalid neighborPartitionNodes input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } } if (numGhostCellsPerSection == NULL && ghostCells != NULL) { ___3183("Error in %s: Invalid numGhostCellsPerSection array parameter. Expected numGhostCellsPerSection to be non-NULL if ghostCells array is non-NULL.\n", routineName); ++outputInfo->m_numErrs; return -1; } int64_t totalNumGhostCells = 0; if (numGhostCellsPerSection != NULL && ghostCells != NULL) { totalNumGhostCells = std::accumulate(numGhostCellsPerSection, numGhostCellsPerSection+numSections, int64_t(0)); if (totalNumGhostCells < 0) { ___3184("Error in %s: Invalid numGhostCells or numGhostCellsPerSection input parameter (%" PRId64 ").\n", routineName, totalNumGhostCells); ++outputInfo->m_numErrs; return -1; } if (totalNumGhostCells > 0 && ghostCells == NULL) { ___3183("Error in %s: Invalid ghostCells input parameter.\n", routineName); ++outputInfo->m_numErrs;
return -1; } } try {
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error(std::string("Must call tecZoneMapPartitionsToMPIRanks prior to calling ") + routineName); } else if (static_cast<size_t>(___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to " << routineName << ": " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #endif 
outputInfo->m_tecioData.addFEZonePartition( zone, ___2975, ___2819, tecplot::___3267<int64_t const>(numCellsPerSection, numSections, numSections), tecplot::___3267<T const>(ghostNodes, numGhostNodes, numGhostNodes), tecplot::___3267<int32_t const>(neighborPartitions, numGhostNodes, numGhostNodes), tecplot::___3267<T const>(neighborPartitionNodes, numGhostNodes, numGhostNodes), tecplot::___3267<int64_t const>(numGhostCellsPerSection, numSections, numSections), tecplot::___3267<T const>(ghostCells, totalNumGhostCells, totalNumGhostCells)); } catch (std::exception const& e) { ___3184("Error in %s: %s\n", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } } int32_t tecFEPartitionCreate32_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { return fePartitionCreate<int32_t>( "tecFEPartitionCreate32", fileHandle, zone, ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } int32_t tecFEPartitionCreate64_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int64_t const* ghostCells) { return fePartitionCreate<int64_t>( "tecFEPartitionCreate64", fileHandle, zone, ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } namespace { bool checkParameter(int64_t parameter, char const* parameterName, int64_t minValue, int64_t maxValue) { if (parameter < minValue || parameter > maxValue) { ___3184("Error in tecIJKPartitionCreate: Invalid %s input parameter (%" PRId64 ").\n", parameterName, parameter); return false; } else { return true; } } } int32_t tecIJKPartitionCreate_SZL( void*   fileHandle, int32_t zone, int32_t ___2975, int64_t imin, int64_t jmin, int64_t kmin, int64_t imax, int64_t jmax, int64_t kmax) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecIJKPartitionCreate")) return -1; if (___2975 < 1) { ___3183("Error in tecIJKPartitionCreate : invalid partition input parameter (%d).\n", ___2975); ++outputInfo->m_numErrs; return -1; } if (!supportedOrderedVolumeZoneType(zonePtr->___2682, zonePtr->m_zoneDimension)) { ___3182("Error in tecIJKPartitionCreate: Called for the wrong zone type; can be called only for 3D ordered zones.\n"); ++outputInfo->m_numErrs; return -1; } if (___2975 < 1) { ___3183("Error in tecIJKPartitionCreate: Invalid Partition input parameter (%d).\n", ___2975);
++outputInfo->m_numErrs; return -1; } if (!checkParameter(imin, "imin", 1, zonePtr->___2680.i()) || !checkParameter(jmin, "jmin", 1, zonePtr->___2680.___2103()) || !checkParameter(kmin, "kmin", 1, zonePtr->___2680.___2132()) || !checkParameter(imax, "imax", imin, zonePtr->___2680.i()) || !checkParameter(jmax, "jmax", jmin, zonePtr->___2680.___2103()) || !checkParameter(kmax, "kmax", kmin, zonePtr->___2680.___2132())) { ++outputInfo->m_numErrs; return -1; } try {
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call tecZoneMapPartitionsToMPIRanks prior to calling tecIJKPartitionCreate"); } else if (static_cast<size_t>(___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to tecIJKPartitionCreate: " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #endif 
outputInfo->m_tecioData.addIJKZonePartition(zone, ___2975, imin, jmin, kmin, imax, jmax, kmax); } catch (std::exception const& e) { ___3183("Error in tecZoneMapPartitionsToMPIRanks: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } namespace { bool getOutputInfoAndZoneOrPartitionPtr(OutputInfo** outputInfo, Zone_s** zoneOrPartitionPtr, void* fileHandle, int32_t zone, int32_t ___2975, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zoneOrPartitionPtr)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___2975 >= 0); REQUIRE(VALID_REF(routineName)); if (!getOutputInfoAndZonePtr(outputInfo, zoneOrPartitionPtr, fileHandle, zone, routineName)) return false; if (!(*zoneOrPartitionPtr)->m_partitionMap.empty()) { if ((*zoneOrPartitionPtr)->m_partitionMap.find(___2975 - 1) == (*zoneOrPartitionPtr)->m_partitionMap.end()) { ___3184("Error in %s : invalid partition input parameter (%d).\n", routineName, ___2975); ++(*outputInfo)->m_numErrs; return false; } (*zoneOrPartitionPtr) = (*zoneOrPartitionPtr)->m_partitionMap[___2975 - 1].get(); } return true; } template <typename T> int32_t zoneVarWriteValues( void*       fileHandle, int32_t     zone, int32_t     ___4333, int32_t     ___2975, int64_t     count, T const*    values, char const* routineName) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZoneOrPartitionPtr(&outputInfo, &zonePtr, fileHandle, zone, ___2975, routineName)) return -1; if (zonePtr->m_passiveVars[___4333 - 1]) { ___3184("Error in %s : Variable %d is a passive var, so values cannot be written to it.\n", routineName, ___4333); ++outputInfo->m_numErrs; return -1; } else if (zonePtr->m_shareVarFromZone[___4333 - 1]) { ___3185("Error in %s : Variable %d is shared with zone %d, so values cannot be written to it.\n", routineName, ___4333, zone); ++outputInfo->m_numErrs; return -1; } ___1360* ___1349 = zonePtr->___2494[___4333 - 1].get(); if (outputInfo->m_debugLevel && (count > 1)) ___3185("Writing %" PRId64 " values to zone %d, var %d.\n", count, zone, ___4333); if (___1349->storedValueCount() == 0) ___1349->reserveValues(___1349->___2666); for (int64_t i = 0; i < count; ++i) { if (___1349->storedValueCount() >= ___1349->___2666) { int64_t extraValues = count - i; if (___2975 == 0) PRINT4("Error in %s: Too many values supplied for zone %d var %d (%" PRId64 " extra values).\n", routineName, zone, ___4333, extraValues); else PRINT5("Error in %s: Too many values supplied for zone %d var %d partition %d (%" PRId64 " extra values).\n", routineName, zone, ___4333, ___2975, extraValues); ++outputInfo->m_numErrs; return -1; } ___1349->appendValue(checked_numeric_cast<double>(values[i])); if (zonePtr->___2682 == ___4701 && ___1349->___2667 == ___4325) { padCCValuesIfNecessary(*___1349, zonePtr->___2680.i(), zonePtr->___2680.___2103(), zonePtr->___2680.___2132()); } } return 0; } } int32_t tecZoneVarWriteDoubleValues_SZL( void*         fileHandle,
int32_t       zone, int32_t       ___4333, int32_t       ___2975, int64_t       count, double const* values) { return zoneVarWriteValues( fileHandle, zone, ___4333, ___2975, count, values, "tecZoneVarWriteDoubleValues"); } int32_t tecZoneVarWriteFloatValues_SZL( void*         fileHandle, int32_t       zone, int32_t       ___4333, int32_t       ___2975, int64_t       count, float const*  values) { return zoneVarWriteValues( fileHandle, zone, ___4333, ___2975, count, values, "tecZoneVarWriteFloatValues"); } int32_t tecZoneVarWriteInt32Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, int32_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4333, ___2975, count, values, "tecZoneVarWriteInt32Values"); } int32_t tecZoneVarWriteInt16Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, int16_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4333, ___2975, count, values, "tecZoneVarWriteInt16Values"); } int32_t tecZoneVarWriteUInt8Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, uint8_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4333, ___2975, count, values, "tecZoneVarWriteUInt8Values"); } namespace { template <typename T> int32_t zoneNodeMapWrite( void*       fileHandle, int32_t     zone, int32_t     ___2975, int32_t     nodesAreOneBased, int64_t     count, T const*    nodes, char const* routineName) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZoneOrPartitionPtr(&outputInfo, &zonePtr, fileHandle, zone, ___2975, routineName)) return -1; if (count + zonePtr->___2495->storedValueCount() > zonePtr->___2495->expectedValueCount()) { ___3185("Error in %s: Too many node map values for this zone. %" PRIu64 " supplied, need only %" PRIu64 " more values.\n", routineName, count, zonePtr->___2495->expectedValueCount() - zonePtr->___2495->storedValueCount()); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel && (count > 1)) ___3184("Writing %" PRId64 " nodes to zone %d.\n", count, zone); for (int64_t i = 0; i < count; ++i) { T ___2707 = nodes[i]; if (nodesAreOneBased) --___2707; if (___2707 < 0 || zonePtr->___2680.i() <= (___81)___2707) { T maxValue = static_cast<T>(zonePtr->___2680.i()); if (!nodesAreOneBased) --maxValue; std::ostringstream ___2890; ___2890 << routineName << ": Invalid node map value at position " << i << std::endl << "     node map value = " << nodes[i] << ", max value = " << maxValue << "." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; return -1; } zonePtr->___2495->appendValue(___2707); } return 0; } } int32_t tecZoneNodeMapWrite32_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased, int64_t        count, int32_t const* nodes)
{ return zoneNodeMapWrite(fileHandle, zone, ___2975, nodesAreOneBased, count, nodes, "tecZoneNodeMapWrite32"); } int32_t tecZoneNodeMapWrite64_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased, int64_t        count, int64_t const* nodes) { return zoneNodeMapWrite(fileHandle, zone, ___2975, nodesAreOneBased, count, nodes, "tecZoneNodeMapWrite64"); } namespace { template <typename T> int32_t zoneFaceNbrWriteConnections( void*       fileHandle, int32_t     zone, T const*    faceNeighbors, char const* routineName) { OutputInfo* outputInfo = (OutputInfo*)fileHandle; Zone_s* zonePtr = outputInfo->m_tecioData.zonePtr(zone); if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, routineName)) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting face neighbor data for zone %d\n", zone); try { if (outputInfo->m_debugLevel) ___3183("\nInserting face neighbor data for zone %d\n", zone); outputInfo->m_tecioData.___430(zonePtr, faceNeighbors); } catch (std::exception const& e) { ___3184("Error in %s: %s\n", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } } int32_t tecZoneFaceNbrWriteConnections32_SZL( void*          fileHandle, int32_t        zone, int32_t const* faceNeighbors) { return zoneFaceNbrWriteConnections(fileHandle, zone, faceNeighbors, "tecZoneFaceNbrWriteConnections32"); } int32_t tecZoneFaceNbrWriteConnections64_SZL( void*          fileHandle, int32_t        zone, int64_t const* faceNeighbors) { return zoneFaceNbrWriteConnections(fileHandle, zone, faceNeighbors, "tecZoneFaceNbrWriteConnections64"); } int32_t tecZoneWritePolyFaces32_SZL( void*           , int32_t         , int32_t         , int32_t         , int32_t const*  , int32_t const*  , int32_t const*  , int32_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyFaces64_SZL( void*           , int32_t         , int32_t         , int64_t         , int32_t const*  , int64_t const*  , int64_t const*  , int64_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyBoundaryConnections32_SZL( void*           , int32_t         , int32_t         , int32_t         , int32_t const*  , int32_t const*  , int32_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyBoundaryConnections64_SZL( void*           , int32_t         , int32_t         , int64_t         , int32_t const*  , int64_t const*  , int32_t const*  , int32_t         ) { return 0; } namespace { bool auxDataIsValidNameChar(char c, bool isLeadChar) { REQUIRE(0 <= c && "c <= 127"); bool isValidNameChar = (c == '_' || tecplot::___1996(c)); if (!isLeadChar) isValidNameChar = (isValidNameChar || c == '.' || tecplot::___2010(c)); return isValidNameChar; } bool auxDataIsValidName(char const* ___2683) { REQUIRE(VALID_REF(___2683)); bool isValidName = auxDataIsValidNameChar(*___2683, true); for (char const* nPtr = ___2683; isValidName && *nPtr != '\0'; ++nPtr) isValidName = auxDataIsValidNameChar(*nPtr, false);
return isValidName; } bool checkAuxNameAndValue(OutputInfo* outputInfo, char const* ___2683, char const* value, char const* routineName) { if ((___2683 == NULL) || !auxDataIsValidName(___2683)) { ___3183("Error in %s: Invalid Name string\n", routineName); ++outputInfo->m_numErrs; return false; } if ((value == NULL) || (*value == '\0')) { ___3183("Error in %s: Invalid Value string\n", routineName); ++outputInfo->m_numErrs; return false; } return true; } } int32_t tecDataSetAddAuxData_SZL( void*       fileHandle, char const* ___2683, char const* value) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecDataSetAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting data set aux data: '%s' = '%s'\n", ___2683, value); if (!checkAuxNameAndValue(outputInfo, ___2683, value, "TECAUXSTR")) return -1; outputInfo->m_tecioData.___8(___2683, value); return 0; } int32_t tecVarAddAuxData_SZL( void*       fileHandle, int32_t     ___4333, char const* ___2683, char const* value) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecVarAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting variable aux data: '%s' = '%s'\n", ___2683, value); if (!checkAuxNameAndValue(outputInfo, ___2683, value, "tecVarAddAuxData")) return -1; outputInfo->m_tecioData.___18(___4333, ___2683, value); return 0; } int32_t tecZoneAddAuxData_SZL( void*       fileHandle, int32_t     zone, char const* ___2683, char const* value) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting zone aux data: '%s' = '%s'\n", ___2683, value); if (!checkAuxNameAndValue(outputInfo, ___2683, value, "tecZoneAddAuxData")) return -1; outputInfo->m_tecioData.___20(zone, ___2683, value); return 0; } namespace { char const* geomTypeStrings[] = { "2D Line", "Rectangle", "Square", "Circle", "Ellipse", "3D Line" }; } int32_t tecGeom2DLineSegmentsBegin_SZL( void*         fileHandle, double        xOrigin, double        yOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, int32_t       ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom2DLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom2DLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (numPoints < 2) { ___3183("Error in tecGeom2DLineSegmentsBegin: numPoints = %d. numPoints must be >= 2.\n", numPoints); ++outputInfo->m_numErrs; return -1; } if (___3157 != 0 && ___3157 != 1) { ___3183("Error in tecGeom2DLineSegmentsBegin: posCoordMode = %d. posCoordMode must be 0 or 1.\n", numPoints); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2462.resize(1);
outputInfo->m_geom.___2462[0].reserve(numPoints); for (int32_t i = 0; i < numPoints; ++i) { outputInfo->m_geom.___2462[0].push_back(___4577(relativeX[i], relativeY[i], 0.0)); } outputInfo->m_geom.___2464 = GeomType_LineSegs; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom2DLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom2DMultiLineSegmentsBegin_SZL( void*          fileHandle, double         xOrigin, double         yOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, int32_t        ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom2DMultiLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom2DMultiLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (___2833 <= 0) { ___3183("Error in tecGeom2DMultiLineSegmentsBegin: numSegments = %d. numSegments must be > 0.\n", ___2833); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting multi-line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2462.resize(___2833); int32_t pos = 0; for (int32_t i = 0; i < ___2833; ++i) { if (numSegmentPoints[i] < 2) { ___3184("Error in tecGeom2DMultiLineSegmentsBegin: numSegmentsPoints[%d] = %d.\n" "Each entry of numSegmentPoints must be >= 2.\n", i, numSegmentPoints[i]); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2462[i].reserve(numSegmentPoints[i]); for (int32_t ___2103 = 0; ___2103 < numSegmentPoints[i]; ++___2103) { outputInfo->m_geom.___2462[i].push_back(___4577(relativeX[pos], relativeY[pos], 0.0)); ++pos; } } outputInfo->m_geom.___2464 = GeomType_LineSegs; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom2DMultiLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom3DLineSegmentsBegin_SZL( void* fileHandle, double xOrigin, double yOrigin, double zOrigin, int32_t numPoints, double const* relativeX, double const* relativeY, double const* relativeZ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom3DLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom3DLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (numPoints < 2) { ___3183("Error in tecGeom3DLineSegmentsBegin: numPoints = %d. numPoints must be >= 2.\n", numPoints); ++outputInfo->m_numErrs;
return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting 3D line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2615[2] = zOrigin; outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].reserve(numPoints); for (int32_t i = 0; i < numPoints; ++i) { outputInfo->m_geom.___2462[0].push_back(___4577(relativeX[i], relativeY[i], relativeZ[i])); } outputInfo->m_geom.___2464 = GeomType_LineSegs3D; outputInfo->m_geom.___2614 = CoordSys_Grid3D; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom3DLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom3DMultiLineSegmentsBegin_SZL( void*          fileHandle, double         xOrigin, double         yOrigin, double         zOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, double const*  relativeZ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom3DMultiLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom3DMultiLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (___2833 <= 0) { ___3183("Error in tecGeom3DMultiLineSegmentsBegin: numSegments = %d. numSegments must be > 0.\n", ___2833); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting 3D multi-line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2615[2] = zOrigin; outputInfo->m_geom.___2462.resize(___2833); int32_t pos = 0; for (int32_t i = 0; i < ___2833; ++i) { if (numSegmentPoints[i] < 2) { ___3184("Error in tecGeom3DMultiLineSegmentsBegin: numSegmentsPoints[%d] = %d.\n" "Each entry of numSegmentPoints must be >= 2.\n", i, numSegmentPoints[i]); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2462[i].reserve(numSegmentPoints[i]); for (int32_t ___2103 = 0; ___2103 < numSegmentPoints[i]; ++___2103) { outputInfo->m_geom.___2462[i].push_back(___4577(relativeX[pos], relativeY[pos], relativeZ[pos])); ++pos; } } outputInfo->m_geom.___2464 = GeomType_LineSegs3D; outputInfo->m_geom.___2614 = CoordSys_Grid3D; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom3DMultiLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomCircleBegin_SZL( void*   fileHandle, double  xCenter, double  yCenter, double  radius, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomCircleBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomCircleBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n");
++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting circle Geometry\n"); outputInfo->m_geom.___2615[0] = xCenter; outputInfo->m_geom.___2615[1] = yCenter; outputInfo->m_geom.___2464 = GeomType_Circle; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4577(radius, 0.0, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomCircleBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomEllipseBegin_SZL( void*   fileHandle, double  xCenter, double  yCenter, double  ___4455, double  ___1824, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEllipseBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomEllipseBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting ellipse Geometry\n"); outputInfo->m_geom.___2615[0] = xCenter; outputInfo->m_geom.___2615[1] = yCenter; outputInfo->m_geom.___2464 = GeomType_Ellipse; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4577(___4455, ___1824, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomEllipseBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomRectangleBegin_SZL( void*   fileHandle, double  xMin, double  yMin, double  xMax, double  yMax, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomRectangleBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomRectangleBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting rectangle Geometry\n"); outputInfo->m_geom.___2615[0] = xMin; outputInfo->m_geom.___2615[1] = yMin; outputInfo->m_geom.___2464 = GeomType_Rectangle; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4577(xMax - xMin, yMax - yMin, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomRectangleBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomSquareBegin_SZL( void*   fileHandle, double  xMin, double  yMin, double  size, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSquareBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSquareBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n");
++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting square Geometry\n"); outputInfo->m_geom.___2615[0] = xMin; outputInfo->m_geom.___2615[1] = yMin; outputInfo->m_geom.___2464 = GeomType_Square; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4577(size, 0.0, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomSquareBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomArrowheadSetInfo_SZL( void*   fileHandle, double  ___56, int32_t attachment, double  size, int32_t style) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomArrowheadSetInfo")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomArrowheadSetInfo: You must begin a geometry by calling tecGeom2DLineSegmentsBegin\n" "or tecGeom3DLineSegmentsBegin before calling tecGeomArrowheadSetInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_geom.___2464 != GeomType_LineSegs && outputInfo->m_geom.___2464 != GeomType_LineSegs3D) { ___3183("Warning in tecGeomArrowheadSetInfo: Arrowhead info affects only line segment geometries.\n" " The current grometry type is %s. Continuing...\n", geomTypeStrings[outputInfo->m_geom.___2464]); } if (___56 <= 0.0) { ___3183("Error in tecGeomArrowheadSetInfo: angle = %g. angle must be > 0.\n", ___56); ++outputInfo->m_numErrs; return -1; } if (attachment < 0 || 3 < attachment) { ___3183("Error in tecGeomArrowheadSetInfo: attachment = %d. Must be 0 <= attachment <= 3.\n", attachment); ++outputInfo->m_numErrs; return -1; } if (size < 0.0) { ___3183("tecGeomArrowheadSetInfo: size = %g. size must be >= 0.\n", size); ++outputInfo->m_numErrs; return -1; } if (style < 0 || 2 < style) { ___3183("Error in tecGeomArrowheadSetInfo: style = %d. Must be 0 <= style <= 2.\n", style); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2338      = ___56; outputInfo->m_geom.___2339 = (ArrowheadAttachment_e)attachment; outputInfo->m_geom.___2340       = size; outputInfo->m_geom.___2341      = (ArrowheadStyle_e)style; return 0; } int32_t tecGeomEllipseSetNumPoints_SZL( void*   fileHandle, int32_t numEllipsePoints) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEllipseSetNumPoints")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetNumEllipsePoints: You must begin a geometry before calling tecGeomEllipseSetNumPoints.\n"); ++outputInfo->m_numErrs; return -1; } if (numEllipsePoints < 3 || 720 < numEllipsePoints) { ___3183("Error in tecGeomEllipseSetNumPoints: numEllipsePoints = %d. Must be 3 <= numEllipsePoints <= 720.\n", numEllipsePoints); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_geom.___2464 != GeomType_Circle && outputInfo->m_geom.___2464 != GeomType_Ellipse) {
___3183("Warning in tecGeomEllipseSetNumPoints: numEllipsePts affects only circle and ellipse geometries.\n" "The current geometry's type is %s. Continuing...\n", geomTypeStrings[outputInfo->m_geom.___2464]); } outputInfo->m_geom.___2500 = static_cast<uint16_t>(numEllipsePoints); return 0; } int32_t tecGeomSetClipping_SZL( void*   fileHandle, int32_t ___493) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetClipping")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetClipping: You must begin a geometry before calling tecGeomSetClipping.\n"); ++outputInfo->m_numErrs; return -1; } if (___493 != 0 && ___493 != 1) { ___3183("Error in tecGeomSetClipping: clipping = %d. clipping must = 0 or 1.\n", ___493); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2392 = static_cast<Clipping_e>(___493); return 0; } int32_t tecGeomSetLineInfo_SZL( void*   fileHandle, int32_t ___2261, double  ___2984, double  thickness, int32_t color) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetLineInfo")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetLineInfo: You must begin a geometry before calling tecGeomSetLineInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (___2261 < 0 || 5 < ___2261) { ___3183("Error in tecGeomSetLineInfo: linePattern = %d. Must be 0 <= linePattern <= 5.\n", ___2261); ++outputInfo->m_numErrs; return -1; } if (___2984 < .0001 || 100.0 < ___2984) { ___3183("Error in tecGeomSetLineInfo: patternLength = %g. Must be 0.0001 <= patternLength <= 100.\n", ___2984); ++outputInfo->m_numErrs; return -1; } if (thickness < .01 || 100.0 < thickness) { ___3183("Error in tecGeomSetLineInfo: thickness = %g. Must be 0.01 <= thickness <= 100.\n", thickness); ++outputInfo->m_numErrs; return -1; } if (color < 0 || 15 < color) { ___3183("Error in tecGeomSetLineInfo: color = %d. Must be 0 <= color <= 15.\n", color); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2487 = (LinePattern_e)___2261; outputInfo->m_geom.___2613 = ___2984; outputInfo->m_geom.___2488 = thickness; outputInfo->m_geom.___2393 = color; return 0; } int32_t tecGeomSetMacroFunctionCmd_SZL( void*       fileHandle, char const* macroFunctionCmd) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetMacroFunctionCmd")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetMacroFunctionCmd: You must begin a geometry before calling tecGeomSetMacroFunctionCmd.\n"); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2489 = macroFunctionCmd; return 0; } int32_t tecGeomSetScope_SZL( void*   fileHandle, int32_t ___3440) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetScope")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetScope: You must begin a geometry before calling tecGeomSetScope.\n");
++outputInfo->m_numErrs; return -1; } if (___3440 != 0 && ___3440 != 1) { ___3183("Error in tecGeomSetScope: ___3440 = %d. Must be 0 or 1.\n", ___3440); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2617 = (Scope_e)___3440; return 0; } int32_t tecGeomAttachToZone_SZL( void*   fileHandle, int32_t zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomAttachToZone")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomAttachToZone: You must begin a geometry before calling tecGeomAttachToZone.\n"); ++outputInfo->m_numErrs; return -1; } if (zone <= 0) { ___3183("Error in tecGeomAttachToZone: zone = %d. Must be > 0.\n", zone); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2482 = ___4224; outputInfo->m_geom.___2675 = zone; return 0; } int32_t tecGeomFill_SZL( void*   fileHandle, int32_t ___1409) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomFill")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomFill: You must begin a geometry before calling tecGeomFill.\n"); ++outputInfo->m_numErrs; return -1; } if (___1409 < 0 || 15 < ___1409) { ___3183("Error in tecGeomFill: ___1409 = %d. Must be 0 <= ___1409 <= 15.\n", ___1409); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2484 = ___4224; outputInfo->m_geom.___2460 = ___1409; return 0; } int32_t tecGeomEnd_SZL(void* fileHandle) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEnd")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomEnd: You must begin a geometry before calling tecGeomEnd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_tecioData.___9(outputInfo->m_geom); outputInfo->m_geom = ___1554::invalidGeom(); return 0; } catch (std::bad_alloc const&) { ___3182("Error in tecGeomEnd: Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } } int32_t tecCustomLabelsAddSet_SZL( void*       fileHandle, char const* ___2171) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecCustomLabelsAddSet")) return -1; if (outputInfo->m_debugLevel) ___3182("\nInserting Custom Labels:\n"); std::string inputString(___2171); boost::escaped_list_separator<char> ___3473("\\", ", \t", "\""); typedef boost::tokenizer<boost::escaped_list_separator<char> > LabelTokenizer_t; LabelTokenizer_t labelTokenizer(inputString, ___3473); std::vector<std::string> ___2169; for (LabelTokenizer_t::iterator labelIt = labelTokenizer.begin(); labelIt != labelTokenizer.end(); ++labelIt) { std::string label = *labelIt; if (!label.empty()) { boost::trim(label); ___2169.push_back(label); if (outputInfo->m_debugLevel) ___3183("          %s\n", label.c_str()); } } outputInfo->m_tecioData.___6(___2169); return 0; } namespace { bool validateTextHeightAndUnits(OutputInfo* outputInfo, double ___1824, int32_t sizeUnits, char const* routineName) { if (sizeUnits < 0 || 2 < sizeUnits)
{ ___3184("Error in %s: sizeUnits = %d. Must be 0 <= sizeUnits <= 2.\n", routineName, sizeUnits); ++outputInfo->m_numErrs; return false; } if (sizeUnits == 1) { if (___1824 < 0.0 || 100.0 < ___1824) { ___3184("Error in %s: height = %g. Must 0 <= height <= 100 when sizeUnits = 1 (Frame coordinates).\n", routineName, ___1824); ++outputInfo->m_numErrs; return false; } } else if (___1824 < 0.0) { ___3184("Error in %s: height = %g. height must >= 0.\n", routineName, ___1824); ++outputInfo->m_numErrs; return false; } return true; } } int32_t tecText2DBegin_SZL( void*       fileHandle, char const* string, double      x, double      ___4580, int32_t     ___3157, double      ___1824, int32_t     sizeUnits) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecText2DBegin")) return -1; if (outputInfo->m_text.___2065()) { ___3182("Error in tecText2DBegin: You must end the current text by calling tecTextEnd before beginning a new text.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(string)) { ___3182("Error in tecText2DBegin: Invalid string input parameter.\n"); ++outputInfo->m_numErrs; return -1; } if (___3157 != 0 && ___3157 != 1) { ___3183("Error in tecText2DBegin: posCoordMode = %d. posCoordMode must be zero or 1.\n", ___3157); ++outputInfo->m_numErrs; return -1; } if (!validateTextHeightAndUnits(outputInfo, ___1824, sizeUnits, "tecText2DBegin")) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting Text: %s\n", string); try { outputInfo->m_text.___2641 = string; outputInfo->m_text.___2624[0] = x; outputInfo->m_text.___2624[1] = ___4580; outputInfo->m_text.___2637 = (CoordSys_e)___3157; outputInfo->m_text.___2633 = ___1824; outputInfo->m_text.___2640 = (Units_e)sizeUnits; } catch (std::bad_alloc const&) { ___3182("Error in tecText2DBegin: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecText3DBegin_SZL( void*       fileHandle, char const* string, double      x, double      ___4580, double      z, double      ___1824, int32_t     sizeUnits) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecText3DBegin")) return -1; if (outputInfo->m_text.___2065()) { ___3182("Error in tecText3DBegin: You must end the current text by calling tecTextEnd before beginning a new text.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(string)) { ___3182("Error in tecText3DBegin: Invalid string input parameter.\n"); ++outputInfo->m_numErrs; return -1; } if (!validateTextHeightAndUnits(outputInfo, ___1824, sizeUnits, "tecText3DBegin")) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting 3D Text: %s\n", string); try { outputInfo->m_text.___2641 = string; outputInfo->m_text.___2624[0] = x; outputInfo->m_text.___2624[1] = ___4580; outputInfo->m_text.___2624[1] = z; outputInfo->m_text.___2637 = CoordSys_Grid3D; outputInfo->m_text.___2633 = ___1824; outputInfo->m_text.___2640 = (Units_e)sizeUnits;
} catch (std::bad_alloc const&) { ___3182("Error in tecText2DBegin: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextAttachToZone_SZL(void* fileHandle, int32_t zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextAttachToZone")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextAttachToZone: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextAttachToZone.\n"); ++outputInfo->m_numErrs; return -1; } if (zone <= 0) { ___3183("Error in tecTextAttachToZone: zone = %d. zone must be > 0.\n", zone); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2645  = zone; outputInfo->m_text.___2634 = true; return 0; } int32_t tecTextBoxSetInfo_SZL( void*   fileHandle, int32_t ___410, int32_t lineColor, int32_t ___1409, double  ___2287, double  margin) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextBoxSetInfo")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextBoxSetInfo: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextBoxSetInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (___410 < 0 || 2 < ___410) { ___3183("Error in tecTextBoxSetInfo: boxType = %d. Must be 0 <= boxType <= 2.\n", ___410); ++outputInfo->m_numErrs; return -1; } if (lineColor < 0 || 15 < lineColor) { ___3183("Error in tecTextBoxSetInfo: lineColor = %d. Must be 0 <= lineColor <= 15.\n", lineColor); ++outputInfo->m_numErrs; return -1; } if (___1409 < 0 || 15 < ___1409) { ___3183("Error in tecTextBoxSetInfo: fillColor = %d. Must be 0 <= fillColor <= 15.\n", ___1409); ++outputInfo->m_numErrs; return -1; } if (___2287 < .0001 || 100.0 < ___2287) { ___3183("Error in tecTextBoxSetInfo: lineThickness = %g. Must be 0.0001 <= lineThickness <= 100.\n", ___2287); ++outputInfo->m_numErrs; return -1; } if (margin < 0.0 || 100.0 < margin) { ___3183("Error in tecTextBoxSetInfo: margin = %g. Must be 0 <= margin <= 100.\n", margin); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2630 = (TextBox_e)___410; outputInfo->m_text.___2626 = lineColor; outputInfo->m_text.___2627 = ___1409; outputInfo->m_text.___2628 = ___2287; outputInfo->m_text.___2629 = margin; return 0; } int32_t tecTextSetAnchor_SZL( void*   fileHandle, int32_t ___38) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetAnchor")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetAnchor: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextSetAnchor.\n"); ++outputInfo->m_numErrs; return -1; } if (___38 < 0 || 8 < ___38) { ___3183("Error in tecTextSetAnchor: anchor = %d. Must be 0 <= anchor <= 8.\n", ___38); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2623 = (TextAnchor_e)___38; return 0; } int32_t tecTextSetAngle_SZL(
void*  fileHandle, double ___56) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetAngle")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetAngle: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextSetAngle.\n"); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2625 = ___56; return 0; } int32_t tecTextSetClipping_SZL( void*   fileHandle, int32_t ___493) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetClipping")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetClipping: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetClipping.\n"); ++outputInfo->m_numErrs; return -1; } if (___493 != 0 && ___493 != 1) { ___3183("Error in tecTextSetClipping: clipping = %d. Must be 0 or 1.\n", ___493); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2631 = (Clipping_e)___493; return 0; } int32_t tecTextSetColor_SZL( void*   fileHandle, int32_t color) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetColor")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetColor: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetColor.\n"); ++outputInfo->m_numErrs; return -1; } if (color < 0 || 15 < color) { ___3183("Error in tecTextSetColor: color = %d. Must be 0 <= color <= 15.\n", color); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2632 = color; return 0; } int32_t tecTextSetTypeface_SZL( void*       fileHandle, char const* family, int32_t     isBold, int32_t     isItalic) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetTypeface")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetTypeface: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetTypeface.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(family)) { ___3182("Error in tecTextSetTypeface: Invalid family input parameter.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_text.___2642 = family; if (isBold) outputInfo->m_text.___2643 = true; else outputInfo->m_text.___2643 = false; if (isItalic) outputInfo->m_text.___2644 = true; else outputInfo->m_text.___2644 = false; } catch (std::bad_alloc const&) { ___3182("Error in tecTextSetTypeface: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextSetLineSpacing_SZL( void*  fileHandle, double ___2285) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetLineSpacing")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetLineSpacing: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetLineSpacing.\n"); ++outputInfo->m_numErrs;
return -1; } outputInfo->m_text.___2635 = ___2285; return 0; } int32_t tecTextSetMacroFunctionCmd_SZL( void*       fileHandle, char const* macroFunctionCmd) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetMacroFunctionCmd")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetMacroFunctionCmd: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetMacroFunctionCmd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_text.___2636 = macroFunctionCmd; } catch (std::bad_alloc const&) { ___3182("Error in tecTextSetMacroFunctionCmd: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextSetScope_SZL( void*   fileHandle, int32_t ___3440) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetScope")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetScope: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetScope.\n"); ++outputInfo->m_numErrs; return -1; } if (___3440 != 0 && ___3440 != 1) { ___3183("Error in tecTextSetScope: scope = %d. Must be 0 or 1.\n", ___3440); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2639 = (Scope_e)___3440; return 0; } int32_t tecTextEnd_SZL(void* fileHandle) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextEnd")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextEnd: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextEnd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_tecioData.___16(outputInfo->m_text); outputInfo->m_text = tecioszl::Text::invalidText(); } catch (std::bad_alloc const&) { ___3182("Error in tecTextEnd: Out of memory.\n"); outputInfo->m_text = tecioszl::Text::invalidText(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecUserRecAdd_SZL( void*       fileHandle, char const*  ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecUserRecAdd")) return -1; ___3182("Error in tecUserRecAdd: User records not currently supported for subzone-load-on-demand files.\n"); ++outputInfo->m_numErrs; return -1; } int32_t tecFileWriterFlush_SZL( void*          fileHandle, int32_t        numZonesToRetain, int32_t const* zonesToRetain) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecFileWriterFlush")) return -1; return flushDataToIntermediateFiles(outputInfo, numZonesToRetain, zonesToRetain, "tecFileWriterFlush"); } int32_t tecFileWriterClose_SZL(void** fileHandle) { OutputInfo* outputInfo; if (!fileHandle || !getOutputInfo(&outputInfo, *fileHandle, "tecFileWriterClose")) return -1; int32_t ___3356 = 0; if (outputInfo->m_hasBeenFlushedToDisk) { ___3356 = flushDataToIntermediateFiles(outputInfo, 0, NULL, "tecFileWriterClose"); if (___3356 == 0) ___3356 = convertIntermediateFilesToSZLFile(outputInfo, outputInfo->___2459, true, outputInfo->___2459, "tecFileWriterClose");
if (___3356 != 0) ++outputInfo->m_numErrs; } else { ___3356 = writeAllZonesToSZLFile(outputInfo, "tecFileWriterClose"); } if (outputInfo->m_debugLevel) { ___3183("File %s closed.\n", outputInfo->___2459.c_str()); if (outputInfo->m_numErrs) { ___3182("********************************************\n"); ___3183("      %d Errors occurred on this file\n", outputInfo->m_numErrs); ___3182("********************************************\n"); } } delete outputInfo; *fileHandle = NULL; return ___3356; } int32_t  ___4002(int32_t  ___1395) { REQUIRE(0 <= ___1395 && ___1395 < ___2378); return outputInfos[___1395]->m_tecioData.___2844(); } int32_t  ___4001(int32_t  ___1395) { REQUIRE(0 <= ___1395 && ___1395 < ___2378); return outputInfos[___1395]->m_tecioData.___2841(); } namespace { int checkFile( int32_t     ___1395, char const* routineName) { if ((___1395 < 0) || (___1395 >= ___2378)) { ___3185("%s: Attempt to use invalid file %d file must be between 1 and %d inclusive.\n", routineName, ___1395+1, ___2378); return -1; } if (outputInfos.empty() || !outputInfos[___1395]) { ___3184("Error in %s: Attempt to use file %d that hasn't been initialized with TECINI.\n", routineName, ___1395+1); return -1; } return 0; } } namespace { int checkData( int32_t     ___1395, char const* routineName) { try { bool checkConnectivity = (outputInfos[___1395]->m_fileType != 2); outputInfos[___1395]->m_tecioData.___4164(checkConnectivity); } catch (std::exception const& e) { ___3184("%s: Wrong number of data values in file %d:\n", routineName, ___1395+1); ___3183("%s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } } int32_t  ___3997( int32_t          fileNum, char const*      ___4175, char const*      ___4347, char const*      ___1392, char const*      ___3445, int32_t  const*  ___1405, int32_t  const*  ___939, int32_t  const*  ___2011) { outputInfos.resize(___2378); if (*___1405 == 2 && !___1810) { ___3182("TECINI: For SZL files, you must output a grid file (FileType = 1)\nprior to outputting a solution file (FileType = 2).\n"); return -1; } if ((size_t)fileNum < outputInfos.size() && outputInfos[fileNum]) { ___3183("TECINI: Attempting to initialize file %d twice before calling TECEND.\n", fileNum + 1); ++outputInfos[fileNum]->m_numErrs; return -1; } try { outputInfos[fileNum] = boost::make_shared<OutputInfo>( ___4175, ___4347, ___1392, ___3445, *___1405, *___939, (*___2011 ? FieldDataType_Double : FieldDataType_Float), ___1810.get()); if (*___1405 == 1) { ___1810 = outputInfos[fileNum]; } if (outputInfos[fileNum]->m_debugLevel) { ___3184("Dest    File #%d: %s\n", fileNum + 1, outputInfos[fileNum]->___2459.c_str()); ___3183("NumVars=%d\n", outputInfos[fileNum]->m_tecioData.___2841()); }
 #if defined TECIOMPI
outputInfos[fileNum]->m_comm = MPI_COMM_SELF; outputInfos[fileNum]->m_communicator.reset(new MPICommunicator(MPI_COMM_SELF)); outputInfos[fileNum]->___2394.reset(new MPINonBlockingCommunicationCollection(MPI_COMM_SELF)); outputInfos[fileNum]->m_localProcess = 0; outputInfos[fileNum]->m_mainProcess = 0;
 #endif
} catch(std::exception const& e) { ___3183("TECINI: %s\n", e.what()); return -1; } return 0; } int32_t  ___4012( int32_t        ___1395, char    const* ___4688, int32_t const* ___4690, int64_t const* ___1908, int64_t const* ___2115, int64_t const* ___2160, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, double  const* ___3639, int32_t const* ___3784, int32_t const*  , int32_t const* ___2004, int32_t const* ___2801, int32_t const* ___1283, int32_t const* ___4191, int32_t const* ___2785, int32_t const* ___4187, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { if (checkFile(___1395, "TECZNE") < 0 || checkData(___1395, "TECZNE") < 0) return -1; if (*___2004 != 1) { ___3184("TECZNE: Point data is not currently allowed. " " Please use block format for file %lld, zone %lld.\n", lldfmt_t(___1395+1), lldfmt_t(outputInfos[___1395]->m_tecioData.___2844())); ++outputInfos[___1395]->m_numErrs; return -1; } try { if (outputInfos[___1395]->m_debugLevel) { ___3183("Writing Zone %d:\n", outputInfos[___1395]->m_tecioData.___2844() + 1); ___3183("      Title = %s\n", ___4688); ___3183("      Type  = %s\n", zoneTypeStrings[*___4690]); ___3183("      IMax  = %lld\n", lldfmt_t(*___1908)); ___3183("      JMax  = %lld\n", lldfmt_t(*___2115)); ___3183("      KMax  = %lld\n", lldfmt_t(*___2160)); if (___3550) { std::ostringstream ___2890; for (int i = 0; i < outputInfos[___1395]->m_tecioData.___2841(); ++i) { if (i > 0) ___2890 <<  ","; ___2890 << ___3550[i]; } ___3183("      DupList = %s\n", ___2890.str().c_str()); } } outputInfos[___1395]->m_tecioData.___19( ___4688, *___4690, *___1908, *___2115, *___2160, numSections, cellShapePerSection, gridOrderPerSection, basisFnPerSection, numElementsPerSection, *___3639, *___3784, 0, *___2801, *___1283, ___4191 ? *___4191 : 0, ___2785 ? *___2785 : 0, ___4187 ? *___4187 : 0, NULL, ___2981, ___4324, ___3550, *___3548); outputInfos[___1395]->m_numValuesWritten = 0; } catch (std::exception const& e) { ___3183("TECZNE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___3992( int32_t         ___1395, int32_t  const* N, void const*     ___1350, int32_t  const* ___2012) { if (checkFile(___1395, "TECDAT") < 0) return -1; try { outputInfos[___1395]->m_tecioData.___429((___2225)*N, ___1350, (*___2012 != 0)); if (outputInfos[___1395]->m_debugLevel && (*N > 1)) ___3184("Writing %d values to file %d.\n", *N, ___1395 + 1); if (outputInfos[___1395]->m_debugLevel > 1)
{ double* dPtr = (double*)___1350; float* fPtr = (float*)___1350; for(int32_t i = 0; i < *N; ++i) { double ___4296 = (*___2012 ? dPtr[i] : fPtr[i]); ___3184("%" PRIu64 " %G\n", ++outputInfos[___1395]->m_numValuesWritten, ___4296); } } } catch (std::exception const& e) { ___3183("TECDAT: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___3999( int32_t         ___1395, int32_t  const* ___2687) { if (checkFile(___1395, "TECNOD") < 0) return -1; ___4633 curZone = outputInfos[___1395]->m_tecioData.___2844(); Zone_s* zonePtr = outputInfos[___1395]->m_tecioData.zonePtr(curZone); if (!zonePtr->m_partitionMap.empty()) { zonePtr = zonePtr->m_partitionMap.rbegin()->second.get(); } else if (!zonePtr->m_partitionOwners.empty()) { ___3182("TECNOD: Must call TECFEPTN to create a partition before calling TECDAT or TECNOD"); return -1; } int32_t  N = (int32_t )(zonePtr->___2495->expectedValueCount()); return ___4000(___1395, &N, ___2687); } int32_t  ___4000( int32_t         ___1395, int32_t  const* N, int32_t  const* ___2687) { if (checkFile(___1395, "TECNODE") < 0) return -1; try { outputInfos[___1395]->m_tecioData.___431((___2225)*N, ___2687); if (outputInfos[___1395]->m_debugLevel && (*N > 1)) ___3184("Writing %d nodes to file %d.\n", *N, ___1395 + 1); } catch (std::exception const& e) { ___3183("TECNODE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t TECIOSZL_FLUSH( int32_t        fileNum, int32_t const* numZonesToRetain, int32_t const* zonesToRetain) { if (checkFile(fileNum, "TECFLUSH") != 0 || checkData(fileNum, "TECFLUSH") != 0) return -1; return flushDataToIntermediateFiles(outputInfos[fileNum].get(), *numZonesToRetain, zonesToRetain, "TECFLUSH"); } int32_t  ___3993(int32_t  ___1395) { if (checkFile(___1395, "TECEND") != 0 || checkData(___1395, "TECEND") != 0) return -1; int32_t ___3356 = 0; if (outputInfos[___1395]->m_hasBeenFlushedToDisk) { ___3356 = flushDataToIntermediateFiles(outputInfos[___1395].get(), 0, NULL, "TECEND"); if (___3356 == 0) ___3356 = convertIntermediateFilesToSZLFile(outputInfos[___1395].get(), outputInfos[___1395]->___2459, true, outputInfos[___1395]->___2459, "TECEND"); } else { ___3356 = writeAllZonesToSZLFile(outputInfos[___1395].get(), "TECEND"); } if (!outputInfos.empty() && outputInfos[___1395]->m_debugLevel) { ___3183("File %d closed.\n", ___1395 + 1); if (outputInfos[___1395]->m_numErrs) { ___3182("********************************************\n"); ___3183("      %d Errors occurred on this file\n", outputInfos[___1395]->m_numErrs); ___3182("********************************************\n"); } } outputInfos[___1395].reset(); return ___3356; } int32_t  ___3998( int32_t     ___1395, char const* S) { if (checkFile(___1395, "TECLAB") < 0) return -1; return tecCustomLabelsAddSet_SZL(outputInfos[___1395].get(), S); } int32_t  ___4009( int32_t     ___1395, char const*  ) { if (checkFile(___1395, "TECUSR") < 0) return -1; ___3182("TECUSR: User records not currently supported for subzone-load-on-demand files.\n");
++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___3996( int32_t         ___1395, double const*   ___4573, double const*   ___4590, double const*   ___4713, int32_t  const* ___3158, int32_t  const* ___227, int32_t  const* ___4597, int32_t  const* Color, int32_t  const* ___1410, int32_t  const* ___2021, int32_t  const* ___1650, int32_t  const* ___2262, double const*   ___2985, double const*   ___2288, int32_t  const* ___2792, int32_t  const* ___188, int32_t  const* ___176, double const*   ___187, double const*   ___171, int32_t  const* ___3441, int32_t  const* ___494, int32_t  const* ___2834, int32_t  const* ___2836, float const*    ___4567, float const*    ___4585, float const*    ___4594, char const*     mfc) { if (checkFile(___1395, "TECGEO") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3182("\nInserting Geometry\n"); try { ___2225 const maxLocalBuffLen = 1024; ___2225 localNumSegPts[maxLocalBuffLen]; ___2225 *localNumSegPtsRef = *___2834 < maxLocalBuffLen ? localNumSegPts : new ___2225[*___2834]; for (int32_t sIndex = 0; sIndex < *___2834; ++sIndex) localNumSegPtsRef[sIndex] = ___2836[sIndex]; ___372 const ___2002 = (*___227 == 0 ? ___1303 : ___4224); outputInfos[___1395]->m_tecioData.___9(*___4573, *___4590, *___4713, (CoordSys_e)(*___3158), ___2002, *___4597, (___514)*Color, (___514)*___1410, (___372)*___2021, (GeomForm_e)(*___1650), (LinePattern_e)(*___2262), *___2985, *___2288, (uint16_t)(*___2792), (ArrowheadStyle_e)(*___188), (ArrowheadAttachment_e)(*___176), *___187, *___171, (Scope_e)(*___3441), (Clipping_e)(*___494), *___2834, localNumSegPtsRef, ___4567, ___4585, ___4594, mfc); if (localNumSegPtsRef != localNumSegPts) delete [] localNumSegPtsRef; } catch(...) { ___3182("TECGEO: Out of memory or unknown error\n"); ++outputInfos[___1395]->m_numErrs; return 1; } return 0; } int32_t  ___4008( int32_t         ___1395, double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t  const* ___3158, int32_t  const* ___227, int32_t  const* ___4597, int32_t  const* ___353, int32_t  const* ___1451, double const*   ___1449, int32_t  const* ___411, double const*   ___409, double const*   ___407, int32_t  const* ___403, int32_t  const* ___405, double const*   ___57, int32_t  const* ___39, double const*   ___2286, int32_t  const* ___4079, int32_t  const* ___3441, int32_t  const* ___494, char const*     ___3811, char const*     mfc) { if (checkFile(___1395, "TECTXT") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3183("\nInserting Text: %s\n", ___3811); try { ___372 const ___2002 = (*___227 == 0 ? ___1303 : ___4224); outputInfos[___1395]->m_tecioData.___16(*___4572, *___4589, *___4711, (CoordSys_e)*___3158, ___2002, *___4597, (Font_e)*___353,
(Units_e)*___1451, *___1449, (TextBox_e)*___411, *___409, *___407, (___514)*___403, (___514)*___405, *___57, (TextAnchor_e)*___39, *___2286, (___514)*___4079, (Scope_e)*___3441, (Clipping_e)*___494, ___3811, mfc); } catch(...) { ___3182("TECTXT: Out of memory or unknown error\n"); ++outputInfos[___1395]->m_numErrs; return 1; } return 0; } void ___3995( int32_t         ___1395, int32_t  const*   ) { if (checkFile(___1395, "TECFOREIGN") < 0) return; ___3182("TECFOREIGN: Foreign byte order not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; } int32_t  ___3991( int32_t     ___1395, char const* ___2684, char const* ___4312) { if (checkFile(___1395, "TECAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting data set aux data: '%s' = '%s'\n", ___2684, ___4312); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4312, "TECAUXSTR")) return -1; outputInfos[___1395]->m_tecioData.___8(___2684, ___4312); return 0; } int32_t  ___4011( int32_t     ___1395, char const* ___2684, char const* ___4312) { if (checkFile(___1395, "TECZAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_tecioData.___2844() == 0) { ___3182("TECZAUXSTR: Must call TECZNE prior to TECZAUXSTR\n"); ++outputInfos[___1395]->m_numErrs; return -1; } if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting zone aux data: '%s' = '%s'\n", ___2684, ___4312); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4312, "TECZAUXSTR")) return -1; int32_t ___2844 = outputInfos[___1395]->m_tecioData.___2844(); outputInfos[___1395]->m_tecioData.___20(___2844, ___2684, ___4312); return 0; } int32_t  ___4010( int32_t         ___1395, int32_t  const* ___4334, char const*     ___2684, char const*     ___4312) { if (checkFile(___1395, "TECVAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting variable aux data: '%s' = '%s'\n", ___2684, ___4312); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4312, "TECVAUXSTR")) return -1; outputInfos[___1395]->m_tecioData.___18(*___4334, ___2684, ___4312); return 0; } int32_t  ___3994( int32_t         ___1395, int32_t  const* ___1256) { if (checkFile(___1395, "TECFACE") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3182("\nInserting face neighbor data\n"); Zone_s* zonePtr = outputInfos[___1395]->m_tecioData.zonePtr(outputInfos[___1395]->m_tecioData.___2844()); try { outputInfos[___1395]->m_tecioData.___430(zonePtr, ___1256); } catch (std::exception const& e) { ___3183("TECFACE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___4006(int32_t  ___1395) { ___4276(___1395); return 0; } int32_t  ___4007(int32_t  ___1395) { ___4276(___1395); return 0; } int32_t  ___4003( int32_t         ___1395, int32_t  const* ___1292, int32_t  const* ___1295,
int32_t  const* ___1257, int32_t  const* ___1301, int32_t  const* ___1251, int32_t  const* ___1252, int32_t  const* ___1254) { ___4276(___1292); ___4276(___1295); ___4276(___1257); ___4276(___1301); ___4276(___1251); ___4276(___1252); ___4276(___1254); if (checkFile(___1395, "TECPOLY") < 0) return -1; ___3182("TECPOLY: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___4005( int32_t         ___1395, int32_t  const* ___2804, int32_t  const* ___1292, int32_t  const* ___1295, int32_t  const* ___1257, int32_t  const* ___1301) { ___4276(___2804); ___4276(___1292); ___4276(___1295); ___4276(___1257); ___4276(___1301); if (checkFile(___1395, "TECPOLYFACE") < 0) return -1; ___3182("TECPOLYFACE: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___4004( int32_t         ___1395, int32_t  const* ___2776, int32_t  const* ___1251, int32_t  const* ___1252, int32_t  const* ___1254) { ___4276(___2776); ___4276(___1251); ___4276(___1252); ___4276(___1254); if (checkFile(___1395, "TECPOLYBCONN") < 0) return -1; ___476(TecplotSDKBinaryFileVersion == 191); ___3182("TECPOLYBCONN: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; }
 #if defined TECIOMPI
int32_t  TECIOSZL_MPIINIT( int32_t *       fileNum, void*           communicator, int32_t  const* mainrank) { BOOST_STATIC_ASSERT(sizeof(int) == 4); INVARIANT(mpiSizeof(MPI_INT) == 4); MPI_Comm comm;
 #if defined OPEN_MPI
MPI_Fint fComm = *(static_cast<MPI_Fint*>(communicator)); comm = MPI_Comm_f2c(fComm); if (!comm)
 #endif
comm = *(static_cast<MPI_Comm*>(communicator)); return szlMPIInit(outputInfos[*fileNum].get(), comm, *mainrank); } int32_t  TECIOSZL_ZNEMAP( int32_t         fileNum, int32_t  const* npartitions, int32_t  const* ptnworkers) { if (checkFile(fileNum, "TECZNEMAP") < 0) return -1; OutputInfo* outputInfo = outputInfos[fileNum].get(); return storeZonePartitionInfo(outputInfo, *npartitions, ptnworkers, "TECZNEMAP"); }
 #endif
namespace { int32_t validateCommonTecIOSzlPtnArgs( char const*    ptnFnName, char const*    zneFnName, int32_t        fileNum, int32_t const* ___2975, int64_t const  numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t        numGhostCells, int32_t const* ghostCells) { if (checkFile(fileNum, ptnFnName)) return -1; if (outputInfos[fileNum]->m_tecioData.___2844() == 0) { ___3185("%s: Must call %s prior to calling %s.\n", ptnFnName, zneFnName, ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } Zone_s* zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(outputInfos[fileNum]->m_tecioData.___2844()); if (!___3892(zonePtr->___2682, zonePtr->m_zoneDimension)) { ___3183("%s: Called for the wrong zone type; can be called only for 3D FE zones.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!___2975 || *___2975 < 1) { ___3183("%s: Invalid Partition input parameter.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } if (numGhostNodes > 0) { if (!ghostNodes) { ___3183("%s: Invalid GNodes input parameter.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } else if (!neighborPartitions) { ___3183("%s: Invalid GNPartitions input parameter.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } else if (!neighborPartitionNodes) { ___3183("%s: Invalid GNPNodes input parameter.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } } if (numGhostCells > 0 && !ghostCells) { ___3183("%s: Invalid GhostCells input parameter.\n", ptnFnName); ++outputInfos[fileNum]->m_numErrs; return -1; } try { int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); ___476(partitionZone > 0); zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(partitionZone);
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call TECZNEMAP prior to calling TECFEPTN or TECFEMIXEDPTN"); } else if (static_cast<size_t>(*___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to "<<ptnFnName<<": " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #else
___4276(___2975);
 #endif 
if (!zonePtr->m_partitionMap.empty() && checkData(fileNum, ptnFnName) < 0) return -1; } catch(std::exception const& e) { ___3184("%s: %s\n", ptnFnName, e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } } int32_t TECIOSZL_FEMIXEDPTN( int32_t        fileNum, int32_t const* ___2975, int64_t const* ___2819, int64_t const* numCellsPerSection, int64_t const* numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { if (!___2819 || *___2819 < 1) { ___3182("TECFEMIXEDPTN: Invalid NumNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); ___476(partitionZone > 0); Zone_s const* const zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(partitionZone); size_t const numSections = zonePtr->m_numElementsPerSection.size(); if (!numCellsPerSection || std::accumulate(numCellsPerSection,numCellsPerSection+numSections, int64_t(0)) < 1) { ___3182("TECFEMIXEDPTN: Invalid NumCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!numGhostNodes || *numGhostNodes < 0) { ___3182("TECFEMIXEDPTN: Invalid NGNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!numGhostCellsPerSection || std::accumulate(numGhostCellsPerSection,numGhostCellsPerSection+numSections, int64_t(0)) < 0) { ___3182("TECFEMIXEDPTN: Invalid NumGhostCellsPerSection input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } int64_t const numGhostCells = std::accumulate(numGhostCellsPerSection,numGhostCellsPerSection+numSections, int64_t(0)); if (validateCommonTecIOSzlPtnArgs("TECFEMIXEDPTN", "TECZNEFEMIXED", fileNum, ___2975, *numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCells, ghostCells) != 0) { return -1; } try { outputInfos[fileNum]->m_tecioData.addFEZonePartition( partitionZone, *___2975, *___2819, tecplot::___3267<int64_t const>(numCellsPerSection, numSections, numSections), tecplot::___3267<int32_t const>(ghostNodes, *numGhostNodes, *numGhostNodes), tecplot::___3267<int32_t const>(neighborPartitions, *numGhostNodes, *numGhostNodes), tecplot::___3267<int32_t const>(neighborPartitionNodes, *numGhostNodes, *numGhostNodes), tecplot::___3267<int64_t const>(numGhostCellsPerSection, numSections, numSections), tecplot::___3267<int32_t const>(ghostCells, numGhostCells, numGhostCells)); } catch(std::exception const& e) { ___3183("TEFECPTN: %s\n", e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } int32_t  TECIOSZL_FEPTN( int32_t         fileNum, int32_t  const* ___2975, int32_t  const* numnodes, int32_t  const* numcells, int32_t  const* ngnodes, int32_t  const* gnodes, int32_t  const* gnpartitions, int32_t  const* gnpnodes, int32_t  const* ngcells, int32_t  const* gcells) { if (!numnodes || *numnodes < 1) { ___3182("TECFEPTN: Invalid NumNodes input parameter.\n");
++outputInfos[fileNum]->m_numErrs; return -1; } if (!numcells || *numcells < 1) { ___3182("TECFEPTN: Invalid NumCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!ngnodes || *ngnodes < 0) { ___3182("TECFEPTN: Invalid NGNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!ngcells || *ngcells < 0) { ___3182("TECFEPTN: Invalid NGCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (validateCommonTecIOSzlPtnArgs("TECFEPTN", "TECZNE", fileNum, ___2975, *ngnodes, gnodes, gnpartitions, gnpnodes, *ngcells, gcells) != 0) { return -1; } try { int32_t const numSections = 1; int64_t const numCellsPerSection = *numcells; int64_t const numGhostCellsPerSection = *ngcells; int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); outputInfos[fileNum]->m_tecioData.addFEZonePartition( partitionZone, *___2975, *numnodes, tecplot::___3267<int64_t const>(&numCellsPerSection, numSections, numSections), tecplot::___3267<int32_t const>(gnodes, *ngnodes, *ngnodes), tecplot::___3267<int32_t const>(gnpartitions, *ngnodes, *ngnodes), tecplot::___3267<int32_t const>(gnpnodes, *ngnodes, *ngnodes), tecplot::___3267<int64_t const>(&numGhostCellsPerSection, numSections, numSections), tecplot::___3267<int32_t const>(gcells, *ngcells, *ngcells)); } catch(std::exception const& e) { ___3183("TEFECPTN: %s\n", e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } namespace { bool checkParameter(int32_t  const* parameter, char const* parameterName, int32_t  minValue, int32_t  maxValue) { if (!parameter || *parameter < minValue || *parameter > maxValue) { ___3183("TECIJKPTN: Invalid %s input parameter.\n", parameterName); return false; } else { return true; } } } int32_t  TECIOSZL_IJKPTN( int32_t         fileNum, int32_t  const* ___2975, int32_t  const* imin, int32_t  const* jmin, int32_t  const* kmin, int32_t  const* imax, int32_t  const* jmax, int32_t  const* kmax) { if (checkFile(fileNum, "TECIJKPTN")) return -1; if (outputInfos[fileNum]->m_tecioData.___2844() == 0) { ___3182("TECIJKPTN: Must call TECZNE prior to calling TECIJKPTN.\n"); ++outputInfos[fileNum]->m_numErrs; return 1; } Zone_s* zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(outputInfos[fileNum]->m_tecioData.___2844()); if (!supportedOrderedVolumeZoneType(zonePtr->___2682, zonePtr->m_zoneDimension)) { ___3182("TECIJKPTN: Called for the wrong zone type; can be called only for 3D FE zones.\n"); ++outputInfos[fileNum]->m_numErrs; return 1; } if (!___2975 || *___2975 < 1) { ___3182("TECIJKPTN: Invalid Partition input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!checkParameter(imin, "imin", 1,     static_cast<int32_t>(zonePtr->___2680.i()))) return -1; if (!checkParameter(jmin, "jmin", 1,     static_cast<int32_t>(zonePtr->___2680.___2103()))) return -1; if (!checkParameter(kmin, "kmin", 1,     static_cast<int32_t>(zonePtr->___2680.___2132()))) return -1; if (!checkParameter(imax, "imax", *imin, static_cast<int32_t>(zonePtr->___2680.i())))
return -1; if (!checkParameter(jmax, "jmax", *jmin, static_cast<int32_t>(zonePtr->___2680.___2103()))) return -1; if (!checkParameter(kmax, "kmax", *kmin, static_cast<int32_t>(zonePtr->___2680.___2132()))) return -1; try { int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); ___476(partitionZone > 0); zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(partitionZone);
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call TECZNEMAP prior to calling TECIJKPTN"); } else if (static_cast<size_t>(*___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to TECIJKPTN: " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #else
___4276(___2975);
 #endif 
if (!zonePtr->m_partitionMap.empty() && checkData(fileNum, "TECIJKPTN") < 0) return -1; outputInfos[fileNum]->m_tecioData.addIJKZonePartition( partitionZone, *___2975, *imin, *jmin, *kmin, *imax, *jmax, *kmax); } catch (std::exception const& e) { ___3183("TECIJKPTN: %s\n", e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } int32_t tecioszl_convertrawdata(char const* ___1392) {
 #if defined TECIOMPI
MPIFileReader inputFile(___1392, MPI_COMM_WORLD);
 #else
FileStreamReader inputFile(___1392);
 #endif
if (!inputFile.open()) return 1; ___476(inputFile.___2039()); char asciiFileIndicator[3]; bool readASCII = false; inputFile.fread(asciiFileIndicator, 1, 3); if (asciiFileIndicator[0] == 'T') readASCII = true; int ___2674 = 0; int numRanks = 1;
 #if defined TECIOMPI
MPI_Comm_rank(MPI_COMM_WORLD, &___2674); MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
 #endif
___1391 requiredNumRanks; readScalar(inputFile, requiredNumRanks, readASCII); if (static_cast<___1391>(numRanks) != requiredNumRanks) { std::ostringstream ___2890; ___2890 << "Converting file " << inputFile.___1392() << " requires " << requiredNumRanks << " MPI ranks."; if (___2674 == 0) std::cerr << ___2890.str() << std::endl; throw std::runtime_error(___2890.str()); } ___1391 sizeOfFileLoc = readASCII ? 2 + ___199<___1391, false>::size : sizeof(___1391); ___1391 fileLocLoc = 3 + (___2674 + 1) * sizeOfFileLoc; inputFile.___3457(fileLocLoc); ___1391 fileLoc; readScalar(inputFile, fileLoc, readASCII); inputFile.___3457(fileLoc); ___3968 tecioData(inputFile, readASCII); ___4014 ___4013(tecioData); bool const ___4477 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
uint32_t const fileVersion = ___1386::surveyZonesForFileVersion( ___4013, ___3499(0)); ___1386 ___1385( fileVersion, ___4477, ___843, DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setCodeRevision(1); DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> szpltFile; boost::shared_ptr<DataSetWriter> dataSetWriter; std::string outputFileName(___1392); size_t suffixLocation = outputFileName.rfind(".szplt"); if (suffixLocation == std::string::npos) outputFileName += ".szplt"; else outputFileName.erase(suffixLocation + 6);
 #if defined TECIOMPI
szpltFile.reset(new MPIFileWriter(outputFileName.c_str(), MPI_COMM_WORLD, MPI_INFO_NULL)); dataSetWriter = boost::make_shared<DataSetWriterMPI>( &___4013, ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754(), static_cast<MPI_Comm>(MPI_COMM_WORLD), 0, ___2674);
 #else
szpltFile.reset(new FileStreamWriter(outputFileName.c_str())); dataSetWriter = boost::make_shared<DataSetWriter>( &___4013, ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754());
 #endif
if (!szpltFile->open(false)) { std::cerr << "Unable to open file " << outputFileName << " for writing" << std::endl; return -1; } else { szpltFile->___3492(___1385.___2000()); szpltFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (___2674 != 0) { if (___4013.___894()) { ___1390 szpltZoneHeaderFileLocs; if (!szpltZoneHeaderFileLocs.alloc(___4013.___889()) || !dataSetWriter->writeDataSet(*szpltFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs)) { std::cerr << "Error writing file" << std::endl; return -1; } } } else {
 #endif
if (!___1240( ___4013, *szpltFile, ___1385, includeRevisionNumber(), *dataSetWriter, ___3499(0), ___3499(0), ___933)) { std::cerr << "Error writing file" << std::endl; return -1; }
 #if defined TECIOMPI
}
 #endif
} szpltFile->close(true); return 0; } namespace { template <typename T> bool allocVector(std::vector<T>& vec, size_t count, T value) { try { vec.assign(count, value); return true; } catch (std::bad_alloc const&) { return false; } } struct TecioSzlDataReaderCache { FileStreamReader szpltFile; ___1386  ___1385; ___4349       ___2841; ___4633      ___2844; std::string      dataSetTitle; ___4704  ___4703; ___1390     ___4626; ___2238<ZoneMetadata> zoneMetadata; std::vector<std::pair<std::string, std::string> > dataSetAuxData; std::vector<std::vector<std::pair<std::string, std::string> > > varAuxData; std::vector<std::vector<std::pair<std::string, std::string> > > zoneAuxData; CustomLabelsArray customLabelsArray; GeomArray geomArray; TextArray textArray; ___2238<uint8_t> zoneHeaderIsRead; ___2238<___2238<char> > zonePartitionHeaderIsRead; TecioSzlDataReaderCache(char const* ___1392) : szpltFile(___1392) {} bool allocateArrays() { if (___2841 > 0 && ___2844 > 0) return ___4626.alloc(___2844) && zoneMetadata.alloc(___2844) && zoneHeaderIsRead.alloc((uint64_t)___2844, (uint8_t)0) && zonePartitionHeaderIsRead.alloc((uint64_t)___2844); return true; } }; } int32_t tecioSZL_CustomLabelsGetNumSets(void* fileHandle, int32_t* numSets) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(numSets)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *numSets = static_cast<int32_t>(szlDataReaderCache->customLabelsArray.size()); return 0; } namespace { bool duplicateString(char const* source, char** target) { REQUIRE(VALID_REF(source)); REQUIRE(VALID_REF(target) && *target == NULL); try { *target = new char[strlen(source) + 1]; strcpy(*target, source); return true; } catch (std::bad_alloc const&) { std::cerr << "Error: Out of memory while duplicating string." << std::endl; return false; } } } int32_t tecioSZL_CustomLabelsGetSet(void* fileHandle, int32_t ___4450, char** labelSet) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4450 && ___4450 <= static_cast<int32_t>(szlDataReaderCache->customLabelsArray.size())); REQUIRE(VALID_REF(labelSet) && *labelSet == NULL); std::ostringstream ___2890; CustomLabelSet const& customLabelSet = szlDataReaderCache->customLabelsArray[___4450 - 1]; for (uint32_t i = 0; i < customLabelSet.m_numLabels - 1; ++i) ___2890 <<'"' << customLabelSet.m_labels[i] << "\", "; ___2890 << '"' << customLabelSet.m_labels[customLabelSet.m_numLabels - 1] << '"'; if (!duplicateString(___2890.str().c_str(), labelSet)) return -1; return 0; } namespace { int32_t duplicateAuxDataItem(std::pair<std::string, std::string> const& auxData, char** ___2683, char** value) { REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(value) && *value == NULL);
int32_t ___3356 = 0; if (!duplicateString(auxData.first.c_str(), ___2683)) { ___3356 = -1; } else if (!duplicateString(auxData.second.c_str(), value)) { delete[] *___2683; *___2683 = NULL; ___3356 = -1; } ENSURE(___3356 == 0 || ___3356 == -1); ENSURE(EQUIVALENCE(___3356 == 0, VALID_REF(*___2683))); ENSURE(EQUIVALENCE(___3356 == 0, VALID_REF(*value))); return ___3356; } } int32_t tecioSZL_DataSetAuxDataGetItem(void* fileHandle, int32_t whichItem, char** ___2683, char** value) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->dataSetAuxData.size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(value) && *value == NULL); return duplicateAuxDataItem(szlDataReaderCache->dataSetAuxData[whichItem - 1], ___2683, value); } int32_t tecioSZL_DataSetAuxDataGetNumItems(void* fileHandle, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2810)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2810 = static_cast<int32_t>(szlDataReaderCache->dataSetAuxData.size()); return 0; } int32_t tecioSZL_DataSetGetNumVars(void* fileHandle, int32_t* ___2841) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2841)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2841 = static_cast<int32_t>(szlDataReaderCache->___2841); return 0; } int32_t tecioSZL_DataSetGetNumZones(void* fileHandle, int32_t* ___2844) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2844)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2844 = static_cast<int32_t>(szlDataReaderCache->___2844); return 0; } int32_t tecioSZL_DataSetGetTitle(void* fileHandle, char** ___4175) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___4175) && *___4175 == NULL); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); if (!duplicateString(szlDataReaderCache->dataSetTitle.c_str(), ___4175)) return -1; return 0; } int32_t tecioSZL_FileGetType(void* fileHandle, int32_t* ___1405) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___1405)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___1405 = static_cast<int32_t>(szlDataReaderCache->___1385.___842()); return 0; } int32_t tecioSZL_FileReaderClose(void** fileHandle) { TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(*fileHandle); int32_t returnCode = 0; if (!szlDataReaderCache->szpltFile.close(true)) returnCode = -1; delete szlDataReaderCache; *fileHandle = NULL; return returnCode; } namespace { bool readAndCategorizeAuxData(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942)
{ REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t auxDataCount = 0; AuxDataArray auxDataArray; szlDataReaderCache->varAuxData.resize(szlDataReaderCache->___2841); szlDataReaderCache->zoneAuxData.resize(szlDataReaderCache->___2844); bool ___3356 = (readAuxDataCount(szlDataReaderCache->szpltFile, ___3942, auxDataCount) == ___4224); if (auxDataCount > 0) { ___3356 = ___3356 && (auxDataArray.alloc(static_cast<uint64_t>(auxDataCount)) == ___4224) && (readAuxData(szlDataReaderCache->szpltFile, ___3942, 0, 0, 0, auxDataArray) == ___4224); } for (uint32_t i = 0; i < auxDataCount; ++i) { switch (auxDataArray[i].m_location) { case ___253: szlDataReaderCache->dataSetAuxData.push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; case ___258: szlDataReaderCache->varAuxData[auxDataArray[i].m_entity - 1].push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; case ___259: szlDataReaderCache->zoneAuxData[auxDataArray[i].m_entity - 1].push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; default: ___476(___1303); break; } } return ___3356; } bool readAndStoreCustomLabels(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t customLabelsCount = 0; bool ___3356 = (readCustomLabelsCount(szlDataReaderCache->szpltFile, ___3942, customLabelsCount) == ___4224); if (customLabelsCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->customLabelsArray.alloc(static_cast<uint64_t>(customLabelsCount)) == ___4224) && readCustomLabels(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->customLabelsArray); } return ___3356; } bool readAndStoreGeoms(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t geomCount = 0; bool ___3356 = (readGeometriesCount(szlDataReaderCache->szpltFile, ___3942, geomCount) == ___4224); if (geomCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->geomArray.alloc(static_cast<uint64_t>(geomCount)) == ___4224) && readGeometries(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->geomArray); } return ___3356; } bool readAndStoreTexts(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t textCount = 0; bool ___3356 = (readTextsCount(szlDataReaderCache->szpltFile, ___3942, textCount) == ___4224); if (textCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->textArray.alloc(static_cast<uint64_t>(textCount)) == ___4224) && readTexts(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->textArray); } return ___3356; } } TecioSZLFileOpenResult_e tecioSZL_FileReaderOpen(char const* ___1392, void** fileHandle) { REQUIRE(VALID_REF(___1392) && strlen(___1392) > 0); REQUIRE(VALID_REF(fileHandle) && *fileHandle == NULL); TecioSZLFileOpenResult_e returnCode = TecioSZLFileOpenResult_OK;
TecioSzlDataReaderCache* szlDataReaderCache = NULL; try { szlDataReaderCache = new TecioSzlDataReaderCache(___1392); if (!szlDataReaderCache->szpltFile.open()) { returnCode = TecioSZLFileOpenResult_ErrorOpeningFile; } else { uint64_t byteOrderIndicator; uint64_t dataSetHeaderLocation; ___3943 ___3942; if (!readDataFileHeader(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, byteOrderIndicator, dataSetHeaderLocation) || !szlDataReaderCache->szpltFile.___3457(dataSetHeaderLocation) || !readDataSetHeaderTags(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, ___3942) || !applyDataSetHeaderScalarTagValues(___3942, szlDataReaderCache->___2841, szlDataReaderCache->___2844) || !szlDataReaderCache->allocateArrays() || !readDataSetHeader(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, ___3942, szlDataReaderCache->dataSetTitle, szlDataReaderCache->___4703, szlDataReaderCache->___4626) || !readAndCategorizeAuxData(szlDataReaderCache, ___3942) || !readAndStoreCustomLabels(szlDataReaderCache, ___3942) || !readAndStoreGeoms(szlDataReaderCache, ___3942) || !readAndStoreTexts(szlDataReaderCache, ___3942)) { returnCode = TecioSZLFileOpenResult_BadFormat; } else { for (___4633 zone = 0; zone < szlDataReaderCache->___2844; ++zone) storeZoneMetadata(szlDataReaderCache->___4703, zone, 0, szlDataReaderCache->zoneMetadata[zone]); } } } catch (std::bad_alloc const&) { returnCode = TecioSZLFileOpenResult_OutOfMemory; } if (returnCode == 0) *fileHandle = reinterpret_cast<void*>(szlDataReaderCache); else delete szlDataReaderCache; ENSURE(VALID_ENUM(returnCode, TecioSZLFileOpenResult_e)); ENSURE(EQUIVALENCE(returnCode == TecioSZLFileOpenResult_OK, VALID_REF(*fileHandle))); return returnCode; } int32_t tecioSZL_GeomArrowheadGetAngle(void* fileHandle, int32_t ___1553, double* ___56) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___56)); *___56 = szlDataReaderCache->geomArray[___1553 - 1].___2338; return 0; } int32_t tecioSZL_GeomArrowheadGetAttach(void* fileHandle, int32_t ___1553, int32_t* attachment) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(attachment)); *attachment = szlDataReaderCache->geomArray[___1553 - 1].___2339; return 0; } int32_t tecioSZL_GeomArrowheadGetSize(void* fileHandle, int32_t ___1553, double* arrowheadSize) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size()));
REQUIRE(VALID_REF(arrowheadSize)); *arrowheadSize = szlDataReaderCache->geomArray[___1553 - 1].___2340; return 0; } int32_t tecioSZL_GeomArrowheadGetStyle(void* fileHandle, int32_t ___1553, int32_t* arrowheadStyle) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(arrowheadStyle)); *arrowheadStyle = szlDataReaderCache->geomArray[___1553 - 1].___2341; return 0; } int32_t tecioSZL_GeomCircleGetRadius(void* fileHandle, int32_t ___1553, double* radius) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(radius)); *radius = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); return 0; } int32_t tecioSZL_GeomEllipseGetNumPoints(void* fileHandle, int32_t ___1553, int32_t* numEllipsePoints) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(numEllipsePoints)); *numEllipsePoints = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2500); return 0; } int32_t tecioSZL_GeomEllipseGetSize(void* fileHandle, int32_t ___1553, double* horizontalAxis, double* verticalAxis) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(horizontalAxis)); REQUIRE(VALID_REF(verticalAxis)); *horizontalAxis = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); *verticalAxis = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].___4580(); return 0; } int32_t tecioSZL_GeomGetAnchorPos(void* fileHandle, int32_t ___1553, double* x, double* ___4580, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4580)); REQUIRE(VALID_REF(z)); *x = szlDataReaderCache->geomArray[___1553 - 1].___2615[0]; *___4580 = szlDataReaderCache->geomArray[___1553 - 1].___2615[1]; *z = szlDataReaderCache->geomArray[___1553 - 1].___2615[2]; return 0; } int32_t tecioSZL_GeomGetClipping(void* fileHandle, int32_t ___1553, int32_t* ___493) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size()));
REQUIRE(VALID_REF(___493)); *___493 = szlDataReaderCache->geomArray[___1553 - 1].___2392; return 0; } int32_t tecioSZL_GeomGetColor(void* fileHandle, int32_t ___1553, int32_t* color) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(color)); *color = szlDataReaderCache->geomArray[___1553 - 1].___2393; return 0; } int32_t tecioSZL_GeomGetCoordMode(void* fileHandle, int32_t ___1553, int32_t* coordMode) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(coordMode)); *coordMode = szlDataReaderCache->geomArray[___1553 - 1].___2614; return 0; } int32_t tecioSZL_GeomGetFillColor(void* fileHandle, int32_t ___1553, int32_t* ___1409) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___1409)); *___1409 = szlDataReaderCache->geomArray[___1553 - 1].___2460; return 0; } int32_t tecioSZL_GeomGetLinePattern(void* fileHandle, int32_t ___1553, int32_t* ___2261) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2261)); *___2261 = szlDataReaderCache->geomArray[___1553 - 1].___2487; return 0; } int32_t tecioSZL_GeomGetLineThickness(void* fileHandle, int32_t ___1553, double* ___2287) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2287)); *___2287 = szlDataReaderCache->geomArray[___1553 - 1].___2488; return 0; } int32_t tecioSZL_GeomGetMacroFunctionCmd(void* fileHandle, int32_t ___1553, char** macroFunctionCmd) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(macroFunctionCmd) && *macroFunctionCmd == NULL); if (!duplicateString(szlDataReaderCache->geomArray[___1553 - 1].___2489.c_str(), macroFunctionCmd)) return -1; return 0; } int32_t tecioSZL_GeomGetNumGeoms(void* fileHandle, int32_t* numGeoms) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(numGeoms)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle);
*numGeoms = static_cast<int32_t>(szlDataReaderCache->geomArray.size()); return 0; } int32_t tecioSZL_GeomGetPatternLength(void* fileHandle, int32_t ___1553, double* ___2984) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2984)); *___2984 = szlDataReaderCache->geomArray[___1553 - 1].___2613; return 0; } int32_t tecioSZL_GeomGetScope(void* fileHandle, int32_t ___1553, int32_t* ___3440) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___3440)); *___3440 = szlDataReaderCache->geomArray[___1553 - 1].___2617; return 0; } int32_t tecioSZL_GeomGetType(void* fileHandle, int32_t ___1553, int32_t* type) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(type)); *type = szlDataReaderCache->geomArray[___1553 - 1].___2464; return 0; } int32_t tecioSZL_GeomGetZone(void* fileHandle, int32_t ___1553, int32_t* zone) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(zone)); *zone = szlDataReaderCache->geomArray[___1553 - 1].___2675; return 0; } int32_t tecioSZL_GeomIsAttached(void* fileHandle, int32_t ___1553, int32_t* ___2002) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2002)); *___2002 = szlDataReaderCache->geomArray[___1553 - 1].___2482; return 0; } int32_t tecioSZL_GeomIsFilled(void* fileHandle, int32_t ___1553, int32_t* ___2020) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2020)); *___2020 = szlDataReaderCache->geomArray[___1553 - 1].___2484; return 0; } int32_t tecioSZL_GeomLineGetPoint(void* fileHandle, int32_t ___1553, int32_t segment, int32_t index, double* x, double* ___4580, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(0 < segment && segment <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size()));
REQUIRE(0 < index && index <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1].size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4580)); REQUIRE(VALID_REF(z)); *x = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].x()); *___4580 = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].___4580()); *z = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].z()); return 0; } int32_t tecioSZL_GeomLineGetSegmentCount(void* fileHandle, int32_t ___1553, int32_t* segmentCount) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(segmentCount)); *segmentCount = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size()); return 0; } int32_t tecioSZL_GeomLineSegmentGetPointCount(void* fileHandle, int32_t ___1553, int32_t segment, int32_t* pointCount) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(0 < segment && segment <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size())); REQUIRE(VALID_REF(pointCount)); *pointCount = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1].size()); return 0; } int32_t tecioSZL_GeomRectangleGetSize(void* fileHandle, int32_t ___1553, double* ___4455, double* ___1824) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___4455)); REQUIRE(VALID_REF(___1824)); *___4455 = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); *___1824 = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].___4580(); return 0; } int32_t tecioSZL_GeomSquareGetSize(void* fileHandle, int32_t ___1553, double* size) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(szlDataReaderCache->geomArray[___1553 - 1].___2464 == GeomType_Square); REQUIRE(VALID_REF(size)); *size = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); return 0; } int32_t tecioSZL_TextBoxGetColor(void* fileHandle, int32_t ___4040, int32_t* ___402) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___402));
*___402 = szlDataReaderCache->textArray[___4040 - 1].___2626; return 0; } int32_t tecioSZL_TextBoxGetFillColor(void* fileHandle, int32_t ___4040, int32_t* ___404) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___404)); *___404 = szlDataReaderCache->textArray[___4040 - 1].___2627; return 0; } int32_t tecioSZL_TextBoxGetLineThickness(void* fileHandle, int32_t ___4040, double* ___406) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___406)); *___406 = szlDataReaderCache->textArray[___4040 - 1].___2628; return 0; } int32_t tecioSZL_TextBoxGetMargin(void* fileHandle, int32_t ___4040, double* ___408) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___408)); *___408 = szlDataReaderCache->textArray[___4040 - 1].___2629; return 0; } int32_t tecioSZL_TextBoxGetType(void* fileHandle, int32_t ___4040, int32_t* ___410) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___410)); *___410 = szlDataReaderCache->textArray[___4040 - 1].___2630; return 0; } int32_t tecioSZL_TextGetAnchor(void* fileHandle, int32_t ___4040, int32_t* ___38) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___38)); *___38 = szlDataReaderCache->textArray[___4040 - 1].___2623; return 0; } int32_t tecioSZL_TextGetAnchorPos(void* fileHandle, int32_t ___4040, double* x, double* ___4580, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4580)); REQUIRE(VALID_REF(z)); *x = szlDataReaderCache->textArray[___4040 - 1].___2624[0]; *___4580 = szlDataReaderCache->textArray[___4040 - 1].___2624[1]; *z = szlDataReaderCache->textArray[___4040 - 1].___2624[2]; return 0; } int32_t tecioSZL_TextGetAngle(void* fileHandle, int32_t ___4040, double* ___56) { REQUIRE(VALID_REF(fileHandle));
TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___56)); *___56 = szlDataReaderCache->textArray[___4040 - 1].___2625; return 0; } int32_t tecioSZL_TextGetClipping(void* fileHandle, int32_t ___4040, int32_t* ___493) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___493)); *___493 = szlDataReaderCache->textArray[___4040 - 1].___2631; return 0; } int32_t tecioSZL_TextGetColor(void* fileHandle, int32_t ___4040, int32_t* color) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(color)); *color = szlDataReaderCache->textArray[___4040 - 1].___2632; return 0; } int32_t tecioSZL_TextGetCoordMode(void* fileHandle, int32_t ___4040, int32_t* coordMode) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(coordMode)); *coordMode = szlDataReaderCache->textArray[___4040 - 1].___2637; return 0; } int32_t tecioSZL_TextGetHeight(void* fileHandle, int32_t ___4040, double* ___1824) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___1824)); *___1824 = szlDataReaderCache->textArray[___4040 - 1].___2633; return 0; } int32_t tecioSZL_TextGetLineSpacing(void* fileHandle, int32_t ___4040, double* ___2285) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___2285)); *___2285 = szlDataReaderCache->textArray[___4040 - 1].___2635; return 0; } int32_t tecioSZL_TextGetMacroFunctionCmd(void* fileHandle, int32_t ___4040, char** macroFunctionCmd) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(macroFunctionCmd) && *macroFunctionCmd == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2636.c_str(), macroFunctionCmd)) return 0; return -1; } int32_t tecioSZL_TextGetScope(void* fileHandle, int32_t ___4040, int32_t* ___3440)
{ REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___3440)); *___3440 = static_cast<int32_t>(szlDataReaderCache->textArray[___4040 - 1].___2639); return 0; } int32_t tecioSZL_TextGetNumTexts(void* fileHandle, int32_t* numTexts) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(VALID_REF(numTexts)); *numTexts = static_cast<int32_t>(szlDataReaderCache->textArray.size()); return 0; } int32_t tecioSZL_TextGetSizeUnits(void* fileHandle, int32_t ___4040, int32_t* sizeUnits) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(sizeUnits)); *sizeUnits = szlDataReaderCache->textArray[___4040 - 1].___2640; return 0; } int32_t tecioSZL_TextGetString(void* fileHandle, int32_t ___4040, char** str) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(str) && *str == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2641.c_str(), str)) return 0; return 1; } int32_t tecioSZL_TextGetTypeface(void* fileHandle, int32_t ___4040, char** typeface) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(typeface) && *typeface == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2642.c_str(), typeface)) return 0; return 1; } int32_t tecioSZL_TextGetZone(void* fileHandle, int32_t ___4040, int32_t* zone) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(zone)); *zone = static_cast<int32_t>(szlDataReaderCache->textArray[___4040 - 1].___2645); return 0; } int32_t tecioSZL_TextIsAttached(void* fileHandle, int32_t ___4040, int32_t* ___2002) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___2002)); *___2002 = (szlDataReaderCache->textArray[___4040 - 1].___2634 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_TextIsBold(void* fileHandle, int32_t ___4040, int32_t* isBold)
{ REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(isBold)); *isBold = (szlDataReaderCache->textArray[___4040 - 1].___2643 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_TextIsItalic(void* fileHandle, int32_t ___4040, int32_t* isItalic) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(isItalic)); *isItalic = (szlDataReaderCache->textArray[___4040 - 1].___2644 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_VarAuxDataGetItem(void* fileHandle, int32_t ___4333, int32_t whichItem, char** ___2683, char** value) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4333 && ___4333 <= szlDataReaderCache->___2841); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->varAuxData[___4333 - 1].size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(value) && *value == NULL); return duplicateAuxDataItem(szlDataReaderCache->varAuxData[___4333 - 1][whichItem - 1], ___2683, value); } int32_t tecioSZL_VarAuxDataGetNumItems(void* fileHandle, int32_t ___4333, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4333 && ___4333 <= szlDataReaderCache->___2841); REQUIRE(VALID_REF(___2810)); *___2810 = static_cast<int32_t>(szlDataReaderCache->varAuxData[___4333 - 1].size()); return 0; } int32_t tecioSZL_VarGetName(void* fileHandle, int32_t ___4333, char** ___2683) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4333 && ___4333 <= szlDataReaderCache->___2841); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); return (duplicateString(szlDataReaderCache->___4703.m_varNames[___4333 - 1].c_str(), ___2683) ? 0 : -1); } int32_t tecioSZL_VarIsEnabled(void*  , int32_t /*___4333*/, int32_t* isEnabled) { *isEnabled = 1; return 0; } int32_t tecioSZL_ZoneAuxDataGetItem(void* fileHandle, int32_t zone, int32_t whichItem, char** ___2683, char** value) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < zone && zone <= szlDataReaderCache->___2844); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->zoneAuxData[zone - 1].size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(value) && *value == NULL); return duplicateAuxDataItem(szlDataReaderCache->zoneAuxData[zone - 1][whichItem - 1], ___2683, value);
} int32_t tecioSZL_ZoneAuxDataGetNumItems(void* fileHandle, int32_t zone, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2810)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2810 = static_cast<int32_t>(szlDataReaderCache->zoneAuxData[zone - 1].size()); return 0; } int32_t tecioSZL_ZoneConnectivityGetSharedZone(void* fileHandle, int32_t zone, int32_t* sharedZone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(sharedZone)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *sharedZone = static_cast<int32_t>(szlDataReaderCache->___4703.m_zoneShareConnectivityWithZone[zone - 1] + 1); return 0; } namespace { bool readZoneHeaderIfNecessary(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone >= 0); bool ___3356 = true; if (!szlDataReaderCache->zoneHeaderIsRead[zone]) { ___3943 ___3942; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->___4626[zone]) || !readZoneHeaders(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, 0  , zone, 0  , szlDataReaderCache->___2841, szlDataReaderCache->___4703.m_vzMinMaxes, szlDataReaderCache->___4703.m_vzFieldDataTypes, szlDataReaderCache->zoneMetadata[zone])) { std::cerr << "File seek/read error while reading zone header." << std::endl; ___3356 = false; } else { szlDataReaderCache->zoneHeaderIsRead[zone] = 1; if (szlDataReaderCache->zoneMetadata[zone].isSZL()) ___3356 = szlDataReaderCache->zonePartitionHeaderIsRead[zone].alloc((uint64_t)szlDataReaderCache->zoneMetadata[zone].getNumPartitions(), (uint8_t)0); if (!___3356) std::cerr << "Out of memory while reading zone header." << std::endl; } } return ___3356; } bool readZonePartitionHeaderIfNecessary(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, ItemAddress64::___2978 ___2975) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone >= 0); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone); if (___3356 && szlDataReaderCache->zoneMetadata[zone].getNumPartitions() > 1 && !szlDataReaderCache->zonePartitionHeaderIsRead[zone][___2975]) { ZoneMetadata& zoneMetadata = szlDataReaderCache->zoneMetadata[zone]; if (!szlDataReaderCache->szpltFile.___3457(zoneMetadata.m_ptnHeaderFileLocs[___2975]) || !readPartitionHeader(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, szlDataReaderCache->___2841, 0, zone, ___2975, zoneMetadata, szlDataReaderCache->___4703.m_vzFieldDataTypes, zoneMetadata.m_ptnMetadata[___2975])) { std::cerr << "File seek/read error while reading partition header." << std::endl; ___3356 = false; } else { szlDataReaderCache->zonePartitionHeaderIsRead[zone][___2975] = 1; } } return ___3356; } int32_t incrementIndex(uint64_t& currentIndex, uint64_t numValues) {
if (currentIndex < numValues - 1) { ++currentIndex; return 0; } else { std::cerr << "Wrong number of face neighbor values detected." << std::endl; return -1; } } } int32_t tecioSZL_ZoneFaceNbrGetConnections(void* fileHandle, int32_t zone, int32_t* connections) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(connections)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); int32_t ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1) ? 0 : -1; if (___3356 == 0 && szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661 != ___330) { uint64_t tempNumValues; ___1963 ___4297; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, tempNumValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; ___3356 = -1; } else { FaceNeighborMode_e const ___2502 = szlDataReaderCache->zoneMetadata[zone - 1].getFaceNeighborMode(); bool const isOneToMany = (___2502 == ___1287 || ___2502 == ___1284); bool const isGlobal = (___2502 == ___1285 || ___2502 == ___1284); uint64_t currentIndex = 0; while (___3356 == 0 && currentIndex < tempNumValues) { int32_t numNeighbors = 1; connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); if (___3356 == 0) { connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); } if (___3356 == 0 && isOneToMany) { connections[currentIndex] = ___4297[currentIndex]; ___3356 = incrementIndex(currentIndex, tempNumValues); if (___3356 == 0) { numNeighbors = ___4297[currentIndex]; connections[currentIndex] = numNeighbors; ___3356 = incrementIndex(currentIndex, tempNumValues); } } for (int32_t i = 0; ___3356 == 0 && i < numNeighbors; ++i) { if (isGlobal) { connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); } if (___3356 == 0) { connections[currentIndex] = ___4297[currentIndex] + 1; if (i == numNeighbors - 1) ++currentIndex; else ___3356 = incrementIndex(currentIndex, tempNumValues); } } } } } return ___3356; } int32_t tecioSZL_ZoneFaceNbrGetConnections64(void* fileHandle, int32_t zone, int64_t* connections) { ___4276(fileHandle); ___4276(zone); ___4276(connections); ___476(!"Not implemented."); return 1; } int32_t tecioSZL_ZoneFaceNbrGetMode(void* fileHandle, int32_t zone, int32_t* ___2502) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2502)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2502 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getFaceNeighborMode()); return 0; } namespace { template <typename T>
bool countFaceConnections(int64_t numFaceValues, ___2238<T> const& faceValues, int32_t ___2502, int64_t* numConnections) { REQUIRE(numFaceValues >= 0); REQUIRE(VALID_REF(numConnections)); int64_t index = 0; T nz; while (index < numFaceValues) { ++(*numConnections); switch (___2502) { case 0: index += 3; break; case 1: nz = faceValues[index + 3]; if (nz <= 0) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Invalid # face neighbors for connection " << *numConnections << ")." << std::endl; *numConnections = 0; return false; } index += (nz + 4); break; case 2: index += 4; break; case 3: nz = faceValues[index + 3]; if (nz <= 0) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Invalid # face neighbors for connection " << *numConnections << ")." << std::endl; *numConnections = 0; return false; } index += (2 * nz + 4); break; default: std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (invalid face neighbor mode)." << std::endl; return false; } if (index > numFaceValues) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Array bound violation while parsing face neighbors)." << std::endl; return false; } } return true; } } int32_t tecioSZL_ZoneFaceNbrGetNumConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(numConnections)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); *numConnections = 0; bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); if (___3356 && szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() != ___4693 && szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661 != ___330) { int32_t are64Bit; int32_t ___2502 = 0; ___3356 = (tecioSZL_ZoneFaceNbrsAre64Bit(fileHandle, zone, &are64Bit) == 0) && (tecioSZL_ZoneFaceNbrGetMode(fileHandle, zone, &___2502) == 0); if (___3356) { if (are64Bit) { ___3356 = false; } else { uint64_t numValues; ___2238<int32_t> ___4297; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, numValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; return 0; } else { ___3356 = countFaceConnections(numValues, ___4297, ___2502, numConnections); } } } } ENSURE(IMPLICATION(___3356, *numConnections >= 0)); return ___3356 ? 0 : -1; } int32_t tecioSZL_ZoneFaceNbrGetNumValues(void* fileHandle, int32_t zone, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(numValues)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); *numValues = 0; uint64_t tempNumValues; ___1963 ___4297; bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1);
if (___3356 && szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() != ___4693 && szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661 != ___330) { if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, tempNumValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; ___3356 = false; } else { ___476(tempNumValues < static_cast<uint64_t>(std::numeric_limits<int64_t>::max())); *numValues = static_cast<int64_t>(tempNumValues); } } ENSURE(IMPLICATION(___3356, *numValues >= 0)); return ___3356 ? 0 : -1; } int32_t tecioSZL_ZoneFaceNbrsAre64Bit(void* fileHandle, int32_t zone, int32_t* are64Bit) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(are64Bit)); ___4276(fileHandle); ___4276(zone); *are64Bit = 0; return 0; } int32_t tecioSZL_ZoneGetIJK(void* fileHandle, int32_t zone, int64_t* iMax, int64_t* jMax, int64_t* kMax) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(iMax)); REQUIRE(VALID_REF(jMax)); REQUIRE(VALID_REF(kMax)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); ___1842 ___1841 = szlDataReaderCache->zoneMetadata[zone - 1].getZoneIJK(); *iMax = static_cast<int64_t>(___1841.i()); *jMax = static_cast<int64_t>(___1841.___2103()); *kMax = static_cast<int64_t>(___1841.___2132()); return 0; } int32_t tecioSZL_ZoneGetParentZone(void* fileHandle, int32_t zone, int32_t* ___2972) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2972)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2972 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getParentZone() + 1); return 0; } int32_t tecioSZL_ZoneGetSolutionTime(void* fileHandle, int32_t zone, double* ___3638) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___3638)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___3638 = szlDataReaderCache->zoneMetadata[zone - 1].getSolutionTime(); return 0; } int32_t tecioSZL_ZoneGetStrandID(void* fileHandle, int32_t zone, int32_t* ___3783) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___3783)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___3783 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getStrandID()); return 0; } int32_t tecioSZL_ZoneGetTitle(void* fileHandle, int32_t zone, char** ___4175) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___4175)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); if (!duplicateString(szlDataReaderCache->zoneMetadata[zone - 1].getName().c_str(), ___4175))
return -1; return 0; } int32_t tecioSZL_ZoneGetType(void* fileHandle, int32_t zone, int32_t* type) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(type)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); boost::unordered_map<ZoneType_e, int32_t> tecioZoneTypes = boost::assign::map_list_of<ZoneType_e, int32_t> (___4701, 0) (___4699, 2) (___4697, 3) (___4698, 4) (___4692, 5) (___4693, 1) (___4695, 6) (___4696, 7) (ZoneType_FEMixed, 8); *type = tecioZoneTypes[szlDataReaderCache->zoneMetadata[zone - 1].getZoneType()]; return 0; } int32_t tecioSZL_ZoneGetNumSections(void* fileHandle, int32_t zone, int32_t* numSections) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(numSections)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *numSections = szlDataReaderCache->zoneMetadata[zone - 1].numSections(); return 0; } int32_t tecioSZL_ZoneGetSectionMetrics( void* fileHandle, int32_t  zone, int32_t  section, int32_t* cellShape, int32_t* gridOrder, int32_t* basisFunction, int64_t* numElemsInSection, int32_t* numNodesPerCell) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(section > 0); REQUIRE(VALID_REF(cellShape)); REQUIRE(VALID_REF(gridOrder)); REQUIRE(VALID_REF(basisFunction)); REQUIRE(VALID_REF(numElemsInSection)); REQUIRE(VALID_REF(numNodesPerCell)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *cellShape = szlDataReaderCache->zoneMetadata[zone - 1].cellShape(section - 1); *gridOrder = szlDataReaderCache->zoneMetadata[zone - 1].gridOrder(section - 1); *basisFunction = szlDataReaderCache->zoneMetadata[zone - 1].cellBasisFunc(section - 1); *numElemsInSection = szlDataReaderCache->zoneMetadata[zone - 1].numElems(section - 1); *numNodesPerCell = szlDataReaderCache->zoneMetadata[zone - 1].getNumNodesPerCell(section - 1); return 0; } int32_t tecioSZL_ZoneIsEnabled(void* fileHandle, int32_t zone, int32_t* isEnabled) { ___4276(fileHandle); ___4276(zone); *isEnabled = 1; return 0; } namespace { uint64_t getNumValuesInSubzone(TecioSzlDataReaderCache const* szlDataReaderCache, ValueLocation_e ___4323, int32_t zone, ItemAddress64::___2978 ___2975, ItemAddress64::SubzoneOffset_t ___3878) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(VALID_ENUM(___4323, ValueLocation_e)); REQUIRE(zone >= 0); uint64_t ___3356; if (szlDataReaderCache->zoneMetadata[zone].getZoneType() == ___4701) { if (___4323 == ___4327) ___3356 = szlDataReaderCache->zoneMetadata[zone].m_ijkZoneInfos[___2975].getNumNodesInNsz(___3878); else ___3356 = szlDataReaderCache->zoneMetadata[zone].m_ijkZoneInfos[___2975].getNumCellsInCsz(___3878); } else { uint64_t const valuesPerSubzone = static_cast<uint64_t>(szlDataReaderCache->___1385.___1754());
uint64_t numSubzones = 0; uint64_t numValues = 0; if (___4323 == ___4327) { numSubzones = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].getNumNszsInPartition(___2975)); numValues = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].m_ptnNumNodes[___2975]); } else { numSubzones = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].getNumCszsInPartition(___2975)); for (ItemAddress64::SectionOffset_t section = 0; section < szlDataReaderCache->zoneMetadata[zone].numSections(); ++section) numValues += static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].m_secPtnNumCells[section][___2975]); } if (___3878 < numSubzones - 1) ___3356 = valuesPerSubzone; else ___3356 = numValues - (numSubzones - 1) * valuesPerSubzone; } return ___3356; } void getSectionPartionOffset( ZoneMetadata const&             zoneMetadata, int64_t                         ___447, ItemAddress64::___2978&     ___2975, ItemAddress64::SectionOffset_t& section, uint64_t&                       cellOffset) { if (zoneMetadata.getZoneDimension() == 3) { ItemAddress64::___2978 const numPartitions = zoneMetadata.getNumPartitions(); ___463 cumulativeNumCells{0}; for (section = 0; section < zoneMetadata.numSections(); ++section) { bool foundLocation = false; for (___2975 = 0; ___2975 < numPartitions; ++___2975) { cumulativeNumCells += zoneMetadata.m_secPtnNumCells[section][___2975]; foundLocation = ___447 < cumulativeNumCells; if (foundLocation) break; } if (foundLocation) break; } ___476(___2975 < numPartitions && section < zoneMetadata.numSections()); cellOffset = ___447 - (cumulativeNumCells - zoneMetadata.m_secPtnNumCells[section][___2975]); } else { ___2975 = 0; ___463 cumulativeNumCells{0}; for (section = 0; section < zoneMetadata.numSections(); ++section) { bool foundLocation = false; cumulativeNumCells += zoneMetadata.numElems(section); foundLocation = ___447 < cumulativeNumCells; if (foundLocation) break; } ___476(section < zoneMetadata.numSections()); cellOffset = ___447 - (cumulativeNumCells - zoneMetadata.numElems(section)); } } void getPartitionSubzoneAndOffset( TecioSzlDataReaderCache const*  szlDataReaderCache, ValueLocation_e                 ___4323, int32_t                         zone, int64_t                         index, ItemAddress64::___2978&     ___2975, ItemAddress64::SectionOffset_t& section, ItemAddress64::SubzoneOffset_t& ___3878, uint64_t&                       itemOffset) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(VALID_ENUM(___4323, ValueLocation_e)); REQUIRE(zone >= 0); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone]; ItemAddress64::___2978 const numPartitions = zoneMetadata.getNumPartitions(); ___2975 = 0; section = 0; ItemAddress64::SubzoneOffset_t numSubzones = 0; if (___4323 == ___4327) { for (___2975 = 0; ___2975 < numPartitions; ++___2975) if (index < zoneMetadata.m_ptnFirstNode[___2975] + zoneMetadata.m_ptnNumNodes[___2975])
break; ___476(___2975 < numPartitions); section = 0; itemOffset = static_cast<uint64_t>(index - zoneMetadata.m_ptnFirstNode[___2975]); numSubzones = zoneMetadata.m_ptnNumNszs[___2975]; } else { getSectionPartionOffset(zoneMetadata, index, ___2975, section, itemOffset); numSubzones = zoneMetadata.m_secPtnNumCszs[section][___2975]; } ___476(numSubzones > 0); for (___3878 = 0; ___3878 < numSubzones; ++___3878) { uint64_t const valuesInSubzone = getNumValuesInSubzone(szlDataReaderCache, ___4323, zone, ___2975, ___3878); if (valuesInSubzone >= itemOffset) return; itemOffset -= valuesInSubzone; } ___476(___1303); } int64_t getNumNodeMapValues( TecioSzlDataReaderCache const*  szlDataReaderCache, int32_t                         zone, int64_t                         startCell, int64_t                         ___2779) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone >= 0); ZoneMetadata const&              zoneMetadata  = szlDataReaderCache->zoneMetadata[zone]; ItemAddress64::___2978 const numPartitions = zoneMetadata.getNumPartitions(); ItemAddress64::___2978     startPartition = 0; ItemAddress64::SectionOffset_t startSection   = 0; uint64_t firstSectionCellOffset; getSectionPartionOffset(zoneMetadata, startCell, startPartition, startSection, firstSectionCellOffset); ___463 endCell = startCell + ___2779; ___463 cumulativeNumCells = 0; int64_t     numValues{0}; for (ItemAddress64::SectionOffset_t section{startSection}; section < zoneMetadata.numSections(); ++section) { bool foundLocation = false; for (ItemAddress64::___2978 ___2975{startPartition}; ___2975 < numPartitions; ++___2975) { ___463 numElemsPerSectPart = zoneMetadata.getZoneDimension() == 3 ? zoneMetadata.m_secPtnNumCells[section][___2975] : zoneMetadata.numElems(section); ___463 endSectionCell = numElemsPerSectPart + cumulativeNumCells; if (endCell < endSectionCell) { numValues += (endCell - cumulativeNumCells - firstSectionCellOffset) * zoneMetadata.getNumNodesPerCell(section); foundLocation = ___4224; } else { numValues += (numElemsPerSectPart - firstSectionCellOffset) * zoneMetadata.getNumNodesPerCell(section); cumulativeNumCells += numElemsPerSectPart - firstSectionCellOffset; foundLocation = ___1303; } firstSectionCellOffset = 0; if (foundLocation) break; } startPartition = 0; if (foundLocation) break; } return numValues; } } int32_t tecioSZL_ZoneNodeMapGet(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int32_t* ___2721) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(startCell > 0); REQUIRE(___2779 > 0); REQUIRE(VALID_REF(___2721)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); ZoneType_e const ___4689 = szlDataReaderCache->zoneMetadata[zone - 1].getZoneType(); ___476(___4689 != ___4701); bool const ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); if (___3356)
{ if (___4689 == ___4693 || ___4689 == ___4699 || ___4689 == ___4697 || (___4689 == ZoneType_FEMixed && szlDataReaderCache->zoneMetadata[zone - 1].getZoneDimension() < 3)) { uint64_t const sizeOfHeader = arraySizeInFile<int32_t, false  >(0, ___2000); uint64_t const bytesPerNumber = arrayValueSizeInFile<int32_t, false  >(___2000); uint64_t const valuesToSkip = getNumNodeMapValues(szlDataReaderCache, zone - 1, 0, startCell - 1); uint64_t const fileLoc = szlDataReaderCache->zoneMetadata[zone - 1].m_nonSzZoneFileLocations.___2496 + NonSzFEZoneConnectivityWriter::nodeMapHeaderSizeInFile(___2000) + sizeOfHeader + valuesToSkip * bytesPerNumber; uint64_t const valuesToRead = getNumNodeMapValues(szlDataReaderCache, zone - 1, startCell - 1, ___2779); ___3356 = szlDataReaderCache->szpltFile.___3457(fileLoc) && readValues<int32_t, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, ___2721, IODescription()); if (___3356) { for (uint64_t i = 0; i < valuesToRead; ++i) ++___2721[i]; } } else { ___476(___4689 == ___4698 || ___4689 == ___4692 || ___4689 == ZoneType_FEMixed); uint64_t const sizeOfHeader = SZLFEZoneWriter::cszConnectivityHeaderFileSize(___2000); uint64_t nodeMapIndex = 0; ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ItemAddress64::___2978     startingPartition; ItemAddress64::SectionOffset_t startingSection; ItemAddress64::SubzoneOffset_t startingSubzone; uint64_t                       startingItemOffset; getPartitionSubzoneAndOffset( szlDataReaderCache, ___4325, zone - 1, startCell - 1, startingPartition, startingSection, startingSubzone, startingItemOffset); uint64_t valuesToRead = getNumNodeMapValues( szlDataReaderCache, zone - 1, startCell - 1, ___2779); for (ItemAddress64::SectionOffset_t section = startingSection; ___3356 && nodeMapIndex < valuesToRead && section < szlDataReaderCache->zoneMetadata[zone - 1].numSections(); ++section) { uint64_t const nodesPerCell = static_cast<uint64_t>(zoneMetadata.getNumNodesPerCell(section)); for (ItemAddress64::___2978 ___2975 = startingPartition; ___3356 && nodeMapIndex < valuesToRead && ___2975 < zoneMetadata.getNumPartitions(); ++___2975) { ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); PartitionMetadata const& partitionMetadata = zoneMetadata.m_ptnMetadata[___2975]; for (ItemAddress64::SubzoneOffset_t ___3878 = startingSubzone; ___3356 && nodeMapIndex < valuesToRead && ___3878 < zoneMetadata.getNumCszsInPartitionSection(___2975, section); ++___3878) { CszConnectivity cszConnectivity; ___3356 = szlDataReaderCache->szpltFile.___3457( partitionMetadata.m_secCszConnectivityFileLocs[section][___3878] + sizeOfHeader) && readCszConnectivity( szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, zoneMetadata, ___2975, section, ___3878, cszConnectivity); for (CszConnectivity::EntryIndex_t entry = static_cast<CszConnectivity::EntryIndex_t>(
nodesPerCell * startingItemOffset); ___3356 && nodeMapIndex < valuesToRead && entry < static_cast<CszConnectivity::EntryIndex_t>( cszConnectivity.getNumEntries()); ++entry) { ItemAddress64 const nodeAddress = cszConnectivity.getNodeAddress(entry); int64_t             nodeNumber  = nodeAddress.itemOffset(); if (nodeAddress.___2975()) nodeNumber += zoneMetadata.m_ptnFirstNode[nodeAddress.___2975()]; if (nodeAddress.subzoneOffset()) nodeNumber += nodeAddress.subzoneOffset() * szlDataReaderCache->___1385.___1754(); ___2721[nodeMapIndex] = static_cast<int32_t>(nodeNumber + 1); ++nodeMapIndex; } startingItemOffset = 0; } startingSubzone = 0; } startingPartition = 0; } } } return (___3356 ? 0 : -1); } int32_t tecioSZL_ZoneNodeMapGet64(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int64_t* ___2721) { ___4276(fileHandle); ___4276(zone); ___4276(startCell); ___4276(___2779); ___4276(___2721); ___476(!"Not implemented."); return 1; } int32_t tecioSZL_ZoneNodeMapIs64Bit(void* fileHandle, int32_t zone, int32_t* is64Bit) { ___4276(fileHandle); ___4276(zone); ___4276(is64Bit); ___476(!"Not implemented."); return 1; } namespace { int64_t skipCCGhostCells(___1842 const &cellIJKSize, ___1842 &cellIJKLocation) { int64_t numValuesToSkip = 0; if (cellIJKSize.i() > 1) { cellIJKLocation.setI(0); if (cellIJKLocation.___2103() < cellIJKSize.___2103() - 1) { cellIJKLocation.setJ(cellIJKLocation.___2103() + 1); numValuesToSkip = 1; } else { cellIJKLocation.setJ(0); cellIJKLocation.___3495(cellIJKLocation.___2132() + 1); if (cellIJKSize.___2103() > 1) { numValuesToSkip = cellIJKSize.i() + 2; } else { numValuesToSkip = 1; } } } else if (cellIJKSize.___2103() > 1) { cellIJKLocation.setJ(0); cellIJKLocation.___3495(cellIJKLocation.___2132() + 1); numValuesToSkip = 1; } return numValuesToSkip; } template <typename T> bool readSZLOrderedZoneVarValues( TecioSzlDataReaderCache* szlDataReaderCache, int32_t                  zone, int32_t                  ___4333, int64_t                  startIndex, int64_t                  numValues, T*                       values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e const ___4323 = static_cast<ValueLocation_e>(szlDataReaderCache->___4703.m_vzValueLocations[___4333 - 1][zone - 1]); ___1842 ___4629 = zoneMetadata.getZoneIJK(); if (___4323 == ___4325) ___4629 = (___4629 - 1).maxOp(1); ___1842 minIJK = ___4629.ijkAtOffset(startIndex - 1); ___1842 maxIJK = ___4629.ijkAtOffset(startIndex + numValues - 2); if (maxIJK.___2132() > minIJK.___2132()) { minIJK.setI(0); maxIJK.setI(___4629.i()); minIJK.setJ(0); maxIJK.setJ(___4629.___2103()); } else if (maxIJK.___2103() > minIJK.___2103()) { minIJK.setI(0); maxIJK.setI(___4629.i()); } bool ___3356 = true; int64_t remainingValues = numValues; try { auto enclosingPartitions = zoneMetadata.getPartitionsForIJKRange(minIJK, maxIJK); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224);
uint64_t const sizeOfEachSzHeader = arraySizeInFile<T, false   >(0, ___2000) + SZLOrderedZoneWriter::fieldDataSubzoneHeaderFileSize(___2000); uint64_t const bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); boost::scoped_array<T> subzoneValues(new T[szlDataReaderCache->___1385.___1755().blockSize()]); for (auto ___2975 : enclosingPartitions) { if (!___3356 || remainingValues == 0) break; ItemAddress64::SubzoneOffset_t numSubzones = 0; if (___4323 == ___4325) numSubzones = zoneMetadata.getNumCszsInPartitionSection(___2975, 0 ); else numSubzones = zoneMetadata.getNumNszsInPartition(___2975); ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); ___1842 partitionMinIJK(0, 0, 0); if (zoneMetadata.getNumPartitions() > 1) partitionMinIJK = zoneMetadata.m_ptnNodeMinIJKs[___2975]; uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4333 - 1] + sizeOfEachSzHeader; for (ItemAddress64::SubzoneOffset_t ___3878 = 0; ___3356 && remainingValues > 0 && ___3878 < numSubzones; ++___3878) { ___1842 subzoneIJKStart; ___1842 subzoneIJKEnd; if (___4323 == ___4325) { subzoneIJKStart = zoneMetadata.m_ijkZoneInfos[___2975].___688(___3878) + partitionMinIJK; subzoneIJKEnd = zoneMetadata.m_ijkZoneInfos[___2975].___687(___3878) + partitionMinIJK; } else { subzoneIJKStart = zoneMetadata.m_ijkZoneInfos[___2975].___2759(___3878) + partitionMinIJK; subzoneIJKEnd = zoneMetadata.m_ijkZoneInfos[___2975].___2758(___3878) + partitionMinIJK; } ___1842 const subzoneIJKDim(subzoneIJKEnd - subzoneIJKStart + 1); int64_t const subzoneNumValues = subzoneIJKDim.blockSize(); int64_t const subzoneFirstIndex = ___4629.offsetAtIJK(subzoneIJKStart); int64_t const subzoneLastIndex = ___4629.offsetAtIJK(subzoneIJKEnd); if (subzoneLastIndex >= startIndex - 1 && subzoneFirstIndex < startIndex + numValues - 1) { if (szlDataReaderCache->szpltFile.___3457(fileLoc) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, subzoneNumValues, subzoneValues.get(), IODescription())) { for (ItemAddress64::ItemOffset_t ___2083 = 0; ___2083 < subzoneNumValues; ++___2083) { int64_t const itemIndex = ___4629.offsetAtIJK(subzoneIJKStart + subzoneIJKDim.ijkAtOffset(___2083)); if (startIndex - 1 <= itemIndex && itemIndex < startIndex + numValues - 1) { values[itemIndex - startIndex + 1] = subzoneValues[___2083]; --remainingValues; } } } else { ___3356 = false; std::cerr << "Error reading value array." << std::endl; } } fileLoc += subzoneNumValues * bytesPerNumber + sizeOfEachSzHeader; } } } catch (std::bad_alloc const&) { std::cerr << "Out of memory reading value array." << std::endl; ___3356 = false; } ENSURE(IMPLICATION(___3356, remainingValues == 0)); return ___3356; } template <typename T> bool readSZLFEZoneVarValues( TecioSzlDataReaderCache* szlDataReaderCache, int32_t                  zone, int32_t                  ___4333, int64_t                  startIndex, int64_t                  numValues,
T*                       values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e ___4323 = static_cast<ValueLocation_e>(szlDataReaderCache->___4703.m_vzValueLocations[___4333 - 1][zone - 1]); ItemAddress64::___2978 ___2975; ItemAddress64::SectionOffset_t section; ItemAddress64::SubzoneOffset_t startingSubzone; uint64_t itemOffset; getPartitionSubzoneAndOffset(szlDataReaderCache, ___4323, zone - 1, startIndex - 1, ___2975, section, startingSubzone, itemOffset); uint64_t destIndex = 0; uint64_t remainingValues = static_cast<uint64_t>(numValues); uint64_t valuesToSkip; if (___4323 == ___4327) valuesToSkip = startIndex - zoneMetadata.m_ptnFirstNode[___2975] - 1; else valuesToSkip = startIndex - zoneMetadata.m_secPtnFirstCell[section][___2975] - 1; bool ___3356 = true; while (___3356 && remainingValues > 0) { ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); if (___3356) { if (___2000) { uint64_t const sizeOfEachSzHeader = arraySizeInFile<T, false  >(0, ___2000) + SZLFEZoneWriter::fieldDataSubzoneHeaderFileSize(___2000); uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4333 - 1] + (startingSubzone + 1) * sizeOfEachSzHeader + valuesToSkip * bytesPerNumber; ItemAddress64::SubzoneOffset_t const numSubzones = ___4323 == ___4327 ? zoneMetadata.getNumNszsInPartition(___2975) : zoneMetadata.getNumCszsInPartition(___2975); for (ItemAddress64::SubzoneOffset_t ___3878 = startingSubzone; ___3356 && remainingValues > 0 && ___3878 < numSubzones; ++___3878) { uint64_t const valuesInSubzone = getNumValuesInSubzone(szlDataReaderCache, ___4323, zone - 1, ___2975, ___3878); uint64_t const valuesToRead = std::min(remainingValues, valuesInSubzone - itemOffset); ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &values[destIndex], IODescription()); destIndex += valuesToRead; remainingValues -= valuesToRead; fileLoc = szlDataReaderCache->szpltFile.fileLoc() + sizeOfEachSzHeader; itemOffset = 0; } } else { uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4333 - 1] + valuesToSkip * bytesPerNumber; uint64_t valuesToRead; if (___4323 == ___4327) { valuesToRead = std::min(remainingValues, zoneMetadata.m_ptnNumNodes[___2975] - valuesToSkip); } else { uint64_t valuesInPartition{0}; for (section = 0; section < zoneMetadata.numSections(); ++section) { valuesInPartition += zoneMetadata.m_secPtnNumCells[section][___2975]; } valuesToRead = std::min(remainingValues, valuesInPartition - valuesToSkip);
} ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &values[destIndex], IODescription()); destIndex += valuesToRead; remainingValues -= valuesToRead; } } ++___2975; valuesToSkip = 0; } return ___3356; } template <typename T> bool readNonSzZoneVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4333, int64_t startIndex, bool ___3356, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e ___4323 = static_cast<ValueLocation_e>(szlDataReaderCache->___4703.m_vzValueLocations[___4333 - 1][zone - 1]); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); if (___4323 == ___4327 || zoneMetadata.getZoneType() != ___4701) { uint64_t const fileLoc = zoneMetadata.m_nonSzZoneFileLocations.___2671[___4333 - 1] + NonSzZoneVariableWriter::varHeaderSizeInFile(___2000) + arraySizeInFile<T, false  >(0 /* ___2795 */, ___2000) + (startIndex - 1) * bytesPerNumber; ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, static_cast<uint64_t>(numValues), values, IODescription()); } else { ___1842 const nodeIJKSize = zoneMetadata.getZoneIJK(); ___1842 const cellIJKSize = (nodeIJKSize - 1).maxOp(1); ___1842 cellIJKLocation = cellIJKSize.ijkAtOffset(static_cast<___81>(startIndex - 1)); int64_t const adjustedStartingIndex = static_cast<int64_t>(nodeIJKSize.offsetAtIJK(cellIJKLocation)); uint64_t fileLoc = zoneMetadata.m_nonSzZoneFileLocations.___2671[___4333 - 1] + NonSzZoneVariableWriter::varHeaderSizeInFile(___2000) + arraySizeInFile<T, false  >(0 /* ___2795 */, ___2000) + adjustedStartingIndex * bytesPerNumber; uint64_t destIndex = 0; uint64_t remainingNumValues = static_cast<uint64_t>(numValues); while (___3356 && remainingNumValues > 0) { uint64_t valuesToRead; if (cellIJKSize.i() > 1) valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.i() - cellIJKLocation.i())); else if (cellIJKSize.___2103() > 1) valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.___2103() - cellIJKLocation.___2103())); else valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.___2132() - cellIJKLocation.___2132())); ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &(values[destIndex]), IODescription()); remainingNumValues -= valuesToRead; destIndex += valuesToRead; uint64_t numValuesToSkip; numValuesToSkip = skipCCGhostCells(cellIJKSize, cellIJKLocation); ASSERT_ONLY(if (numValuesToSkip == 0) ___476(remainingNumValues == 0);)
fileLoc = szlDataReaderCache->szpltFile.fileLoc() + bytesPerNumber * numValuesToSkip; } } return ___3356; } template <typename T> bool readVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); if (___3356) { if (szlDataReaderCache->zoneMetadata[zone - 1].isSZL()) { if (szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() == ___4701) ___3356 = readSZLOrderedZoneVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values); else ___3356 = readSZLFEZoneVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values); } else { ___3356 = readNonSzZoneVarValues(szlDataReaderCache, zone, ___4333, startIndex, ___3356, numValues, values); } } return ___3356; } } int32_t tecioSZL_ZoneVarGetDoubleValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, double* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetFloatValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, float* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetInt16Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, int16_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetInt32Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, int32_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetSharedZone(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* sharedZone)
{ REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(VALID_REF(sharedZone)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *sharedZone = static_cast<int32_t>(szlDataReaderCache->___4703.m_vzShareVarWithZone[___4333 - 1][zone - 1] + 1); return 0; } int32_t tecioSZL_ZoneVarGetType(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* type) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(VALID_REF(type)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *type = static_cast<int32_t>(szlDataReaderCache->___4703.m_vzFieldDataTypes[___4333 - 1][zone - 1]); return 0; } int32_t tecioSZL_ZoneVarGetUInt8Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, uint8_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4333, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetValueLocation(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* location) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(VALID_REF(location)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *location = static_cast<int32_t>(szlDataReaderCache->___4703.m_vzValueLocations[___4333 - 1][zone - 1]); return 0; } int32_t tecioSZL_ZoneVarIsPassive(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* isPassive) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(VALID_REF(isPassive)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *isPassive = static_cast<int32_t>(szlDataReaderCache->___4703.m_vzIsPassive[___4333 - 1][zone - 1]); return 0; } }}
