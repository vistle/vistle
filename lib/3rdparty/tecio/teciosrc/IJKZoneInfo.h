 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <vector>
#include <boost/unordered_map.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJKSubzoneInfo.h"
#include "MinMax.h"
namespace tecplot { namespace ___3931 { class ___1879 { public: typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, std::vector<___2477> > NszMinMaxMap; static const ___1842 ijkCornerOffset[NUM_IJK_CELL_CORNERS]; static const ___1842 ijkFaceNeighborOffset[NUM_IJK_CELL_FACES]; private: IJKSubzoneInfo m_cszInfo; IJKSubzoneInfo m_nszInfo;
 #if !defined NO_ASSERTS
ItemAddress64::___2978 m_partition;
 #endif
bool m_includeIMaxNodesInSubzones; bool m_includeJMaxNodesInSubzones; bool m_includeKMaxNodesInSubzones; NszMinMaxMap m_nszMinMaxes; mutable std::vector<ItemAddress64::SubzoneOffset_t> m_subzoneOffsetsAtNodeIndices; public: ___1879( ___1842 const& ___2712, ___1842 const& subzoneMaxIJKDim, ItemAddress64::___2978 ___2975 = ItemAddress64::UNKNOWN_PARTITION, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES, bool includeIMaxNodesInSubzones = true, bool includeJMaxNodesInSubzones = true, bool includeKMaxNodesInSubzones = true) : m_cszInfo( ___2712.getCellIJK(), subzoneMaxIJKDim, ___2975, minimizeNumSubzones ) , m_nszInfo(___1842(includeIMaxNodesInSubzones ? ___2712.i() : ___2712.i() - 1, includeJMaxNodesInSubzones ? ___2712.___2103() : ___2712.___2103() - 1, includeKMaxNodesInSubzones ? ___2712.___2132() : ___2712.___2132() - 1), subzoneMaxIJKDim, ___2975, minimizeNumSubzones)
 #if !defined NO_ASSERTS
, m_partition(___2975)
 #endif
, m_includeIMaxNodesInSubzones(includeIMaxNodesInSubzones) , m_includeJMaxNodesInSubzones(includeJMaxNodesInSubzones) , m_includeKMaxNodesInSubzones(includeKMaxNodesInSubzones) { ___4276(___2975); REQUIRE(___2712>0); REQUIRE(subzoneMaxIJKDim>0); ItemAddress64::SubzoneOffset_t initialValue = ItemAddress64::INVALID_SUBZONE_OFFSET; m_subzoneOffsetsAtNodeIndices.resize(___1766(), initialValue); } ___1879() {} ___1879( ItemAddress64::___2978 ___2975, IJKSubzoneInfo const& nodeSubzoneInfo, IJKSubzoneInfo const& cellSubzoneInfo) : m_cszInfo(cellSubzoneInfo) , m_nszInfo(nodeSubzoneInfo)
 #if !defined NO_ASSERTS
, m_partition(___2975)
 #endif
, m_includeIMaxNodesInSubzones(true) , m_includeJMaxNodesInSubzones(true) , m_includeKMaxNodesInSubzones(true) { ___4276(___2975); } ~___1879() {} inline void swap(___1879& ___2886) { using std::swap; swap(m_cszInfo, ___2886.m_cszInfo); swap(m_nszInfo, ___2886.m_nszInfo);
 #if !defined NO_ASSERTS
swap(m_partition, ___2886.m_partition);
 #endif
swap(m_includeIMaxNodesInSubzones, ___2886.m_includeIMaxNodesInSubzones); swap(m_includeJMaxNodesInSubzones, ___2886.m_includeJMaxNodesInSubzones); swap(m_includeKMaxNodesInSubzones, ___2886.m_includeKMaxNodesInSubzones); swap(m_nszMinMaxes, ___2886.m_nszMinMaxes); swap(m_subzoneOffsetsAtNodeIndices, ___2886.m_subzoneOffsetsAtNodeIndices); } inline void reset( ___1842 const& ___2712, ___1842 const& subzoneMaxIJKDim, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES, bool includeIMaxNodesInSubzones = true, bool includeJMaxNodesInSubzones = true, bool includeKMaxNodesInSubzones = true) { REQUIRE(___2712>0); REQUIRE(subzoneMaxIJKDim>0); m_cszInfo.reset( ___2712.getCellIJK(), subzoneMaxIJKDim, minimizeNumSubzones ); m_nszInfo.reset( ___2712, subzoneMaxIJKDim, minimizeNumSubzones ); m_includeIMaxNodesInSubzones = includeIMaxNodesInSubzones; m_includeJMaxNodesInSubzones = includeJMaxNodesInSubzones; m_includeKMaxNodesInSubzones = includeKMaxNodesInSubzones; } inline bool ___2065() const { return m_cszInfo.___2065() && m_nszInfo.___2065(); } inline bool validCszAddress(ItemAddress64::SubzoneAddress const& cszAddress) const { return m_cszInfo.validSzAddress(cszAddress); } inline bool validNszAddress(ItemAddress64::SubzoneAddress const& nszAddress) const { return m_nszInfo.validSzAddress(nszAddress); } inline bool validCellSubzone(ItemAddress64::SubzoneOffset_t ___467) const { return m_cszInfo.validSubzone(___467); } inline bool validNodeSubzone(ItemAddress64::SubzoneOffset_t ___2732) const { return m_nszInfo.validSubzone(___2732); } inline bool validCellAddress(ItemAddress64 const& ___449) const { return validCszAddress(___449.subzoneAddress()) && ___449.itemOffset() < getNumCellsInCsz(___449.subzoneOffset()); } inline bool validNodeAddress(ItemAddress64 const& nodeAddress) const { return validNszAddress(nodeAddress.subzoneAddress()) && nodeAddress.itemOffset() < getNumNodesInNsz(nodeAddress.subzoneOffset()); } bool includeIMaxNodesInSubzones() const { return m_includeIMaxNodesInSubzones; } bool includeJMaxNodesInSubzones() const { return m_includeJMaxNodesInSubzones; } bool includeKMaxNodesInSubzones() const { return m_includeKMaxNodesInSubzones; } inline ___463 ___1764(void) const { return ___463(m_cszInfo.getNumItems()); } inline ___2716 ___1766(void) const { return ___2716(m_nszInfo.getNumItems()); } inline ___1842 const ___2893() const { return ___1842(m_cszInfo.ijkDim().i() + 1, m_cszInfo.ijkDim().___2103() + 1, m_cszInfo.ijkDim().___2132()); } inline ___1842 const& contiguousCellIJKDim() const { return m_cszInfo.ijkDim(); } inline ___1842 const& ___2712() const { return m_nszInfo.ijkDim(); } inline ___1842 const& ___2196() const { return m_cszInfo.ijkLastIndex(); } inline ___1842 const& ___2197() const { return m_nszInfo.ijkLastIndex(); } inline ___1842 ___688(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(___467 < getNumCszs()); return m_cszInfo.subzoneIJKStart(___467); }
inline ___1842 ___687(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(___467 < getNumCszs()); return m_cszInfo.subzoneIJKEnd(___467); } inline ___1842 ___2759(ItemAddress64::SubzoneOffset_t ___2732) const { REQUIRE(___2732 < getNumNszs()); return m_nszInfo.subzoneIJKStart(___2732); } inline ___1842 ___2758(ItemAddress64::SubzoneOffset_t ___2732) const { REQUIRE(___2732 < getNumNszs()); return m_nszInfo.subzoneIJKEnd(___2732); } inline void nszIJKStartAndEnd( ItemAddress64::SubzoneOffset_t ___2732, ___1842& ___1878, ___1842& ___1850) const { REQUIRE(___2732 < getNumNszs()); m_nszInfo.subzoneIJKStartAndEnd(___2732, ___1878, ___1850); } static ItemAddress64::SubzoneOffset_t calcNumCszs( ___1842 const& zoneIJKDim, ___1842 const& subzoneMaxIJK, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKDim>0 && zoneIJKDim.getNumPaddedCells()<=MAX_NUM_CELLS); REQUIRE(subzoneMaxIJK>0 && subzoneMaxIJK.blockSize()<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t const ___2781 = IJKSubzoneInfo::calcNumSubzones(zoneIJKDim.getCellIJK(), subzoneMaxIJK, minimizeNumSubzones); ENSURE(___2781>0 && ___2781 <= zoneIJKDim.getNumContiguousCells()); return ___2781; } static ItemAddress64::SubzoneOffset_t calcNumNszs( ___1842 const& zoneIJKDim, ___1842 const& subzoneMaxIJK, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKDim>0 && zoneIJKDim.blockSize()<=MAX_NUM_NODES); REQUIRE(subzoneMaxIJK>0 && subzoneMaxIJK.blockSize()<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t const ___2821 = IJKSubzoneInfo::calcNumSubzones(zoneIJKDim, subzoneMaxIJK, minimizeNumSubzones); ENSURE(___2821>0 && ___2821 <= zoneIJKDim.blockSize()); return ___2821; } inline ItemAddress64::SubzoneOffset_t getNumCszs(void) const { return m_cszInfo.getNumSzs(); } inline ItemAddress64::ItemOffset_t getNumCellsInCsz(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(validCellSubzone(___467)); ItemAddress64::ItemOffset_t const ___2779 = m_cszInfo.numItemsInSz(___467); ENSURE(0 < ___2779 && ___2779 < ItemAddress64::MAX_ITEM_OFFSET+1); return ___2779; } inline ItemAddress64 cellAddressAtCellIJK(___1842 const& cellIJK) const { REQUIRE(cellIJK < m_cszInfo.ijkDim()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIJK(cellIJK); ENSURE(validCellAddress(___449)); return ___449; } inline ___1842 cellIJKAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___1842 const cellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ENSURE(cellIJK < m_cszInfo.ijkDim()); return cellIJK; } inline ItemAddress64 cellAddressAtContiguousCellIndex(___463 contiguousCellIndex) const { REQUIRE(contiguousCellIndex < ___1764()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIndex(contiguousCellIndex); ENSURE(validCellAddress(___449)); return ___449;
} inline ___463 contiguousCellIndexAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___463 const contiguousCellIndex = m_cszInfo.itemIndexAtItemAddress(___449); ENSURE(contiguousCellIndex<___1764()); return contiguousCellIndex; } inline ___463 contiguousCellIndexAtCellIJK(___1842 const& cellIJK) const { ___463 const contiguousCellIndex = m_cszInfo.itemIndexAtItemIJK(cellIJK); ENSURE(contiguousCellIndex<___1764()); return contiguousCellIndex; } inline ___463 getMaxPaddedCellIndex() const { REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); return m_nszInfo.ijkDim().i() * m_nszInfo.ijkDim().___2103() * m_cszInfo.ijkDim().___2132(); } inline ItemAddress64 cellAddressAtPaddedCellIndex(___463 paddedCellIndex) const { REQUIRE(paddedCellIndex < getMaxPaddedCellIndex()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___1842 cellIJK = m_nszInfo.itemIJKAtItemIndex(paddedCellIndex); if ( cellIJK.i() == m_cszInfo.ijkDim().i() ) cellIJK.setI(m_cszInfo.ijkLastIndex().i()); if ( cellIJK.___2103() == m_cszInfo.ijkDim().___2103() ) cellIJK.setJ(m_cszInfo.ijkLastIndex().___2103()); REQUIRE(cellIJK<m_cszInfo.ijkDim()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIJK(cellIJK); ENSURE(validCellAddress(___449)); return ___449; } inline ___463 paddedCellIndexAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___1842 const cellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___463 const paddedCellIndex = paddedCellIndexAtCellIJK(cellIJK); ENSURE(paddedCellIndex < getMaxPaddedCellIndex()); return paddedCellIndex; } inline ___463 paddedCellIndexAtCellIJK(___1842 const& cellIJK) const { REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___463 const paddedCellIndex = m_nszInfo.itemIndexAtItemIJK(cellIJK); ENSURE(paddedCellIndex < getMaxPaddedCellIndex()); return paddedCellIndex; } inline ItemAddress64::SubzoneAddress cszAtCellIJK(___1842 const& cellIJK) const { REQUIRE(cellIJK < m_cszInfo.ijkDim()); ItemAddress64::SubzoneAddress const cszAddress = m_cszInfo.szAddressAtItemIJK(cellIJK); ENSURE(validCszAddress(cszAddress)); return cszAddress; } inline ItemAddress64::SubzoneOffset_t getNumNszs(void) const { return m_nszInfo.getNumSzs(); } inline ItemAddress64::ItemOffset_t getNumNodesInNsz(ItemAddress64::SubzoneOffset_t ___2732) const { REQUIRE(validNodeSubzone(___2732)); ItemAddress64::ItemOffset_t const ___2819 = m_nszInfo.numItemsInSz(___2732); ENSURE(0 < ___2819 && ___2819 < ItemAddress64::MAX_ITEM_OFFSET+1); return ___2819; } inline ItemAddress64 nodeAddressAtNodeIJK(___1842 const& nodeIJK) const { REQUIRE(nodeIJK < m_nszInfo.ijkDim()); ItemAddress64 const nodeAddress = m_nszInfo.itemAddressAtItemIJK(nodeIJK); ENSURE(validNodeAddress(nodeAddress)); return nodeAddress; }
inline ___1842 nodeIJKAtNodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(validNodeAddress(nodeAddress)); ___1842 const nodeIJK = m_nszInfo.itemIJKAtItemAddress(nodeAddress); ENSURE(nodeIJK < m_nszInfo.ijkDim()); return nodeIJK; } inline ItemAddress64 nodeAddressAtNodeIndex(___2716 ___2714) const { REQUIRE(___2714 < ___1766()); ItemAddress64 const nodeAddress = m_nszInfo.itemAddressAtItemIndex(___2714); return nodeAddress; } inline ItemAddress64::SubzoneAddress nszAtNodeIJK(___1842 const& nodeIJK) const { REQUIRE(nodeIJK < m_nszInfo.ijkDim()); ItemAddress64::SubzoneAddress const nszAddress = m_nszInfo.szAddressAtItemIJK(nodeIJK); ENSURE(validNszAddress(nszAddress)); return nszAddress; } inline ItemAddress64::SubzoneOffset_t nodeSubzoneOffsetAtNodeIndex(___2716 ___2714) const { REQUIRE(___2714 < ___1766()); if (m_subzoneOffsetsAtNodeIndices[___2714] == ItemAddress64::INVALID_SUBZONE_OFFSET) m_subzoneOffsetsAtNodeIndices[___2714] = m_nszInfo.subzoneOffsetAtItemIndex(___2714); return m_subzoneOffsetsAtNodeIndices[___2714]; } inline ___2716 nodeIndexAtNodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(validNodeAddress(nodeAddress)); ___2716 const ___2714 = m_nszInfo.itemIndexAtItemAddress(nodeAddress); ENSURE(___2714<___1766()); return ___2714; } inline ___2716 nodeIndexAtNodeIJK(___1842 const& nodeIJK) const { ___2716 const ___2714 = m_nszInfo.itemIndexAtItemIJK(nodeIJK); ENSURE(___2714<___1766()); return ___2714; } inline ItemAddress64 getCellCorner( ItemAddress64 const& ___449, CellNodeIndex_t      ___679) const { REQUIRE(validCellAddress(___449)); REQUIRE(___679 < NUM_IJK_CELL_CORNERS); ___1842 const zoneCellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___1842 const cornerIJK = zoneCellIJK + ijkCornerOffset[___679]; ___476(0 <= cornerIJK); ItemAddress64 cornerNodeAddress; if (cornerIJK < ___2712()) { cornerNodeAddress = nodeAddressAtNodeIJK(cornerIJK); ___476(validNodeAddress(cornerNodeAddress)); } else { cornerNodeAddress = ItemAddress64(BAD_ANY_INDEX); } return cornerNodeAddress; } inline void getCellCorners( ItemAddress64 const&     ___449, ___3267<ItemAddress64>& cornerNodeAddresses) const { REQUIRE(validCellAddress(___449)); REQUIRE(cornerNodeAddresses.empty()); cornerNodeAddresses.reserve(NUM_IJK_CELL_CORNERS); cornerNodeAddresses.___3501(NUM_IJK_CELL_CORNERS); ___1842 const zoneCellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___1842 const& nodeSzIJKDim = ___2712(); ___1842 const baseSzIJK = m_nszInfo.szIJKAtItemIJK(zoneCellIJK); ___1842 const baseIJKEnd = m_nszInfo.itemIJKEnd(baseSzIJK); for (CellNodeIndex_t ___679 = 0; ___679 < NUM_IJK_CELL_CORNERS; ++___679) { ___1842 const cornerIJK = zoneCellIJK + ijkCornerOffset[___679]; ___476(0 <= cornerIJK); if (cornerIJK < nodeSzIJKDim) { ___1842 const nszIJK(cornerIJK.i() > baseIJKEnd.i() ? baseSzIJK.i()+1 : baseSzIJK.i(), cornerIJK.___2103() > baseIJKEnd.___2103() ? baseSzIJK.___2103()+1 : baseSzIJK.___2103(), cornerIJK.___2132() > baseIJKEnd.___2132() ? baseSzIJK.___2132()+1 : baseSzIJK.___2132());
cornerNodeAddresses[___679] = m_nszInfo.itemAddressAtItemIJK(cornerIJK, nszIJK); ___476(validNodeAddress(cornerNodeAddresses[___679])); } else { cornerNodeAddresses[___679] = ItemAddress64(BAD_ANY_INDEX); } } } inline ___463 getNumIJKFaceNeighbors( ItemAddress64 const&  , FaceIndex_t          ASSERT_ONLY(___455)) const { REQUIRE(___455 < NUM_IJK_CELL_FACES); return 1; } inline void cszFaceNeighborIJKRange( ItemAddress64::SubzoneOffset_t ___467, int                            iDir, int                            jDir, int                            kDir, ItemAddress64::SubzoneAddress& fnCszAddress, ___1842&                           fnCszIJKRange) const { REQUIRE(validCellSubzone(___467)); REQUIRE(iDir == -1 || iDir == 0 || iDir == 1); REQUIRE(jDir == -1 || jDir == 0 || jDir == 1); REQUIRE(kDir == -1 || kDir == 0 || kDir == 1); REQUIRE((iDir != 0 && jDir == 0 && kDir == 0) || (iDir == 0 && jDir != 0 && kDir == 0) || (iDir == 0 && jDir == 0 && kDir != 0)); ___1842 const subzoneIJK = m_cszInfo.szIJKAtSzIndex(___467); fnCszAddress = m_cszInfo.szAddressAtSzIJK( ___1842(subzoneIJK.i()+iDir,subzoneIJK.___2103()+jDir,subzoneIJK.___2132()+kDir)); ___1842 const fnCszIJKStart = m_cszInfo.subzoneIJKStart(fnCszAddress.subzoneOffset()); ___1842 const fnCszIJKEnd = m_cszInfo.subzoneIJKEnd(fnCszAddress.subzoneOffset()); fnCszIJKRange = fnCszIJKEnd-fnCszIJKStart+1; } inline void getIJKFaceNeighbor( ItemAddress64 const& ___449, FaceIndex_t          ___455, ___463          ASSERT_ONLY(neighborOffset), ItemAddress64&       fnCoord, ___4633&         fnZone) const { REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(neighborOffset < getNumIJKFaceNeighbors(___449, ___455)); ItemAddress64::SubzoneOffset_t const ___467 = ___449.subzoneOffset(); ItemAddress64::ItemOffset_t const ___2863 = ___449.itemOffset(); ___1842 const ijkLastIndex = m_cszInfo.ijkLastIndex(); ___1842 const ___1878 = m_cszInfo.subzoneIJKStart(___467); ___1842 const ___1850 = m_cszInfo.subzoneIJKEnd(___467); ___1842 const ijkRange = ___1850-___1878+1; ___1842 const ___1860 = ijkRange.ijkAtOffset(___2863); ___1842 const ijkCell = ___1878 + ___1860; ItemAddress64::SubzoneAddress fnCszAddress; ___1842 fnCszIJKRange; switch (___455) { case 0: if (ijkCell.i() > 0) { if (___1860.i() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1842(1,0,0)); } else { cszFaceNeighborIJKRange(___467, -1, 0, 0, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(fnCszIJKRange.i()-1,___1860.___2103(),___1860.___2132()); fnCoord = ItemAddress64( fnCszAddress, static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; case 1: if (ijkCell.i() < ijkLastIndex.i()) { if (___1860.i() < ijkRange.i()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1842(1,0,0)); } else { cszFaceNeighborIJKRange(___467, 1,0,0, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(0,___1860.___2103(),___1860.___2132()); fnCoord = ItemAddress64(
fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; case 2: if (ijkCell.___2103() > 0) { if (___1860.___2103() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1842(0,1,0)); } else { cszFaceNeighborIJKRange(___467, 0, -1, 0, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(___1860.i(),fnCszIJKRange.___2103()-1,___1860.___2132()); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; case 3: if (ijkCell.___2103() < ijkLastIndex.___2103()) { if (___1860.___2103() < ijkRange.___2103()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1842(0,1,0)); } else { cszFaceNeighborIJKRange(___467, 0, 1, 0, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(___1860.i(),0,___1860.___2132()); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; case 4: if (ijkCell.___2132() > 0) { if (___1860.___2132() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1842(0,0,1)); } else { cszFaceNeighborIJKRange(___467, 0, 0, -1, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(___1860.i(),___1860.___2103(),fnCszIJKRange.___2132()-1); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; case 5: if (ijkCell.___2132() < ijkLastIndex.___2132()) { if (___1860.___2132() < ijkRange.___2132()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1842(0,0,1)); } else { cszFaceNeighborIJKRange(___467, 0, 0, 1, fnCszAddress, fnCszIJKRange); ___1842 const fnCszIJKOffset(___1860.i(),___1860.___2103(),0); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2747); } break; default: ___476(___1303); break; } fnZone = ___2748; } ___463 getCellsAroundNodeIJK( ___1842 const&               nodeIJK, ___3267<ItemAddress64>& adjacentCells) const; ___372 getCszsOnIndexPlane( IJKPlanes_e                              whichPlane, ___2716                              planeIndex, ___3267<ItemAddress64::SubzoneAddress>& cszAddresses) const { REQUIRE(whichPlane == ___1865 || whichPlane == ___1870 || whichPlane == ___1872); REQUIRE(IMPLICATION(whichPlane == ___1865 ,planeIndex < m_nszInfo.ijkDim().i()) && IMPLICATION(whichPlane == ___1870 ,planeIndex < m_nszInfo.ijkDim().___2103()) && IMPLICATION(whichPlane == ___1872 ,planeIndex < m_nszInfo.ijkDim().___2132())); REQUIRE(cszAddresses.empty()); ___372 const ___2037 = m_cszInfo.getSubzonesOnIndexPlane(whichPlane, planeIndex, cszAddresses); ENSURE(IMPLICATION(___2037, !cszAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(cszAddresses.begin(), cszAddresses.end())));
ENSURE(IMPLICATION(___2037, cszAddresses[cszAddresses.size()-1].___2975()==m_partition)); ENSURE(IMPLICATION(___2037, cszAddresses[cszAddresses.size()-1].subzoneOffset() < getNumCszs())); return ___2037; } ___372 getCszsOnIndexLine( IJKLines_e                               whichLine, ___2716                              mIndex, ___2716                              nIndex, ___3267<ItemAddress64::SubzoneAddress>& cszAddresses) const { REQUIRE(whichLine == ___1855 || whichLine == ___1857 || whichLine == ___1858); REQUIRE(IMPLICATION(whichLine == ___1855, mIndex < m_nszInfo.ijkDim().___2103() && nIndex < m_nszInfo.ijkDim().___2132()) && IMPLICATION(whichLine == ___1857, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2132()) && IMPLICATION(whichLine == ___1858, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2103())); REQUIRE(cszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 const ___2037 = m_cszInfo.getSubzonesOnIndexLine(whichLine, mIndex, nIndex, cszAddresses); ENSURE(IMPLICATION(___2037, !cszAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(cszAddresses.begin(), cszAddresses.end()))); ENSURE(IMPLICATION(___2037, cszAddresses[cszAddresses.size()-1].___2975()==m_partition)); ENSURE(IMPLICATION(___2037, cszAddresses[cszAddresses.size()-1].subzoneOffset() < getNumCszs())); return ___2037; } ___372 getNszsOnIndexPlane( IJKPlanes_e                              whichPlane, ___2716                              planeIndex, ___3267<ItemAddress64::SubzoneAddress>& nszAddresses) const { REQUIRE(whichPlane == ___1865 || whichPlane == ___1870 || whichPlane == ___1872); REQUIRE(IMPLICATION(whichPlane == ___1865, planeIndex < m_nszInfo.ijkDim().i()) && IMPLICATION(whichPlane == ___1870, planeIndex < m_nszInfo.ijkDim().___2103()) && IMPLICATION(whichPlane == ___1872, planeIndex < m_nszInfo.ijkDim().___2132())); REQUIRE(nszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 ___2037 = m_nszInfo.getSubzonesOnIndexPlane(whichPlane, planeIndex, nszAddresses); ENSURE(IMPLICATION(___2037, !nszAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(nszAddresses.begin(), nszAddresses.end()))); ENSURE(IMPLICATION(___2037, nszAddresses[nszAddresses.size()-1].___2975()==m_partition)); ENSURE(IMPLICATION(___2037, nszAddresses[nszAddresses.size()-1].subzoneOffset() < getNumNszs())); return ___2037; } ___372 getNszsOnIndexLine( IJKLines_e                               whichLine, ___2716                              mIndex, ___2716                              nIndex, ___3267<ItemAddress64::SubzoneAddress>& nszAddresses) const { REQUIRE(whichLine == ___1855 || whichLine == ___1857 || whichLine == ___1858); REQUIRE(IMPLICATION(whichLine == ___1855, mIndex < m_nszInfo.ijkDim().___2103() && nIndex < m_nszInfo.ijkDim().___2132()) && IMPLICATION(whichLine == ___1857, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2132()) &&
IMPLICATION(whichLine == ___1858, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2103())); REQUIRE(nszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 const ___2037 = m_nszInfo.getSubzonesOnIndexLine(whichLine, mIndex, nIndex, nszAddresses); ENSURE(IMPLICATION(___2037, !nszAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(nszAddresses.begin(), nszAddresses.end()))); ENSURE(IMPLICATION(___2037, nszAddresses[nszAddresses.size()-1].___2975()==m_partition)); ENSURE(IMPLICATION(___2037, nszAddresses[nszAddresses.size()-1].subzoneOffset() < getNumNszs())); return ___2037; } void includeNszVarMinMax(ItemAddress64::SubzoneOffset_t ___2732, std::vector<___2477> const& varMinMaxes) { REQUIRE(!varMinMaxes.empty()); std::vector<___2477>& nszVarMinMaxes = m_nszMinMaxes[___2732]; if (nszVarMinMaxes.empty()) nszVarMinMaxes.resize(varMinMaxes.size()); for (size_t ___4333 = 0; ___4333 < varMinMaxes.size(); ++___4333) nszVarMinMaxes[___4333].include(varMinMaxes[___4333]); } NszMinMaxMap const& getNszMinMaxes() const { return m_nszMinMaxes; } inline void resetNeighborInfo() { m_nszMinMaxes.clear(); } ___372 getNodeSubzonesInRange( ___1842 const& nodeIJKStart, ___1842 const& nodeIJKEnd, ___3267<ItemAddress64::SubzoneAddress>& refNszAddresses) const; ___372 getCszReferencedNszs( ItemAddress64::SubzoneAddress const&     cszAddress, ___3267<ItemAddress64::SubzoneAddress>& refNszAddresses) const; ___372 getCellSubzonesInRange( ___1842 const& cellIJKStart, ___1842 const& cellIJKEnd, ___3267<ItemAddress64::SubzoneAddress>& refCszAddresses) const; ___372 getNszReferencedCszs( ItemAddress64::SubzoneAddress const&     nszAddress, ___3267<ItemAddress64::SubzoneAddress>& refCszAddresses) const; }; }}
