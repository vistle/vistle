#include "importSzPltFile.h"
#include "ThirdPartyHeadersBegin.h"
#include <cctype>
#include <cfloat>
#include <limits>
#include <locale>
#include <string>
#include <boost/assign.hpp>
#include <boost/function.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "BitArray.h"
#include "CszConnectivity.h"
#include "FECellSubzoneCompressor.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileReaderInterface.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "PartitionMetadata.h"
#include "RawArray.h"
#include "Scanner.h"
#include "readValueArray.h"
#include "xyz.h"
#include "ZoneMetadata.h"
#include "ZoneVarMetadata.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { ___372 readDataFileHeader( ___1397& file, ___1386&     ___1385, uint64_t&            byteOrderIndicator, uint64_t&            dataSetHeaderLocation) { ___372 ___2037 = ___4224; char textOrBinary = '\0'; if (!file.___3458()) ___2037 = ___1184("Can't read SZPLT file."); tecplot::___3439 headerScanner; size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; if (___2037 && !(file.fgets(headerBuffer, headerBufferSize) != NULL && headerBuffer[strlen(headerBuffer)-1] == '\n')) ___2037 = ___1184("SZPLT file has incorrect header. Cannot parse file header info."); uint32_t  fileVersion = 0; if (___2037) { headerScanner.reset(headerBuffer); char const* const fileTypeID = "#!" SZPLT_FILE_TYPE; if (___2037 && !(headerScanner.next(strlen(fileTypeID)) == fileTypeID && headerScanner.next(1) == " ")) ___2037 = ___1184("SZPLT file has incorrect header. File type is not correct."); if (___2037 && !headerScanner.hasNextInt64Token("BT")) ___2037 = ___1184("SZPLT file has incorrect header. Version format is not correct."); if (___2037) fileVersion = static_cast<uint32_t>(headerScanner.nextInt64Token("BT")); if (___2037 && fileVersion < SZPLT_MIN_READ_VERSION) ___2037 = ___1184("SZPLT file is an older version %" PRIu32 " that is no longer supported.", fileVersion); if (___2037 && fileVersion > SZPLT_MAX_READ_VERSION ) ___2037 = ___1184("SZPLT file is an newer version %" PRIu32 " that is not supported by the current loader. Try updating your Tecplot.", fileVersion); if (___2037 && !headerScanner.hasNextChar()) ___2037 = ___1184("SZPLT file has incorrect header. Missing text or binary designator."); if (___2037) textOrBinary = headerScanner.nextChar(); if (___2037 && textOrBinary != 'B' && textOrBinary != 'T') ___2037 = ___1184("SZPLT file has incorrect header. Cannot determine binary or text file type."); } ___372 ___2000 = ___1303; DataFileType_e ___842 = ___845; if (___2037) { ___2000 = textOrBinary == 'T'; ___842 = ___843; if (fileVersion >= 105) { char dataFileTypeChar = '\0'; ___2037 = headerScanner.hasNextChar(); if (___2037) dataFileTypeChar = headerScanner.nextChar(); if (___2037) { if (dataFileTypeChar == 'F') ___842 = ___843; else if (dataFileTypeChar == 'G') ___842 = ___844; else if (dataFileTypeChar == 'S') ___842 = ___846; else ___2037 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } else { ___2037 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } } } uint32_t codeRevision = 0; if (___2037 && headerScanner.hasNextToken() && headerScanner.nextToken() == " $Revision: " && headerScanner.hasNextInt64Token()) codeRevision = static_cast<uint32_t>(headerScanner.nextInt64Token()); else codeRevision = 0; if (___2037) { file.___3492(___2000); file.setDataFileType(___842); ___1385.setFileVersion(fileVersion); ___1385.___3492(___2000);
___1385.setDataFileType(___842); ___1385.setCodeRevision(codeRevision); } byteOrderIndicator = 0; ___2037 = ___2037 && readValue<uint64_t, true>(file, byteOrderIndicator, IODescription(___1384)); ___476(IMPLICATION(___2037, byteOrderIndicator == ___1383)); dataSetHeaderLocation = 0; ___2037 = ___2037 && readValue<uint64_t, true>(file, dataSetHeaderLocation, IODescription(___893)); ___476(IMPLICATION(___2037, dataSetHeaderLocation != 0)); return ___2037; } namespace { ___372 readTagList( ___1397& file, ___3940&   tagDescriptionMap, ___3943&         ___3942) { uint16_t numTags; ___372 ___2037 = readValue<uint16_t, false>(file, numTags, IODescription(___2837)); UInt16Array tagArray; size_t arraySize = static_cast<size_t>(numTags); ___2037 = ___2037 && tagArray.alloc(arraySize); ___2037 = ___2037 && readValueArray<uint16_t, false, 0>(file, 0, arraySize, tagArray, IODescription(___3941)); try { for(size_t i = 0; ___2037 && i < arraySize; ++i) { uint16_t tag = tagArray[i]; ___3940::const_iterator it = tagDescriptionMap.find(tag); if (it == tagDescriptionMap.end()) { ___2037 = ___1929("Unrecognized tag while reading file header: %d. Attempting to continue...", tag); if (___2037) { if (file.___2000()) { int c = file.getc(); while(!file.feof() && c != '\n') c = file.getc(); if (file.feof()) ___2037 = ___1184("End-of-file encountered attempting to skip unrecognized tag."); } else { uint64_t unused; if (file.fread(&unused, sizeof(unused), size_t(1)) != 1) ___2037 = ___1184("Read error while attempting to skip unrecognized tag."); } } } else { ___2037 = ___2037 && readValue<uint64_t, true>(file, ___3942[tag], IODescription(tagDescriptionMap[tag].c_str())); } } } catch(...) { ___2037 = ___1184("Error while reading file tags, possibly out of memory."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ensureRequiredHeaderTagValuesArePresent( const char* headerTypeString, ___3943 const& ___3942, ___3940& tagDescriptionMap, std::vector<uint16_t> const& tagList) { for (std::vector<uint16_t>::const_iterator tag = tagList.begin(); tag != tagList.end(); ++tag) { ___3943::const_iterator it = ___3942.find(*tag); if (it == ___3942.end()) return ___1184("Missing required %s header tag %" PRIu64 ", '%s'.", headerTypeString, uint64_t(*tag), tagDescriptionMap[*tag].c_str()); } return ___4224; } } namespace { template <typename T> ___372 retrieveRequiredNonZeroValue(___3943 const& ___3942, uint16_t tag, char const* ___2683, T& value) { ___372 ___2037 = ___4224; ___3943::const_iterator it = ___3942.find(tag); if (it == ___3942.end()) ___2037 = ___1184("Missing value for '%s' while reading file header.", ___2683); else value = static_cast<T>(it->second); if (___2037 && value == static_cast<T>(0)) ___2037 = ___1184("Invalid value (0) for '%s' while reading file header.", ___2683); ENSURE(VALID_BOOLEAN(___2037));
return ___2037; } } ___372 readDataSetHeaderTags( ___1397& file, ___1386&     ___1385, ___3943&         ___3942) { REQUIRE(file.___2039()); ___3940 tagDescriptionMap = DATASET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; std::vector<uint16_t> tagList; tagList.reserve(tagDescriptionMap.size()); for (___3940::const_iterator it = tagDescriptionMap.begin(); it != tagDescriptionMap.end(); ++it) { bool const addTag = it->first != DATA_SET_TITLE_TAG && it->first != NUM_PARTITION_FILES_TAG && (___1385.getFileVersion() <= 105 && it->first != ZONE_NUM_SECTIONS_FILE_LOC_TAG && it->first != ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG); if (addTag) tagList.push_back(it->first); } ___372 ___2037 = readTagList(file, tagDescriptionMap, ___3942); ___2037 = ___2037 && ensureRequiredHeaderTagValuesArePresent("file", ___3942, tagDescriptionMap, tagList); if (___2037) { ___81 subzoneMaxISize = 0; ___81 subzoneMaxJSize = 0; ___81 subzoneMaxKSize = 0; ItemAddress64::ItemOffset_t subzoneMaxFESize = 0; if (retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_I_SIZE_TAG, SUBZONE_MAX_I_SIZE_DESCRIPTION, subzoneMaxISize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_J_SIZE_TAG, SUBZONE_MAX_J_SIZE_DESCRIPTION, subzoneMaxJSize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_K_SIZE_TAG, SUBZONE_MAX_K_SIZE_DESCRIPTION, subzoneMaxKSize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_FE_SIZE_TAG, SUBZONE_MAX_FE_SIZE_DESCRIPTION, subzoneMaxFESize)) { ___1385.setMaxIJKSubzoneSize(___1842(subzoneMaxISize, subzoneMaxJSize, subzoneMaxKSize)); ___1385.setMaxFESubzoneSize(subzoneMaxFESize); } else { ___2037 = ___1303; } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { template <typename T> ___372 retrieveRequiredValue(___3943 const& ___3942, uint16_t tag, char const* ___2683, T& value) { ___372 ___2037 = ___4224; ___3943::const_iterator it = ___3942.find(tag); if (it == ___3942.end()) ___2037 = ___1184("Missing value for '%s' while reading file header.", ___2683); else value = static_cast<T>(it->second); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 applyDataSetHeaderScalarTagValues( ___3943 const& ___3942, ___4349& ___2841, ___4633& ___2844) { ___372 ___2037 = retrieveRequiredValue(___3942, ___2843, NUM_VARS_DESCRIPTION, ___2841); ___2037 = ___2037 && retrieveRequiredValue(___3942, ___2847, NUM_ZONES_DESCRIPTION, ___2844); if (___2841 > MAX_NUM_VARS) ___2037 = ___1184("File exceeds SZL variable limit"); else if (___2844 > MAX_NUM_ZONES) ___2037 = ___1184("File exceeds SZL zone limit"); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readDatasetTitle( ___1397& file, ___3943&         ___3942, std::string&         datasetTitle)
{ REQUIRE(file.___2039()); if (___3942.find(DATA_SET_TITLE_TAG) == ___3942.end()) return ___4224; ___372 ___2037 = file.___3457(___3942[DATA_SET_TITLE_TAG]); uint32_t titleLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, titleLength, IODescription(DATA_SET_TITLE_LENGTH)); if (___2037 && titleLength > 0) { try { ___471 ___4175; ___2037 = ___2037 && ___4175.alloc(titleLength); ___2037 = ___2037 && readString(file, titleLength, ___4175, IODescription(DATA_SET_TITLE_DESCRIPTION)); if ( ___2037 ) datasetTitle = std::string(___4175.data(), titleLength); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading dataset title."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readPerVarFileHeader( ___1397& file, ___3943&         ___3942, ___4349           varOffset, ___3814&         varNameArray) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; try { size_t ___2841 = static_cast<size_t>(___3942[___2843]); if (___2841 == 0) return ___4224; REQUIRE(IMPLICATION(varNameArray.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!varNameArray.empty(), varOffset+___2841 <= varNameArray.size())); uint64_t varNameLocation = ___3942[___4362]; if (varNameLocation == 0) { ___2037 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4362), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2037 = file.___3457(varNameLocation); ___2037 = ___2037 && readStringArray(file, varOffset, ___2841, varNameArray, IODescription(___4361)); } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading file header."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readZoneHeaderFileLocArray( ___1397& file, ___4633          zoneOffset, ___4633          ___2844, ___1390&        zoneFileLocArray) { REQUIRE(file.___2039()); REQUIRE(___2844>0); REQUIRE(IMPLICATION(zoneFileLocArray.empty(), zoneOffset == 0)); REQUIRE(IMPLICATION(!zoneFileLocArray.empty(), size_t(zoneOffset+___2844) <= zoneFileLocArray.size())); REQUIRE("file is at correct file loc"); ___372 ___2037 = readValueArray<uint64_t, true, 0>(file, zoneOffset, ___2844, zoneFileLocArray, IODescription(___4625)); if ( ___2037 ) { if ( zoneFileLocArray[zoneOffset] == ___1391(0) || zoneFileLocArray[zoneOffset] == ___330 || zoneFileLocArray[zoneOffset + ___2844/2] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2844/2] == ___330 || zoneFileLocArray[zoneOffset + ___2844-1] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2844-1] == ___330 ) { ___2037 = ___1184("This file has invalid zone file locations."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template <typename T> ___372 readZoneSecTaggedArray( ___1397&                      file, ___3943&                              ___3942,
uint16_t                                  fileLocTag, char const*                               ___970, ___4633                               ___2844, ___2238<uint8_t> const&         zoneNumSections, ___2238<___2238<T> >& zoneSecArray) { REQUIRE(file.___2039()); REQUIRE(VALID_REF(___970)); REQUIRE(___2844 == checked_numeric_cast<___4633>(zoneNumSections.size())); REQUIRE(zoneSecArray.empty() || zoneNumSections.size() == zoneSecArray.size()); ___372 ___2037 = zoneSecArray.alloc(___2844) && file.___3457(___3942[fileLocTag]); for (___4633 zone = 0; ___2037 && zone < ___2844; ++zone) { if (zoneNumSections[zone] > 0) ___2037 = readValueArray<T, false, 0>( file, 0, zoneNumSections[zone], zoneSecArray[zone], IODescription(___970)); } return ___2037; } } ___372 readDataSetHeader( ___1397& file, ___1386&     ___1385, ___3943&         ___3942, std::string&         datasetTitle, ___4704&     ___4703, ___1390&        ___4626) { REQUIRE(file.___2039()); REQUIRE(!___3942.empty()); REQUIRE(___4626.empty() || ___3942[___2847] <= ___4626.size()); ___372 ___2037 = readDatasetTitle(file, ___3942, datasetTitle); if (___2037) { try { ___4349 const ___2841 = static_cast<___4349>(___3942[___2843]); if (___2841 > 0) { uint64_t varNameLocation = ___3942[___4362]; if (varNameLocation == 0) { ___2037 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4362), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2037 = file.___3457(varNameLocation); ___2037 = ___2037 && readStringArray(file, 0, ___2841, ___4703.m_varNames, IODescription(___4361)); } } ___4633 const ___2844 = static_cast<___4633>(___3942[___2847]); if (___2844 > 0) { ___4703.m_numZones = ___2844; ___4703.m_numVars  = ___2841; if (___2037 && ___3942[___4627] == 0) ___2037 = ___1184("File does not contain zone header file locations."); ___2037 = ___2037 && file.___3457(___3942[___4627]); ___2037 = ___2037 && readZoneHeaderFileLocArray(file, 0, ___4633(___2844), ___4626); ___2037 = ___2037 && ___4703.m_zoneNames.alloc(___2844) && file.___3457(___3942[___4648]) && readStringArray(file, 0, ___2844, ___4703.m_zoneNames, IODescription(___4647)) && ___4703.m_zoneTypes.alloc(___2844) && file.___3457(___3942[ZONE_TYPE_FILE_LOC_TAG]) && readValueArray<char, false, 0>(file, 0, ___2844, ___4703.m_zoneTypes, IODescription(___4691)) && ___4703.m_zoneFaceNeighborModes.alloc(___2844) && file.___3457(___3942[___4607]) && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4703.m_zoneFaceNeighborModes, IODescription(___4606)) &&
___4703.m_zoneSolutionTimes.alloc(___2844) && file.___3457(___3942[___4673]) && readValueArray<double, false, 0>(file, 0, ___2844, ___4703.m_zoneSolutionTimes, IODescription(___4672)) && ___4703.m_zoneStrandIDs.alloc(___2844) && file.___3457(___3942[___4683]) && readValueArray<uint32_t, false, 0>(file, 0, ___2844, ___4703.m_zoneStrandIDs, IODescription(___4682)) && ___4703.m_zoneParentZones.alloc(___2844) && file.___3457(___3942[___4667]) && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4703.m_zoneParentZones, IODescription(___4666)) && ___4703.m_zoneIMaxOrNumNodes.alloc(___2844) && file.___3457(___3942[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4703.m_zoneIMaxOrNumNodes, IODescription(ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION)) && ___4703.m_zoneJMaxOrNumCells.alloc(___2844) && file.___3457(___3942[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4703.m_zoneJMaxOrNumCells, IODescription(ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION)) && ___4703.m_zoneKMaxOrNumCorners.alloc(___2844) && file.___3457(___3942[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4703.m_zoneKMaxOrNumCorners, IODescription(ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION)) && ___4703.m_zoneShareConnectivityWithZone.alloc(___2844) && file.___3457(___3942[___4671]) && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4703.m_zoneShareConnectivityWithZone, IODescription(___4670)); if (___2037 && ___1385.getFileVersion() > 105) { ___2037 = ___2037 && ___4703.m_zoneNumSections.alloc(___2844) && file.___3457(___3942[ZONE_NUM_SECTIONS_FILE_LOC_TAG]) && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4703.m_zoneNumSections, IODescription(ZONE_NUM_SECTIONS_ARRAY_DESCRIPTION)); if (___2037 && ___1385.getFileVersion() < 232) { ___2238<UInt32Array> zoneNumElemsPerSec_uint32; ___2037 = ___2037 && readZoneSecTaggedArray<uint32_t>(file, ___3942, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, zoneNumElemsPerSec_uint32); ___2037 = ___2037 && ___4703.m_zoneNumElemsPerSec.alloc(___2844); for (___4633 zone = 0; ___2037 && zone < ___2844; ++zone) { ___2037 = ___4703.m_zoneNumElemsPerSec[zone].alloc(___4703.m_zoneNumSections[zone]); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < ___4703.m_zoneNumSections[zone]; ++section) ___4703.m_zoneNumElemsPerSec[zone][section] = zoneNumElemsPerSec_uint32[zone][section];
} } else { ___2037 = ___2037 && readZoneSecTaggedArray<int64_t>(file, ___3942, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneNumElemsPerSec); } ___2037 = ___2037 && readZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_SHAPE_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneCellShapePerSec); ___2037 = ___2037 && readZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG, ZONE_GRID_ORDER_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneGridOrderPerSec); ___2037 = ___2037 && readZoneSecTaggedArray<uint8_t>(file, ___3942, ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_BASIS_FUNC_PER_SECTION_ARRAY_DESCRIPTION, ___2844, ___4703.m_zoneNumSections, ___4703.m_zoneCellBasisFuncPerSec); } else { ___4703.m_zoneNumSections.alloc(___2844, 0); ___4703.m_zoneNumElemsPerSec.alloc(___2844); ___4703.m_zoneCellShapePerSec.alloc(___2844); ___4703.m_zoneGridOrderPerSec.alloc(___2844); ___4703.m_zoneCellBasisFuncPerSec.alloc(___2844); } } if (___2844 > 0 && ___2841 > 0) { ___2037 = ___2037 && ___4703.m_zoneDimension.alloc(___2844); for (___4633 zone = 0; ___2037 && zone < ___2844; ++zone) { ZoneType_e const ___4689 = zoneTypeFromFileChar(___4703.m_zoneTypes[zone]); if (___4689 == ___4701) { ___4703.m_zoneDimension[zone] = ___2881( ___1842(___4703.m_zoneIMaxOrNumNodes[zone], ___4703.m_zoneJMaxOrNumCells[zone], ___4703.m_zoneKMaxOrNumCorners[zone])); } else if (___4689 == ZoneType_FEMixed) { ___476(!___4703.m_zoneCellShapePerSec.empty() && !___4703.m_zoneCellShapePerSec[zone].empty()); ___4703.m_zoneDimension[zone] = feMixedZoneDimension(static_cast<FECellShape_e>(___4703.m_zoneCellShapePerSec[zone][0])); } else { ___4703.m_zoneDimension[zone] = feNonMixedZoneDimension(___4689); } } ___2037 = ___2037 && file.___3457(___3942[___4381]) && ___4703.m_vzFieldDataTypes.alloc(___2841); for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4703.m_vzFieldDataTypes[___4333], IODescription(VAR_ZONE_FIELD_DATA_TYPE_FILE_LOC_DESCRIPTION, ___4333)); ___2037 = ___2037 && file.___3457(___3942[VAR_ZONE_MIN_MAX_FILE_LOC_TAG]) && ___4703.m_vzMinMaxes.alloc(___2841); if (___2037) { bool minMaxesAreDouble = false; for (___4349 ___4333 = 0; !minMaxesAreDouble && ___4333 < ___2841; ++___4333) { for (___4633 zone = 0; !minMaxesAreDouble && zone < ___2844; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4703.m_vzFieldDataTypes[___4333][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32)
minMaxesAreDouble = true; } } if (minMaxesAreDouble) { for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readMinMaxArray<double>(file, 0, ___2844, ___4703.m_vzMinMaxes[___4333], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4333)); } else { for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readMinMaxArray<float>(file, 0, ___2844, ___4703.m_vzMinMaxes[___4333], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4333)); } } ___2037 = ___2037 && file.___3457(___3942[___4390]) && ___4703.m_vzValueLocations.alloc(___2841); for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4703.m_vzValueLocations[___4333], IODescription(VAR_ZONE_VALUE_LOCATION_FILE_LOC_DESCRIPTION, ___4333)); ___2037 = ___2037 && file.___3457(___3942[___4384]) && ___4703.m_vzIsPassive.alloc(___2841); for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4703.m_vzIsPassive[___4333], IODescription(VAR_ZONE_IS_PASSIVE_FILE_LOC_DESCRIPTION, ___4333)); ___2037 = ___2037 && file.___3457(___3942[___4387]) && ___4703.m_vzShareVarWithZone.alloc(___2841); for (___4349 ___4333 = 0; ___2037 && ___4333 < ___2841; ___4333++) ___2037 = ___2037 && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4703.m_vzShareVarWithZone[___4333], IODescription(VAR_ZONE_SHARE_FILE_LOC_DESCRIPTION, ___4333)); } } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading data set header."); } catch (...) { ___2037 = ___1184("Unrecoverable error while reading data set header."); } } return ___2037; } ZoneType_e zoneTypeFromFileChar(char c) { char lowerCaseChar = static_cast<char>(tolower(c)); std::map<char, ZoneType_e> zoneTypeMap = boost::assign::map_list_of<char, ZoneType_e> (___4702, ___4701) (ZONETYPE_FETRIANGLE_CHAR, ___4699) (ZONETYPE_FEQUAD_CHAR, ___4697) (ZONETYPE_FETETRA_CHAR, ___4698) (ZONETYPE_FEBRICK_CHAR, ___4692) (ZONETYPE_FELINESEG_CHAR, ___4693) (ZONETYPE_FEPOLYGON_CHAR, ___4695) (ZONETYPE_FEPOLYHEDRON_CHAR, ___4696) (ZONETYPE_FEMIXED_CHAR, ZoneType_FEMixed); REQUIRE(zoneTypeMap.find(lowerCaseChar) != zoneTypeMap.end()); return zoneTypeMap[lowerCaseChar]; } void storeZoneMetadata( ___4704 const& ___4703, ___4633            zone, ___4633            targetBaseZoneOffset, ZoneMetadata&          zoneMetadata) { zoneMetadata.setZone(zone); ZoneType_e ___4689 = zoneTypeFromFileChar(___4703.m_zoneTypes[zone]); zoneMetadata.setZoneType(___4689); if (___4689 == ___4701) { ___1842 ___1841( static_cast<___81>(___4703.m_zoneIMaxOrNumNodes[zone]), static_cast<___81>(___4703.m_zoneJMaxOrNumCells[zone]), static_cast<___81>(___4703.m_zoneKMaxOrNumCorners[zone]));
zoneMetadata.setIJKMax(___1841); } else { zoneMetadata.setFEDescription( static_cast<___463>(___4703.m_zoneJMaxOrNumCells[zone]), static_cast<CellNodeIndex_t>(___4703.m_zoneKMaxOrNumCorners[zone]), static_cast<___2716>(___4703.m_zoneIMaxOrNumNodes[zone])); } zoneMetadata.setZoneDimension(___4703.m_zoneDimension[zone]); zoneMetadata.setIsSZL(isupper(___4703.m_zoneTypes[zone]) ? true : false); zoneMetadata.setName(___4703.m_zoneNames[zone]); zoneMetadata.setFaceNeighborMode(static_cast<FaceNeighborMode_e>(___4703.m_zoneFaceNeighborModes[zone])); zoneMetadata.setSolutionTime(___4703.m_zoneSolutionTimes[zone]); zoneMetadata.setStrandID(___4703.m_zoneStrandIDs[zone]); zoneMetadata.setParentZone(targetBaseZoneOffset + ___4703.m_zoneParentZones[zone]); if (___4689 == ZoneType_FEMixed) { ItemAddress64::SectionOffset_t const numSections = static_cast<ItemAddress64::SectionOffset_t>(___4703.m_zoneNumSections[zone]); zoneMetadata.setSectionMetrics(numSections, ___3267<int64_t const>(___4703.m_zoneNumElemsPerSec[zone].data(),numSections,numSections), ___3267<uint8_t const>(___4703.m_zoneCellShapePerSec[zone].data(),numSections,numSections), ___3267<uint8_t const>(___4703.m_zoneGridOrderPerSec[zone].data(),numSections,numSections), ___3267<uint8_t const>(___4703.m_zoneCellBasisFuncPerSec[zone].data(),numSections,numSections)); } } namespace { ___372 readAuxDataItem( ___1397& file, ___4349           varOffset, ___4633          zoneOffset, ___230&             auxData) { uint8_t auxDataLocation = 0; uint32_t auxDataEntity = 0; uint32_t auxDataNameLength = 0; ___471 auxDataName; uint8_t auxDataType = 0; uint32_t auxDataValueLength = 0; ___471 auxDataValue; ___372 ___2037 = readValue<uint8_t, false>(file, auxDataLocation, IODescription(___252)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataEntity, IODescription(___239)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataNameLength, IODescription(___262)); ___2037 = ___2037 && (auxDataNameLength > 0); ___2037 = ___2037 && auxDataName.alloc(static_cast<uint64_t>(auxDataNameLength)); ___2037 = ___2037 && readString(file, auxDataNameLength, auxDataName, IODescription(___261)); ___2037 = ___2037 && readValue<uint8_t, false>(file, auxDataType, IODescription(___268)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataValueLength, IODescription(___272)); if (___2037 && auxDataValueLength > 0) { ___2037 = auxDataValue.alloc(static_cast<uint64_t>(auxDataValueLength)); ___2037 = ___2037 && readString(file, auxDataValueLength, auxDataValue, IODescription(___271)); } if (___2037) { try { AuxDataLocation_e location = static_cast<AuxDataLocation_e>(auxDataLocation); ___1170 entity = static_cast<___1170>(auxDataEntity); AuxDataType_e type = static_cast<AuxDataType_e>(auxDataType); ___476(type == ___270); if (location == ___258)
entity += varOffset; else if (location == ___259) entity += zoneOffset; std::string auxDataValueString; if (auxDataValueLength > 0) auxDataValueString = std::string(auxDataValue.data(), auxDataValueLength); auxData = ___230(std::string(auxDataName.data(), auxDataNameLength), auxDataValueString, location, entity, type); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading auxiliary data."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readAuxDataCount( ___1397& file, ___3943&         ___3942, uint32_t&            auxDataCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___241) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___241]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_AUX_DATA_MARKER, IODescription(SZPLT_AUX_DATA_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataCount, IODescription(___233)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readAuxData( ___1397& file, ___3943&         ___3942, ___4349           varOffset, ___4633          zoneOffset, uint32_t             auxDataOffset, AuxDataArray&        auxDataArray) { REQUIRE(file.___2039()); uint32_t  auxDataCount = 0; ___372 ___2037 = readAuxDataCount(file, ___3942, auxDataCount); for(uint32_t i = 0; ___2037 && i < auxDataCount; ++i) ___2037 = readAuxDataItem(file, varOffset, zoneOffset, auxDataArray[auxDataOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readGeomLineSegData( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2039()); REQUIRE(___1553.___2464 == GeomType_LineSegs); uint32_t ___2833; bool is3D = (___1553.___2614 == CoordSys_Grid3D);
 #if 0
std::vector<std::vector<class ___4577> > ___2462;
 #endif
___372 ___2037 = readValue<uint32_t, false>(file, ___2833, IODescription(___1621)); if (___2037) { try { ___1553.___2462.resize(static_cast<size_t>(___2833)); } catch(...) { ___2037 = ___1184("Out of memory while reading geometry data."); } } for(uint32_t segment = 0; ___2037 && segment < ___2833; ++segment) { uint32_t numPts = 0; ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2037 = ___2037 && readValue<uint32_t, false>(file, numPts, IODescription(___1620)) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2037 = ___2037 && zPts.alloc(static_cast<uint64_t>(numPts)); ___2037 = ___2037 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), xPts, IODescription(___1652)) && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), yPts, IODescription(___1654)); if (is3D) ___2037 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), zPts, IODescription(___1657)); for(uint32_t i = 0; ___2037 && i < numPts; ++i) { try { if (is3D) ___1553.___2462[segment].push_back(___4577(xPts[i], yPts[i], zPts[i])); else ___1553.___2462[segment].push_back(___4577(xPts[i], yPts[i], 0.0)); } catch(...) { ___2037 = ___1184("Out of memory while reading geometry data."); } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readGeometry( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<double, false>(file, ___1553.___2615[0], IODescription(___1651)) && readValue<double, false>(file, ___1553.___2615[1], IODescription(___1653)) && readValue<double, false>(file, ___1553.___2615[2], IODescription(___1656)); uint8_t ___3157 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___3157, IODescription(___1625)); ___1553.___2614 = static_cast<CoordSys_e>(___3157); uint8_t ___2002 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2002, IODescription(___1609)); ___1553.___2482 = static_cast<___372>(___2002); int32_t zone = 0; ___2037 = ___2037 && readValue<int32_t, false>(file, zone, IODescription(___1655)); ___1553.___2675 = static_cast<___1170>(zone); uint16_t color = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, color, IODescription(___1569)); ___1553.___2393 = static_cast<___514>(color); uint16_t ___1409 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___1409, IODescription(___1580)); ___1553.___2460 = static_cast<___514>(___1409); uint8_t ___2020 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2020, IODescription(___1610)); ___1553.___2484 = static_cast<___372>(___2020); uint8_t ___1649 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___1649, IODescription(GEOM_GEOM_TYPE)); ___1553.___2464 = static_cast<GeomType_e>(___1649); uint8_t ___2261 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2261, IODescription(___1611));
___1553.___2487 = static_cast<LinePattern_e>(___2261); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2613, IODescription(___1623)); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2488, IODescription(___1612)); ___2037 = ___2037 && readValue<uint16_t, false>(file, ___1553.___2500, IODescription(___1619)); uint8_t arrowheadStyle = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, arrowheadStyle, IODescription(___1567)); ___1553.___2341 = static_cast<ArrowheadStyle_e>(arrowheadStyle); uint8_t arrowheadAttachment = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, arrowheadAttachment, IODescription(___1561)); ___1553.___2339 = static_cast<ArrowheadAttachment_e>(arrowheadAttachment); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2340, IODescription(___1566)); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2338, IODescription(___1560)); uint8_t geomScope = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, geomScope, IODescription(___1631)); ___1553.___2617 = static_cast<Scope_e>(geomScope); uint8_t geomClipping = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, geomClipping, IODescription(GEOM_CLIPPING)); ___1553.___2392 = static_cast<Clipping_e>(geomClipping); uint32_t macroFunctionCommandLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, macroFunctionCommandLength, IODescription(___1614)); if (___2037 && macroFunctionCommandLength > 0) { try { ___471 ___2328; ___2037 = ___2037 && ___2328.alloc(static_cast<uint64_t>(macroFunctionCommandLength)) && readString(file, static_cast<size_t>(macroFunctionCommandLength), ___2328, IODescription(___1613)); if (___2037) ___1553.___2489 = std::string(___2328.data(), static_cast<size_t>(macroFunctionCommandLength)); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading geometries."); } } ___4577 basicGeomData; ___476(!basicGeomData.___2065()); switch (___1553.___2464) { case GeomType_LineSegs: { ___2037 = ___2037 && readGeomLineSegData(file, ___1553); } break; case GeomType_Rectangle: { double ___4455 = 0.0; double ___1824 = 0.0; ___2037 = ___2037 && readValue<double, false>(file, ___4455, IODescription(___1628)) && readValue<double, false>(file, ___1824, IODescription(___1627)); if (___2037) basicGeomData = ___4577(___4455, ___1824, 0.0); } break; case GeomType_Square: { double squareSize = 0.0; ___2037 = ___2037 && readValue<double, false>(file, squareSize, IODescription(___1647)); if (___2037) basicGeomData = ___4577(squareSize, 0.0, 0.0); } break; case GeomType_Circle: { double radius = 0.0; ___2037 = ___2037 && readValue<double, false>(file, radius, IODescription(___1606)); if (___2037) basicGeomData = ___4577(radius, 0.0, 0.0); } break; case GeomType_Ellipse: { double horizontalAxis = 0.0; double verticalAxis = 0.0;
___2037 = ___2037 && readValue<double, false>(file, horizontalAxis, IODescription(___1576)) && readValue<double, false>(file, verticalAxis, IODescription(___1577)); if (___2037) basicGeomData = ___4577(horizontalAxis, verticalAxis, 0.0); } break; default: ___476(___1303); break; } if (___2037 && basicGeomData.___2065()) { try { ___1553.___2462.resize(1); ___1553.___2462[0].push_back(basicGeomData); } catch(...) { ___2037 = ___1184("Out of memory reading square geometry."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readGeometriesCount( ___1397& file, ___3943&         ___3942, uint32_t&            geomCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___1579) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___1579]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_GEOMETRY_MARKER, IODescription(SZPLT_GEOMETRY_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, geomCount, IODescription(NUM_GEOMS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readGeometries( ___1397& file, ___3943&         ___3942, uint32_t             geomOffset, GeomArray&           geomArray) { REQUIRE(file.___2039()); uint32_t geomCount = 0; ___372 ___2037 = readGeometriesCount(file, ___3942, geomCount); for(uint32_t i = 0; ___2037 && i < geomCount; ++i) ___2037 = readGeometry(file, geomArray[geomOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readText( ___1397& file, Text&                ___4040) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<double, false>(file, ___4040.___2624[0], IODescription(___1651)) && readValue<double, false>(file, ___4040.___2624[1], IODescription(___1653)) && readValue<double, false>(file, ___4040.___2624[2], IODescription(___1656)); uint16_t ___4078 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4078, IODescription(___4080)); ___4040.___2632 = static_cast<___514>(___4078); uint16_t ___4057 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4057, IODescription(___4058)); ___4040.___2626 = static_cast<___514>(___4057); uint16_t ___4059 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4059, IODescription(___4060)); ___4040.___2627 = static_cast<___514>(___4059); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2628, IODescription(___4070)); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2629, IODescription(___4072)); uint8_t ___4076 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4076, IODescription(TEXT_BOX_TYPE)); ___4040.___2630 = static_cast<TextBox_e>(___4076); uint8_t ___4041 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4041, IODescription(___4042));
___4040.___2623 = static_cast<TextAnchor_e>(___4041); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2625, IODescription(___4055)); uint8_t ___4077 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4077, IODescription(TEXT_CLIPPING)); ___4040.___2631 = static_cast<Clipping_e>(___4077); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2633, IODescription(TEXT_HEIGHT)); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2635, IODescription(___4106)); uint8_t ___4113 = 0; ___2037 = ___2037 &&  readValue<uint8_t, false>(file, ___4113, IODescription(___4114)); ___4040.___2637 = static_cast<CoordSys_e>(___4113); uint8_t ___4117 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4117, IODescription(___4118)); ___4040.___2639 = static_cast<Scope_e>(___4117); uint8_t ___4122 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4122, IODescription(___4123)); ___4040.___2640 = static_cast<Units_e>(___4122); uint32_t textStringLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textStringLength, IODescription(___4126)); try { if (textStringLength > 0) { ___471 ___4124; ___2037 = ___2037 && ___4124.alloc(static_cast<size_t>(textStringLength)) && readString(file, static_cast<size_t>(textStringLength), ___4124, IODescription(___4125)); if (___2037) ___4040.___2641 = std::string(___4124.data(), static_cast<size_t>(textStringLength)); } uint32_t textTypefaceFamilyLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textTypefaceFamilyLength, IODescription(___4129)); if (___2037 && textTypefaceFamilyLength > 0) { ___471 ___4127; ___2037 = ___2037 && ___4127.alloc(static_cast<size_t>(textTypefaceFamilyLength)) && readString(file, static_cast<size_t>(textTypefaceFamilyLength), ___4127, IODescription(___4128)); if (___2037) ___4040.___2642 = std::string(___4127.data(), static_cast<size_t>(textTypefaceFamilyLength)); } uint8_t ___4130 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4130, IODescription(___4131)); ___4040.___2643 = static_cast<___372>(___4130); uint8_t ___4132 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4132, IODescription(___4133)); ___4040.___2644 = static_cast<___372>(___4132); int32_t ___4136 = 0; ___2037 = ___2037 && readValue<int32_t, false>(file, ___4136, IODescription(___4137)); ___4040.___2645 = static_cast<___1170>(___4136); uint8_t ___4103 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4103, IODescription(___4104)); ___4040.___2634 = static_cast<___372>(___4103); uint32_t textMacroFunctionCmdLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textMacroFunctionCmdLength, IODescription(___4109));
if (___2037 && textMacroFunctionCmdLength > 0) { ___471 ___4107; ___2037 = ___2037 && ___4107.alloc(static_cast<size_t>(textMacroFunctionCmdLength)) && readString(file, static_cast<size_t>(textMacroFunctionCmdLength), ___4107, IODescription(___4108)); if (___2037) ___4040.___2636 = std::string(___4107.data(), static_cast<size_t>(textMacroFunctionCmdLength)); } } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading text."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readTextsCount( ___1397& file, ___3943&         ___3942, uint32_t&            textCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___4081) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___4081]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_TEXT_MARKER, IODescription(SZPLT_TEXT_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, textCount, IODescription(NUM_TEXTS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readTexts( ___1397& file, ___3943&         ___3942, uint32_t             textOffset, TextArray&           textArray) { REQUIRE(file.___2039()); uint32_t textCount = 0; ___372 ___2037 = readTextsCount(file, ___3942, textCount); for(uint32_t i = 0; ___2037 && i < textCount; ++i) ___2037 = readText(file, textArray[textOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readCustomLabelSet( ___1397& file, CustomLabelSet&      customLabelSet) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<uint32_t, false>(file, customLabelSet.m_numLabels, IODescription(___2818)) && readStringArray(file, 0, size_t(customLabelSet.m_numLabels), customLabelSet.m_labels, IODescription(___792)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readCustomLabelsCount( ___1397& file, ___3943&         ___3942, uint32_t&            customLabelsCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___793) != ___3942.end()); ___372 ___2037 = ___4224; ___2037 = file.___3457(___3942[___793]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_CUSTOM_LABELS_MARKER, IODescription(SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, customLabelsCount, IODescription(___791)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readCustomLabels( ___1397& file, ___3943&         ___3942, uint32_t&            customLabelsOffset, CustomLabelsArray&   customLabelsArray) { REQUIRE(file.___2039()); uint32_t  customLabelsCount = 0; ___372 ___2037 = readCustomLabelsCount(file, ___3942, customLabelsCount); for(uint32_t i = 0; ___2037 && i < customLabelsCount; ++i) ___2037 = readCustomLabelSet(file, customLabelsArray[customLabelsOffset + i]);
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readZoneHeaderTags( ___1397& file, ___4633          expectedZone, ___3943&         ___3942) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(expectedZone>=0); if ( file.___2000() ) { ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_ZONE_MARKER, IODescription(SZPLT_ZONE_MARKER_DESCRIPTION)); ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedZone + 1), IODescription(SZPLT_ZONE_NUM_DESCRIPTION)); } ___3940 tagDescriptionMap = ___4686; ___2037 = ___2037 && readTagList(file, tagDescriptionMap, ___3942); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 checkArrayHeaderTag( uint16_t             tag, ___3943 const&   ___3942, IODescription const& ___970) { REQUIRE(!___970.isEmpty() && ___970.zone()!=IODescription::NO_ZONE); ___372 ___2037 = ___4224; ___3943::const_iterator iter = ___3942.find(tag); if ( iter == ___3942.end() ) { if ( ___970.___2975() == IODescription::NO_PARTITION ) ___2037 = ___1184("Missing zone header tag '%s' for zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.zone()+1)); else ___2037 = ___1184("Missing partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.___2975()+1), uint64_t(___970.zone()+1)); } else if ( iter->second == 0 || iter->second == ___330 ) { if ( ___970.___2975() == IODescription::NO_PARTITION ) ___2037 = ___1184("Invalid value for zone header tag '%s' for zone %" PRIu64, ___970.___2683(), uint64_t(___970.zone()+1)); else ___2037 = ___1184("Invalid value for partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.___2975()+1), uint64_t(___970.zone()+1)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 applyZoneHeaderScalarTagValues( ___3943&  ___3942, ZoneMetadata& zoneMetadata) { ___372 ___2037 = ___4224; try { zoneMetadata.m_nonSzZoneFileLocations.___2496 = (___3942[___2723] ? ___3942[___2723] : ___330); zoneMetadata.m_nonSzZoneFileLocations.___2661 = (___3942[USER_FACE_NBR_FILE_LOC_TAG] ? ___3942[USER_FACE_NBR_FILE_LOC_TAG] : ___330); ItemAddress64::___2978 const numPartitions = ItemAddress64::___2978(___3942[NUM_PARTITIONS_TAG]); zoneMetadata.setNumPartitions(numPartitions > 0 ? numPartitions : 1); } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while retrieving file tags."); } catch(...) { ___2037 = ___1184("Unrecoverable error while retrieving file tags."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template<typename T> ___372 readHeaderTagArray( ___1397&  file, ___3943&          ___3942, uint16_t              tagValue, size_t                ___2863,
size_t                numValues, ___2238<T>& valueArray, ___372           (*readValueArrayFunc)(___1397& file, size_t ___2863, size_t ___2793, ___2238<T>& valueArray, IODescription const& ___970), IODescription const&  ___970) { ___372 ___2037 = checkArrayHeaderTag(tagValue, ___3942, ___970); if ( ___2037 ) { ___1391 const fileLoc = ___3942[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2037 = file.___3457(fileLoc) && readValueArrayFunc(file, ___2863, numValues, valueArray, ___970); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readNonSZLZoneHeaderArrays( ___1397& file, ___3943&         ___3942, ___4349           numVarsInFile, ZoneMetadata&        zoneMetadata) { ___372 ___2037 = ___4224; REQUIRE(!zoneMetadata.isSZL()); ___4633 zone = zoneMetadata.zone(); try { ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, ___4339, 0, numVarsInFile, zoneMetadata.m_nonSzZoneFileLocations.___2671, readValueArray<uint64_t, true, 0>, IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone)); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } catch (...) { ___2037 = ___1184("Unrecoverable error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline uint64_t minMaxBlockSize(FieldDataType_e ___1361, ItemAddress64::SubzoneOffset_t numSubzones, bool ___2000) { REQUIRE(VALID_ENUM(___1361, FieldDataType_e)); switch (___1361) { case FieldDataType_Float: return arraySizeInFile<std::pair<float, float>, false >(numSubzones, ___2000); case FieldDataType_Double: return arraySizeInFile<std::pair<double, double>, false >(numSubzones, ___2000); case FieldDataType_Int32: return arraySizeInFile<std::pair<int32_t, int32_t>, false >(numSubzones, ___2000); case FieldDataType_Int16: return arraySizeInFile<std::pair<int16_t, int16_t>, false >(numSubzones, ___2000); case FieldDataType_Byte: case ___1363: return arraySizeInFile<std::pair<uint8_t, uint8_t>, false >(numSubzones, ___2000); default: ___476(___1303); return 0; } } } namespace { template<typename T> ___372 readSecHeaderTagArrays( ___1397&                           file, ___3943&                                   ___3942, uint16_t                                       tagValue, size_t                                         ___2863, size_t                                         ___2793, uint32_t                                       numSections, ___2238<___2238<T> >&      secValueArray, boost::function<___372( ___1397&  file, size_t                ___2863, size_t                ___2793, ___2238<T>& valueArray, IODescription const&  ___970)> const& readValueArrayFunc, IODescription const&                           ___970)
{ REQUIRE(readValueArrayFunc); REQUIRE(secValueArray.empty() || numSections == checked_numeric_cast<uint32_t>(secValueArray.size())); ___372 ___2037 = checkArrayHeaderTag(tagValue, ___3942, ___970); if (___2037 && secValueArray.empty()) ___2037 = secValueArray.alloc(numSections); if (___2037) { ___1391 const fileLoc = ___3942[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2037 = file.___3457(fileLoc); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) ___2037 = readValueArrayFunc(file, ___2863, ___2793, secValueArray[section], ___970); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template<typename T> ___372 readSecPtnHeaderTagArrays( ___1397&                                   file, ___3943&                                           ___3942, uint16_t                                               tagValue, size_t                                                 ___2863, ItemAddress64::___2978                             ___2975, uint32_t                                               numSections, ___2238<___2238<uint32_t> > const& secPtnNumCszs, boost::function<size_t(size_t count)> const&           numEntriesToReadFunc, ___2238<___2238<T> >&              secValueArray, boost::function<___372( ___1397&  file, size_t                ___2863, size_t                ___2793, ___2238<T>& valueArray, IODescription const&  ___970)> const&         readValueArrayFunc, IODescription const&                                   ___970) { REQUIRE(readValueArrayFunc); ___372 ___2037 = checkArrayHeaderTag(tagValue, ___3942, ___970); if (___2037 && secValueArray.empty()) ___2037 = secValueArray.alloc(numSections); if (___2037) { ___1391 const fileLoc = ___3942[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2037 = file.___3457(fileLoc); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) { size_t const ___2794 = numEntriesToReadFunc ? numEntriesToReadFunc(secPtnNumCszs[section][___2975]) : checked_numeric_cast<size_t>(secPtnNumCszs[section][___2975]); if (___2794 > 0) ___2037 = readValueArrayFunc(file, ___2863, ___2794, secValueArray[section], ___970); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readVarLocations( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4349                       varOffset, ___4349                       ___2841, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4633                      zone, ItemAddress64::___2978       ___2975, ___4379 const& vzFieldDataTypes) { ___372 ___2037 = readHeaderTagArray<uint64_t>( file, ___3942, ___4339, 0, ___2841, partitionMetadata.m_nszMinMaxFileLocs, readValueArray<uint64_t, true, 0>,
IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, zoneMetadata.getNumPartitions() == 1 ? IODescription::NO_PARTITION : ___2975)); ___2037 = ___2037 && partitionMetadata.m_cszMinMaxFileLocs.alloc(___2841); ___2037 = ___2037 && partitionMetadata.m_szDataStartFileLocs.alloc(___2841); if (___2037) { ItemAddress64::SectionOffset_t const numSections = zoneMetadata.getZoneType() == ZoneType_FEMixed ? zoneMetadata.numSections() : 1; for (___4349 ___4333 = 0; ___4333 < ___2841; ++___4333) { if (partitionMetadata.m_nszMinMaxFileLocs[___4333] != ___330) { size_t const nszMinMaxBlockSize = minMaxBlockSize( (FieldDataType_e)vzFieldDataTypes[varOffset + ___4333][zone], zoneMetadata.getNumNszsInPartition(___2975), ___1385.___2000() ? true : false); size_t cszMinMaxBlockSize = 0; for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) cszMinMaxBlockSize += minMaxBlockSize( (FieldDataType_e)vzFieldDataTypes[varOffset + ___4333][zone], zoneMetadata.getNumCszsInPartitionSection(___2975,section), ___1385.___2000() ? true : false); partitionMetadata.m_cszMinMaxFileLocs[___4333]   = partitionMetadata.m_nszMinMaxFileLocs[___4333] + nszMinMaxBlockSize; partitionMetadata.m_szDataStartFileLocs[___4333] = partitionMetadata.m_cszMinMaxFileLocs[___4333] + cszMinMaxBlockSize; } else { partitionMetadata.m_cszMinMaxFileLocs[___4333]   = ___330; partitionMetadata.m_szDataStartFileLocs[___4333] = ___330; } } } return ___2037; } } namespace { ___372 readSZLNonPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3943&              ___3942, ___4633               zoneOffset, ___4349                varOffset, ___4349                numVarsInFile, VarZoneMinMaxArray const& vzMinMax, ___4379 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2039()); REQUIRE(numVarsInFile>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+numVarsInFile) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()==1); ___4633 const zone = zoneMetadata.zone(); ___476(zoneMetadata.m_ptnFileNums.empty()); ___476(zoneMetadata.m_ptnHeaderFileLocs.empty()); ___372 ___2037 = ___4224; try { ___2037 = ___2037 && zoneMetadata.m_ptnNumNodes.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnFirstNode.alloc(1); if ( zoneMetadata.getZoneType() == ___4701 ) { ___2037 = ___2037 && zoneMetadata.m_ptnNodeMinIJKs.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(1); } ___2037 = ___2037 && zoneMetadata.m_ptnNumNszs.alloc(1); ItemAddress64::SectionOffset_t const numSections = zoneMetadata.numSections(); ___476(numSections >= 1); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCells.alloc(numSections); ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell.alloc(numSections); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs.alloc(numSections); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section)
{ ___2037 = ___2037 && zoneMetadata.m_secPtnNumCells[section].alloc(1); ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell[section].alloc(1); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs[section].alloc(1); } if ( ___2037 ) { ___2716 const ___2819 = zoneMetadata.___1766(); zoneMetadata.m_ptnNumNodes[0] = ___2819; zoneMetadata.m_ptnFirstNode[0] = 0; if ( zoneMetadata.getZoneType() == ___4701 ) { ___2037 = ___2037 && zoneMetadata.m_ijkZoneInfos.alloc(1); if (___2037) { ___476(numSections == 1); ___463 const ___2779 = zoneMetadata.___1764(); zoneMetadata.m_secPtnNumCells[0][0] = ___2779; zoneMetadata.m_secPtnFirstCell[0][0] = 0; zoneMetadata.m_ijkZoneInfos[0] = ___1879(zoneMetadata.getZoneIJK(), ___1385.___1755()); zoneMetadata.m_ptnNodeMinIJKs[0] = ___1842(0,0,0); zoneMetadata.m_ptnNodeMaxIJKs[0] = zoneMetadata.getZoneIJK()-1; zoneMetadata.m_secPtnNumCszs[0][0] = zoneMetadata.m_ijkZoneInfos[0].getNumCszs(); zoneMetadata.m_ptnNumNszs[0] = zoneMetadata.m_ijkZoneInfos[0].getNumNszs(); } } else { if (___1385.getFileVersion() > 105 && zoneMetadata.getZoneType() == ZoneType_FEMixed) { for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) zoneMetadata.m_secPtnNumCells[section][0] = zoneMetadata.numElems(section); } else { ___476(numSections == 1); ___463 const ___2779 = zoneMetadata.___1764(); zoneMetadata.m_secPtnNumCells[0][0] = ___2779; } for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) { zoneMetadata.m_secPtnNumCszs[section][0] = getNumSzFromNumItems(zoneMetadata.m_secPtnNumCells[section][0]); if (section == 0) zoneMetadata.m_secPtnFirstCell[section][0] = 0; else zoneMetadata.m_secPtnFirstCell[section][0] = checked_numeric_cast<___463>( zoneMetadata.m_secPtnFirstCell[section-1][0] + zoneMetadata.m_secPtnNumCells[section][0]); } zoneMetadata.m_ptnNumNszs[0] = getNumSzFromNumItems(___2819); } } ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxTrees.alloc(numVarsInFile); for ( ___4349 ___4333 = 0; ___2037 && ___4333 < numVarsInFile; ++___4333 ) zoneMetadata.m_varPtnMinMaxTrees[___4333].populateTreeFromMinMax(vzMinMax[varOffset + ___4333][zoneOffset + zone]); ___2037 = ___2037 && zoneMetadata.m_ptnMetadata.alloc(1); if ( ___2037 ) { PartitionMetadata& partitionMetadata = zoneMetadata.m_ptnMetadata[0]; ___2037 = readVarLocations( file, ___1385, ___3942, varOffset, numVarsInFile, zoneMetadata, partitionMetadata, zoneOffset+zone, 0 , vzFieldDataTypes); if ( ___2037 ) { if (___3892(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension()) && ___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2037 = ___2037 && readSecPtnHeaderTagArrays<uint64_t>( file, ___3942, CSZ_CONNECT_FILE_LOC_TAG, 0, 0 , zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL/*numEntriesToReadFunc*/, partitionMetadata.m_secCszConnectivityFileLocs, readValueArray<uint64_t, true, 0>,
IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, NSZ_CONNECT_FILE_LOC_TAG, 0, zoneMetadata.m_ptnNumNszs[0], partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___1385.getFileVersion() > 104) { ___2037 = ___2037 && readSecPtnHeaderTagArrays<uint16_t>( file, ___3942, NUM_REF_NODE_SUBZONES_TAG, 0, 0 , zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL/*numEntriesToReadFunc*/, partitionMetadata.m_secCszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_CELL_SUBZONES_TAG, 0, zoneMetadata.m_ptnNumNszs[0], partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); } } else { ___2037 = ((___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && (___3942.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && IMPLICATION(___1385.getFileVersion() > 105 && zoneMetadata.getZoneType() == ZoneType_FEMixed, (___3942.find(PARTITION_NUM_CELLS_TAG) != ___3942.end() && ___3942.find(PARTITION_NUM_CELLS_TAG)->second == ___330)) && IMPLICATION(___1385.getFileVersion() > 104, (___3942.find(NUM_REF_NODE_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330) && (___3942.find(NUM_REF_CELL_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330))); if (!___2037) ___1184("Connectivity integrity error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } } } else { throw std::bad_alloc(); } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2037 ) { zoneMetadata.m_secPtnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_secPtnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_secPtnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935(); zoneMetadata.m_ptnMetadata.___935(); } ENSURE(zoneMetadata.m_ptnFileNums.empty()); ENSURE(zoneMetadata.m_ptnHeaderFileLocs.empty()); ENSURE(zoneMetadata.m_varPtnMinMaxFileLocs.empty()); ENSURE(IMPLICATION(___2037, !zoneMetadata.m_secPtnNumCells.empty() && zoneMetadata.m_secPtnNumCells[0].size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnNumCells.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNodes.size()==1));
ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(___2037, !zoneMetadata.m_secPtnFirstCell.empty() && zoneMetadata.m_secPtnFirstCell[0].size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnFirstCell.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnFirstNode.size() == 1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(___2037, !zoneMetadata.m_secPtnNumCszs.empty() && zoneMetadata.m_secPtnNumCszs[0].size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnNumCszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNszs.size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(numVarsInFile))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxTrees.empty())); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readSZLPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3943&              ___3942, ___4633               zoneOffset, ___4349                varOffset, ___4349                ___2841, VarZoneMinMaxArray const& ASSERT_ONLY(vzMinMax), ___4379 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2039()); REQUIRE(___2841>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+___2841) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()>1); ___372 ___2037 = ___4224; ___4633 const zone = zoneMetadata.zone(); ItemAddress64::___2978 const numPartitions = zoneMetadata.getNumPartitions(); try { ___2037 = ___2037 && zoneMetadata.m_ptnMetadata.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNumNszs.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnFirstNode.alloc(numPartitions); ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, PARTITION_FILE_NUM_TAG, 0, numPartitions, zoneMetadata.m_ptnFileNums, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_FILE_NUM_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_FILE_LOC_TAG, 0, numPartitions, zoneMetadata.m_ptnHeaderFileLocs, readValueArray<uint64_t, true, 0>, IODescription(PARTITION_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___3892(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())) { ItemAddress64::SectionOffset_t const numSections = zoneMetadata.getZoneType() == ZoneType_FEMixed ? zoneMetadata.numSections() : 1; ___476(IMPLICATION(numSections > 1, ___1385.getFileVersion() > 105)); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCells.alloc(numSections); ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell.alloc(numSections); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs.alloc(numSections); if (___1385.getFileVersion() < 232) { ___2238<___2238<uint32_t>> secPtnNumCells_uint32;
___2037 = ___2037 && readSecHeaderTagArrays<uint32_t>( file, ___3942, PARTITION_NUM_CELLS_TAG, 0, numPartitions, numSections, secPtnNumCells_uint32, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_CELLS_DESCRIPTION, IODescription::NO_VAR, zone)); for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) { ___2037 = zoneMetadata.m_secPtnNumCells[section].alloc(numPartitions); for (ItemAddress64::___2978 ptn = 0; ___2037 && ptn < numPartitions; ++ptn) zoneMetadata.m_secPtnNumCells[section][ptn] = secPtnNumCells_uint32[section][ptn]; } } else { ___2037 = ___2037 && readSecHeaderTagArrays<int64_t>( file, ___3942, PARTITION_NUM_CELLS_TAG, 0, numPartitions, numSections, zoneMetadata.m_secPtnNumCells, readValueArray<int64_t, false, 0>, IODescription(PARTITION_NUM_CELLS_DESCRIPTION, IODescription::NO_VAR, zone)); } ___463 totalNumCells = 0; for (ItemAddress64::___2978 ___2975 = 0; ___2037 && ___2975 < numPartitions; ++___2975) { for (ItemAddress64::SectionOffset_t section = 0; ___2037 && section < numSections; ++section) { if (___2975 == 0) { ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell[section].alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs[section].alloc(numPartitions); } if (___2037) { zoneMetadata.m_secPtnNumCszs[section][___2975] = getNumSzFromNumItems(zoneMetadata.m_secPtnNumCells[section][___2975]); zoneMetadata.m_secPtnFirstCell[section][___2975] = totalNumCells; totalNumCells += zoneMetadata.m_secPtnNumCells[section][___2975]; } } } ___2037 = ___2037 && zoneMetadata.m_ptnNumNodes.alloc(numPartitions); if (___1385.getFileVersion() < 232) { ___2238<uint32_t> ptnNumNodes_uint32; ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, PARTITION_NUM_NODES_TAG, 0, numPartitions, ptnNumNodes_uint32, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_NODES_DESCRIPTION, IODescription::NO_VAR, zone)); for (ItemAddress64::___2978 ptn = 0; ___2037 && ptn < numPartitions; ++ptn) zoneMetadata.m_ptnNumNodes[ptn] = ptnNumNodes_uint32[ptn]; } else { ___2037 = ___2037 && readHeaderTagArray<int64_t>( file, ___3942, PARTITION_NUM_NODES_TAG, 0, numPartitions, zoneMetadata.m_ptnNumNodes, readValueArray<int64_t, false, 0>, IODescription(PARTITION_NUM_NODES_DESCRIPTION, IODescription::NO_VAR, zone)); } if ( ___2037 ) { ___2716 totalNumNodes = 0; for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { ___2716 const ___2819 = zoneMetadata.m_ptnNumNodes[___2975]; zoneMetadata.m_ptnNumNszs[___2975] = getNumSzFromNumItems(___2819); zoneMetadata.m_ptnFirstNode[___2975] = totalNumNodes; totalNumNodes += ___2819; } if ( totalNumNodes != zoneMetadata.___1766() ) ___2037 = ___1184("Mismatch of number of nodes between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone+1)); } } else { ___476(supportedOrderedVolumeZoneType(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())); ___476(zoneMetadata.m_ptnNumNodes.empty());
___2037 = ___2037 && zoneMetadata.m_secPtnNumCells.alloc(1); ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell.alloc(1); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs.alloc(1); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCells[0].alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_secPtnFirstCell[0].alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_secPtnNumCszs[0].alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNumNodes.alloc(numPartitions); ___2238<uint64_t> ptnMinNodeNumbers; ___2238<uint64_t> ptnMaxNodeNumbers; ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_MIN_NODE_NUMBERS_TAG, 0, numPartitions, ptnMinNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MIN_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_MAX_NODE_NUMBERS_TAG, 0, numPartitions, ptnMaxNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MAX_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2037 = ___2037 && zoneMetadata.m_ijkZoneInfos.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMinIJKs.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(numPartitions); if (___2037) { ___463 totalNumCells = 0; ___2716 totalNumNodes = 0; for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ___2975++) { zoneMetadata.m_ptnNodeMinIJKs[___2975] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMinNodeNumbers[___2975])); zoneMetadata.m_ptnNodeMaxIJKs[___2975] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMaxNodeNumbers[___2975])); ___1842 nodeDimensionIJK = zoneMetadata.m_ptnNodeMaxIJKs[___2975] - zoneMetadata.m_ptnNodeMinIJKs[___2975] + 1; IJKSubzoneInfo nodeSubzoneInfo(nodeDimensionIJK, ___1385.___1755(), ___2975, true  ); ___1842 cellDimensionIJK = nodeDimensionIJK; if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].i() == zoneMetadata.getZoneIJK().i() - 1) cellDimensionIJK.setI(nodeDimensionIJK.i() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].___2103() == zoneMetadata.getZoneIJK().___2103() - 1) cellDimensionIJK.setJ(nodeDimensionIJK.___2103() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].___2132() == zoneMetadata.getZoneIJK().___2132() - 1) cellDimensionIJK.___3495(nodeDimensionIJK.___2132() - 1); IJKSubzoneInfo cellSubzoneInfo(cellDimensionIJK, ___1385.___1755(), ___2975, true); zoneMetadata.m_ijkZoneInfos[___2975] = ___1879(___2975, nodeSubzoneInfo, cellSubzoneInfo); zoneMetadata.m_secPtnNumCells[0][___2975] = zoneMetadata.m_ijkZoneInfos[___2975].___1764(); zoneMetadata.m_secPtnFirstCell[0][___2975] = totalNumCells; totalNumCells += zoneMetadata.m_secPtnNumCells[0][___2975]; zoneMetadata.m_secPtnNumCszs[0][___2975] = zoneMetadata.m_ijkZoneInfos[___2975].getNumCszs(); zoneMetadata.m_ptnNumNodes[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].___1766(); zoneMetadata.m_ptnFirstNode[___2975] = totalNumNodes;
totalNumNodes += zoneMetadata.m_ptnNumNodes[___2975]; zoneMetadata.m_ptnNumNszs[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].getNumNszs(); zoneMetadata.addPartitionTreeItem(___2975, zoneMetadata.m_ptnNodeMinIJKs[___2975], zoneMetadata.m_ptnNodeMaxIJKs[___2975]); } if (totalNumCells != zoneMetadata.___1764()) ___2037 = ___1184("Mismatched of number of cells between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); else if (totalNumNodes != zoneMetadata.___1766()) ___2037 = ___1184("Mismatched of number of nodes between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); } ptnMinNodeNumbers.___935(); ptnMaxNodeNumbers.___935(); } ___2037 = ___2037 && checkArrayHeaderTag(VAR_PARTITION_MIN_MAX_TAG, ___3942, IODescription(VAR_PARTITION_MIN_MAX_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxFileLocs.alloc(___2841, ___330); ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxTrees.alloc(___2841); if ( ___2037 ) { size_t const headerSize = file.___2000() ? ___206 + ASCII_SPACING_LEN : 0 ; ___1391 fileLoc = ___3942[VAR_PARTITION_MIN_MAX_TAG]; zoneMetadata.m_varPtnMinMaxFileLocs[0] = fileLoc; for ( ___4349 ___4333 = 1; ___4333 < ___2841; ++___4333 ) { size_t sizePerMinMax; switch ((FieldDataType_e)vzFieldDataTypes[varOffset + ___4333][zoneOffset + zone]) { case FieldDataType_Float: sizePerMinMax = file.___2000() ? ASCII_FLOAT_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(float); break; case FieldDataType_Double: sizePerMinMax = file.___2000() ? ASCII_DOUBLE_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(double); break; case FieldDataType_Int32: sizePerMinMax = file.___2000() ? ASCII_INT32_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int32_t); break; case FieldDataType_Int16: sizePerMinMax = file.___2000() ? ASCII_INT16_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int16_t); break; case FieldDataType_Byte: case ___1363: sizePerMinMax = file.___2000() ? ASCII_UINT8_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(uint8_t); break; default: ___476(___1303); sizePerMinMax = 0; break; } fileLoc += headerSize + numPartitions * sizePerMinMax; zoneMetadata.m_varPtnMinMaxFileLocs[___4333] = fileLoc; } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2037 ) { zoneMetadata.m_ptnFileNums.___935(); zoneMetadata.m_ptnHeaderFileLocs.___935(); zoneMetadata.m_secPtnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_secPtnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_secPtnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_ptnNodeMinIJKs.___935(); zoneMetadata.m_ptnNodeMaxIJKs.___935(); zoneMetadata.m_varPtnMinMaxFileLocs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935();
} ENSURE(VALID_BOOLEAN(___2037)); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnFileNums.size()==size_t(numPartitions))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFileNums.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnHeaderFileLocs.size()==size_t(numPartitions) && zoneMetadata.m_ptnHeaderFileLocs[0] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions/2] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions-1] != ___330)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnHeaderFileLocs.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnNumCells.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnFirstCell.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNodeMinIJKs.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNodeMaxIJKs.empty())); if (___3892(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())) { ENSURE(IMPLICATION(___2037, zoneMetadata.m_secPtnNumCells[0].size() == size_t(numPartitions))); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNodes.size() == size_t(numPartitions))); } else { ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions))); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions) && zoneMetadata.m_ptnNodeMaxIJKs[0].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions / 2].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions - 1].blockSize() > 0)); } ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_secPtnNumCszs[0].size() == size_t(numPartitions))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_secPtnNumCszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNszs.size()==size_t(numPartitions) && zoneMetadata.m_ptnNumNszs[0] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions/2] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions-1] > 0)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxFileLocs.size() == size_t(___2841) && zoneMetadata.m_varPtnMinMaxFileLocs[0] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2841/2] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2841-1] != ___330)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxFileLocs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(___2841))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxTrees.empty())); return ___2037; } } ___372 readZoneHeaders( ___1397&             file, ___1386 const&           ___1385, ___4633                      zoneOffset, ___4633                      expectedZone, ___4349                       varOffset, ___4349                       numFileVars, VarZoneMinMaxArray const&        vzMinMax, ___4379 const& vzFieldDataType,
ZoneMetadata&                    zoneMetadata) { ___3943 ___3942; ___372 ___2037 = readZoneHeaderTags(file, expectedZone, ___3942); ___2037 = ___2037 && applyZoneHeaderScalarTagValues(___3942, zoneMetadata); if (zoneMetadata.isSZL()) { if (___2037) { if (zoneMetadata.getNumPartitions() == 1) { ___2037 = ___2037 && readSZLNonPartitionedZoneHeaderArrays( file, ___1385, ___3942, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } else { ___2037 = ___2037 && readSZLPartitionedZoneHeaderArrays( file, ___1385, ___3942, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } } ___476(IMPLICATION(___2037 && zoneMetadata.getZoneType() == ___4701, !zoneMetadata.m_ijkZoneInfos.empty())); } else { ___2037 = ___2037 && readNonSZLZoneHeaderArrays( file, ___3942, numFileVars, zoneMetadata); } return ___2037; } namespace { ___372 readUserFaceNeighborHeader( ___1397& file, ___4633          expectedZone) { REQUIRE(expectedZone >= 0); REQUIRE(file.___2000()); ___372 ___2037 = (readAndVerifyValue<uint32_t, false>( file, SZPLT_USER_FACE_NEIGHBOR_MARKER, IODescription(SZPLT_USER_FACE_NEIGHBOR_MARKER_DESCRIPTION)) && readAndVerifyValue<uint32_t, false>( file, expectedZone + 1, IODescription(SZPLT_ZONE_NUM_DESCRIPTION))); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readFaceNeighbors( ___1397& file, ___4633          expectedZone, uint64_t&            numValues, ___1963&          ___4297) { ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = readUserFaceNeighborHeader(file, expectedZone); ___2037 = ___2037 && readValue<uint64_t, false>(file, numValues, IODescription(SZPLT_USER_FACE_NEIGHBORS_COUNT_DESCRIPTION)); if (numValues) ___2037 = ___2037 && readValueArray<int32_t, false, 0>(file, 0, numValues, ___4297, IODescription(SZPLT_USER_FACE_NEIGHBORS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readPartitionHeaderTags( ___1397&       file, ___4633                expectedZone, ItemAddress64::___2978 expectedPartition, ___3943&               ___3942) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(expectedZone>=0); if ( file.___2000() ) { ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_PARTITION_MARKER, IODescription(SZPLT_PARTITION_MARKER_DESCRIPTION)); ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedPartition + 1), IODescription(SZPLT_PARTITION_NUM_DESCRIPTION, IODescription::NO_VAR, expectedZone)); } static ___3940 tagDescriptionMap = PARTITION_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2037 = ___2037 && readTagList(file, tagDescriptionMap, ___3942); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 applyPartitionHeaderScalarTagValues( ___3943&       ___3942, PartitionMetadata& partitionMetadata) { ___372 ___2037 = ___4224; if ( ___2037 ) { try { partitionMetadata.m_numRefPartitions = ItemAddress64::___2978(___3942[NUM_REF_PARTITIONS_TAG]);
} catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while retrieving partition tags."); } catch(...) { ___2037 = ___1184("Unrecoverable error while retrieving partition tags."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readOrderedPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4349                       varOffset, ___4349                       ___2841, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4633                      zone, ItemAddress64::___2978       ___2975, ___4379 const& vzFieldDataTypes) { REQUIRE(file.___2039()); REQUIRE(___2841>0); REQUIRE(zone >= 0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); ___372 ___2037 = readVarLocations( file, ___1385, ___3942, varOffset, ___2841, zoneMetadata, partitionMetadata, zone, ___2975, vzFieldDataTypes); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readFEPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4349                       varOffset, ___4349                       ___2841, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4633                      zone, ItemAddress64::___2978       ___2975, ___4379 const& vzFieldDataTypes) { REQUIRE(file.___2039()); REQUIRE(___1385.getFileVersion() > 104); REQUIRE(___2841>0); REQUIRE(zone>=0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); ___372 ___2037 = ___4224; try { if (___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2037 = ___2037 && readSecPtnHeaderTagArrays<uint64_t>( file, ___3942, CSZ_CONNECT_FILE_LOC_TAG, 0, ___2975, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL , partitionMetadata.m_secCszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, NSZ_CONNECT_FILE_LOC_TAG, 0, zoneMetadata.m_ptnNumNszs[___2975], partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); } else { ___476(___3942.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330); ___476(___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330); } } ___2037 = ___2037 && readVarLocations( file, ___1385, ___3942, varOffset, ___2841, zoneMetadata, partitionMetadata, zone, ___2975, vzFieldDataTypes);
if (___3942[NUM_REF_PARTITIONS_TAG] > 0) ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, REF_PARTITIONS_TAG, 0, partitionMetadata.m_numRefPartitions, partitionMetadata.m_refPartitions, readValueArray<uint32_t, false, 0>, IODescription(REF_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); if (___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { if (___2037 && partitionMetadata.m_secCszNumRefNszs.empty()) ___2037 = partitionMetadata.m_secCszNumRefNszs.alloc(zoneMetadata.numSections()); ___2037 = ___2037 && readSecPtnHeaderTagArrays<uint16_t>( file, ___3942, NUM_REF_NODE_SUBZONES_TAG, 0, ___2975, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL , partitionMetadata.m_secCszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_CELL_SUBZONES_TAG, 0, zoneMetadata.m_ptnNumNszs[___2975], partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); if (___2037 && partitionMetadata.m_secCszIncludesPtn.empty()) ___2037 = partitionMetadata.m_secCszIncludesPtn.alloc(zoneMetadata.numSections()); ___2037 = ___2037 && readSecPtnHeaderTagArrays<uint8_t>( file, ___3942, CELL_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, ___2975, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, numBytesForNumBits, partitionMetadata.m_secCszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(CELL_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint8_t>( file, ___3942, NODE_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, numBytesForNumBits(zoneMetadata.m_ptnNumNszs[___2975]), partitionMetadata.m_nszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(NODE_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); } else { ___476(___3942.find(NUM_REF_NODE_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330); ___476(___3942.find(NUM_REF_CELL_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330); ___476(___3942.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3942.end() && ___3942.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330); ___476(___3942.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3942.end() && ___3942.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330); } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2975+1), uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2975+1), uint64_t(zone+1));
} if ( !___2037 ) { partitionMetadata.m_nszConnectivityFileLocs.___935(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readPartitionHeader( ___1397&             file, ___1386 const&           ___1385, ___4349                       numFileVars, ___4349                       targetBaseVarOffset, ___4633                      fileInfoZoneOffset, ItemAddress64::___2978       ___2975, ZoneMetadata const&              zoneMetadata, ___4379 const& vzFieldDataType, PartitionMetadata&               partitionMetadata) { ___3943 ___3942; ___372 ___2037 = readPartitionHeaderTags(file, fileInfoZoneOffset, ___2975, ___3942); ___2037 = ___2037 && applyPartitionHeaderScalarTagValues(___3942, partitionMetadata); if (zoneMetadata.getZoneType() == ___4701) ___2037 = ___2037 && readOrderedPartitionHeaderArrays( file, ___1385, ___3942, targetBaseVarOffset, numFileVars, zoneMetadata, partitionMetadata, fileInfoZoneOffset, ___2975, vzFieldDataType); else ___2037 = ___2037 && readFEPartitionHeaderArrays( file, ___1385, ___3942, targetBaseVarOffset, numFileVars, zoneMetadata, partitionMetadata, fileInfoZoneOffset, ___2975, vzFieldDataType); return ___2037; } namespace { template <typename ARRAY_TYPE> ___372 readCompressedRefSzAddresses( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4689, ItemAddress64::___2978     numRefPtns, ItemAddress64::___2978     curPartition, PartitionArray const&          refPartitions, ARRAY_TYPE&                    refPtnOffsets, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription) { REQUIRE(fileWrapper.___2039()); REQUIRE(numRefPtns != 1); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(VALID_REF(refSubzoneAddresses) && "refSubzoneAddresses size is numRefSzs"); REQUIRE(szConnectRefIODescription.___2065()); ___372 ___2037 = ___4224; ___476(sizeof(ItemAddress64::SubzoneAddress) == sizeof(uint64_t)); ___476(sizeof(ItemAddress64::SubzoneOffset_t) == sizeof(uint32_t)); ItemAddress64::SubzoneOffset_t* const szOffsetArray = reinterpret_cast<ItemAddress64::SubzoneOffset_t*>(refSubzoneAddresses); ___2037 = ___2037 && readValues<uint32_t, false, 1>(fileWrapper, numRefSzs, szOffsetArray, szConnectRefIODescription); if (___2037) { BitArray<ItemAddress64::SectionOffset_t,4> refCszSec4BitOffsets(numRefSzs, 0); if (areRefCellSzs && fileVersion > 105 && ___4689 == ZoneType_FEMixed) { ___2037 = readValues<uint8_t, false, 0>(fileWrapper, refCszSec4BitOffsets.byteSize(), refCszSec4BitOffsets.data(), szConnectRefIODescription); } if ( ___2037 ) { for (RefSubzoneOffset_t ___2863 = 0; ___2863 < numRefSzs; ++___2863) { RefSubzoneOffset_t const refSzOffset = numRefSzs-___2863-1; ___476(refSzOffset < numRefSzs); ItemAddress64::___2978 const ___2975 = numRefPtns == 0
? curPartition : refPartitions[refPtnOffsets[refSzOffset]]; refSubzoneAddresses[refSzOffset] = ItemAddress64::SubzoneAddress( ___2975, refCszSec4BitOffsets[refSzOffset], szOffsetArray[refSzOffset]); } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template <size_t COMPRESSED_OFFSET_BIT_SIZE> ___372 readCompressedRefSzAddressesForBitSize( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4689, ItemAddress64::___2978     numRefPtns, ItemAddress64::___2978     curPartition, PartitionArray const&          refPartitions, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription, IODescription const&           szConnectRefPtnIODescription) { REQUIRE(COMPRESSED_OFFSET_BIT_SIZE == 2 || COMPRESSED_OFFSET_BIT_SIZE == 4 || COMPRESSED_OFFSET_BIT_SIZE == 8); size_t numBytesForRefPtnOffsets = BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE>::byteArraySize(numRefSzs); static size_t const MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS = 1024; uint8_t  stackRefPtnOffsets[MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS]; uint8_t* refPtnOffsetsByteArray = numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS ? (uint8_t*)malloc(numBytesForRefPtnOffsets) : stackRefPtnOffsets; ___372 ___2037 = ___4224; BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE> refPtnOffsets(refPtnOffsetsByteArray,numRefSzs); if (numRefPtns > 0) ___2037 = ___2037 && readValues<uint8_t, true, 0>( fileWrapper, refPtnOffsets.byteSize(), refPtnOffsets.data(), szConnectRefPtnIODescription); ___2037 = ___2037 && readCompressedRefSzAddresses(fileWrapper, fileVersion, ___4689, numRefPtns, curPartition, refPartitions, refPtnOffsets, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription); if (numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS) free(refPtnOffsetsByteArray); return ___2037; } } namespace { ___372 readCompressedRefSzAddresses( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4689, ItemAddress64::___2978     numRefPtns, ItemAddress64::___2978     curPartition, PartitionArray const&          refPartitions, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription) { REQUIRE(fileWrapper.___2039()); REQUIRE(numRefPtns != 1); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(VALID_REF(refSubzoneAddresses) && "refSubzoneAddresses size is numRefSzs"); REQUIRE(szConnectRefIODescription.___2065()); ___372 ___2037 = ___4224; if (numRefPtns <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION) { ___2037 = readCompressedRefSzAddressesForBitSize<2>(fileWrapper, fileVersion, ___4689, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription,
IODescription(SZ_CONNECT_REF_PTN_OFFSET_2BIT_ARRAY_DESCRIPTION)); } else if (numRefPtns <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION) { ___2037 = readCompressedRefSzAddressesForBitSize<4>(fileWrapper, fileVersion, ___4689, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription, IODescription(SZ_CONNECT_REF_PTN_OFFSET_4BIT_ARRAY_DESCRIPTION)); } else if (numRefPtns <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION) { ___2037 = readCompressedRefSzAddressesForBitSize<8>(fileWrapper, fileVersion, ___4689, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription, IODescription(SZ_CONNECT_REF_PTN_OFFSET_8BIT_ARRAY_DESCRIPTION)); } else { size_t const numRefPtnOffsets = numRefPtns > 0 ? numRefSzs : 0; static size_t const MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS = 1024; uint16_t stackRefPtnOffsets[MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS]; uint16_t* refPtnOffsetsArray = numRefPtnOffsets > MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS ? (uint16_t*)malloc(numRefPtnOffsets*sizeof(uint16_t)) : stackRefPtnOffsets; if (refPtnOffsetsArray != NULL) { ___3267<uint16_t> refPtnOffsets(refPtnOffsetsArray, numRefSzs, numRefSzs); if (numRefPtns > 0) ___2037 = ___2037 && readValues<uint16_t, true, 0>( fileWrapper, numRefSzs, refPtnOffsets.data(), IODescription(SZ_CONNECT_REF_PTN_OFFSET_16BIT_ARRAY_DESCRIPTION)); ___2037 = ___2037 && readCompressedRefSzAddresses(fileWrapper, fileVersion, ___4689, numRefPtns, curPartition, refPartitions, refPtnOffsets, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription); if (numRefPtnOffsets > MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS) free(refPtnOffsetsArray); } else { ___2037 = ___1184("Cannot allocate memory for reading referenced subzone addresses"); } } return ___2037; } } namespace { template <size_t COMPRESSED_OFFSET_BIT_SIZE> ___372 readCompressedConnectivity( ___1397&         fileWrapper, ___1386 const&       ___1385, uint32_t                     ___2793, IODescription const&         ___970, CszConnectivity&             cszConnectivity) { ___372 ___2037 = ___4224; BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE> rszOffsetsBitArray(___2793); if (COMPRESSED_OFFSET_BIT_SIZE > 2 && ___1385.getFileVersion() == 104 ) ___2037 = readValues<uint8_t, false, 0>(fileWrapper, rszOffsetsBitArray.byteSize(), rszOffsetsBitArray.data(), ___970); else ___2037 = readValues<uint8_t, true, 0>(fileWrapper, rszOffsetsBitArray.byteSize(), rszOffsetsBitArray.data(), ___970); uint16_t* const rszOffsetArray = cszConnectivity.getRszOffsetArray(); for (size_t ___2863 = 0; ___2037 && ___2863 < rszOffsetsBitArray.size(); ++___2863) rszOffsetArray[___2863] = rszOffsetsBitArray[___2863]; return ___2037; } } ___372 readCszConnectivity( ___1397&           fileWrapper, ___1386 const&         ___1385, ZoneMetadata const&            zoneMetadata, ItemAddress64::___2978     ___2975, ItemAddress64::SectionOffset_t section,
ItemAddress64::SubzoneOffset_t cszOffset, CszConnectivity&               cszConnectivity) { REQUIRE(fileWrapper.___2039()); REQUIRE(cszConnectivity.empty()); RefSubzoneOffset_t numRefNszs; if (___1385.getFileVersion() == 104) numRefNszs = 0; else numRefNszs = zoneMetadata.m_ptnMetadata[___2975].m_secCszNumRefNszs[section][cszOffset]; ItemAddress64::___2978 numRefPtns; if (zoneMetadata.m_ptnMetadata[___2975].m_secCszIncludesPtn.empty() || zoneMetadata.m_ptnMetadata[___2975].m_secCszIncludesPtn[section].empty()) { ___476(zoneMetadata.getNumPartitions() == 1); ___476(___2975 == 0); numRefPtns = 0; } else { ___476(___1385.getFileVersion() > 104); if (bitValue(zoneMetadata.m_ptnMetadata[___2975].m_secCszIncludesPtn[section], cszOffset)) numRefPtns = zoneMetadata.m_ptnMetadata[___2975].m_numRefPartitions; else numRefPtns = 0; } PartitionArray emptyPartitionList; PartitionArray const& refPartitions = (numRefPtns == 0) ? emptyPartitionList : zoneMetadata.m_ptnMetadata[___2975].m_refPartitions; ___476(refPartitions.size() == size_t(numRefPtns)); ItemAddress64::ItemOffset_t ___2779; if (cszOffset + 1 == zoneMetadata.getNumCszsInPartitionSection(___2975, section)) ___2779 = ItemAddress64::ItemOffset_t(((zoneMetadata.m_secPtnNumCells[section][___2975] - 1)&ItemAddress64::MAX_ITEM_OFFSET) + 1); else ___2779 = ItemAddress64::MAX_ITEM_OFFSET + 1; uint32_t const numNodesPerCell = uint32_t(zoneMetadata.getNumNodesPerCell(section)); uint32_t const ___2793 = uint32_t(___2779) * numNodesPerCell; ___372 ___2037 = ___4224; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValue<uint16_t, false>(fileWrapper, numRefNszs, IODescription(CSZ_CONNECT_NUM_REF_NSZ)); if ( ___2037 && ( numRefNszs == 0 || numRefNszs > ___2793 ) ) ___2037 = ___1184("Bad value for %s.", CSZ_CONNECT_NUM_REF_NSZ); if ( ___2037 && !cszConnectivity.alloc(___2779, numNodesPerCell, numRefNszs) ) ___2037 = ___1184("Cannot allocate memory for cell connectivity (%" PRIu64 " entries, %" PRIu64 " ref subzones).", uint64_t(___2793), uint64_t(numRefNszs)); ___2037 = ___2037 && readCompressedRefSzAddresses( fileWrapper, ___1385.getFileVersion(), zoneMetadata.getZoneType(), numRefPtns, ___2975, refPartitions, numRefNszs, false , cszConnectivity.getRefNszArray(), IODescription(CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION)); if ( ___2037 ) { if ( numRefNszs <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION && ___1385.getFileVersion() > 104 ) { ___2037 = readCompressedConnectivity<2>(fileWrapper, ___1385, ___2793, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION), cszConnectivity); } else if ( numRefNszs <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) { ___2037 = readCompressedConnectivity<4>(fileWrapper, ___1385, ___2793, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION), cszConnectivity); } else if ( numRefNszs <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) { ___2037 = readCompressedConnectivity<8>(fileWrapper, ___1385, ___2793, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION), cszConnectivity);
} else { uint16_t* const rszOffsetArray = cszConnectivity.getRszOffsetArray(); if ( ___1385.getFileVersion() == 104 ) ___2037 = readValues<uint16_t, false, 0>(fileWrapper, ___2793, rszOffsetArray, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); else ___2037 = readValues<uint16_t, true, 0>(fileWrapper, ___2793, rszOffsetArray, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); } } if ( ___2037 ) { uint8_t* offsetArray = cszConnectivity.getItemOffsetArray(); ___2037 = readValues<uint8_t, false, 0>(fileWrapper, ___2793, offsetArray, IODescription(CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readNszConnectivity( ___1397&       fileWrapper, ___1386 const&     ___1385, ZoneMetadata const&        zoneMetadata, ItemAddress64::___2978 numRefPtns, ItemAddress64::___2978 ___2975, PartitionArray const&      refPartitions, RefSubzoneOffset_t         numRefCszs, NszConnectivity&           nszConnectivity) { REQUIRE(fileWrapper.___2039()); REQUIRE(IMPLICATION(___1385.getFileVersion() == 104, numRefPtns == 0)); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(___1385.getFileVersion() == 104 ? numRefCszs == 0 : numRefCszs>=0); REQUIRE(nszConnectivity.empty()); ___372 ___2037 = ___4224; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValue<uint16_t, false>(fileWrapper, numRefCszs, IODescription(NSZ_CONNECT_NUM_REF_CSZ)); if ( ___2037 && !nszConnectivity.setNumRszs(numRefCszs) ) ___2037 = ___1184("Cannot allocate memory for node connectivity referenced cell subzones (%" PRIu64 " subzones).", uint64_t(numRefCszs)); if ( ___2037 && numRefCszs > 0 ) ___2037 = ___2037 && readCompressedRefSzAddresses( fileWrapper, ___1385.getFileVersion(), zoneMetadata.getZoneType(), numRefPtns, ___2975, refPartitions, numRefCszs, true , &nszConnectivity.m_refCszs[0], IODescription(NSZ_CONNECT_REF_CSZS)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
