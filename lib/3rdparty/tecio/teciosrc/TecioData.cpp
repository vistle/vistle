#include "TecioData.h"
#include "ThirdPartyHeadersBegin.h"
#include <numeric>
#include <sstream>
#include <boost/assign.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/bind/bind.hpp>
#include <boost/foreach.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "FieldData_s.h"
#include "RawArray.h"
using namespace tecplot::___3931; struct ___1291 { }; namespace tecplot { namespace tecioszl { ___3968::___3968() {} ___3968::___3968( std::string const& ___4175, std::string const& ___4347, int32_t            defaultVarType) : ___2647(___4175) , m_defaultVarType(defaultVarType) , m_nextZoneIndex(0) , m_lastZoneFlushedToDisk(-1) , ___2397(new AuxData_s) { if (!VALID_ENUM((FieldDataType_e)defaultVarType, FieldDataType_e)) { std::ostringstream ___2890; ___2890 << "Invalid default variable type: " << defaultVarType; throw std::runtime_error(___2890.str()); } char const* ___3473; if (___4347.find_first_of('\n') != std::string::npos) ___3473 = "\n"; else if (___4347.find_first_of(',') != std::string::npos) ___3473 = ","; else ___3473 = " "; std::string trimmedVariables(___4347); boost::trim_if(trimmedVariables, boost::is_any_of(___3473)); boost::split(___2672, trimmedVariables, boost::is_any_of(___3473), boost::token_compress_on); for (std::vector<std::string>::iterator ___2683 = ___2672.begin(); ___2683 != ___2672.end(); ++___2683) { boost::trim(*___2683); ___2670.push_back(boost::make_shared<AuxData_s>()); } } ___3968::~___3968() { } void ___3968::___19( char    const* ___4687, int32_t const  ___4689, int64_t const  ___1907, int64_t const  ___2114, int64_t const  ___2159, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, double  const  ___3638, int32_t const  ___3783, int32_t const  ___2972, int64_t const  ___2800, int32_t const  ___1282, int64_t const  ___4190, int64_t const  ___2784, int64_t const  ___4186, int32_t const* varTypes, int32_t const* ___2980, int32_t const* ___4323, int32_t const* ___3549, int32_t const  ___3547) { REQUIRE(VALID_REF(___4687) && strlen(___4687) > 0); REQUIRE(0 <= ___4689 && ___4689 < 9); REQUIRE(0 < ___1907); REQUIRE(0 < ___2114); REQUIRE(IMPLICATION(___4689 == 0 || ___4689 == 6 || ___4689 == 7, 0 < ___2159)); REQUIRE(IMPLICATION(___4689 == 8, VALID_REF(cellShapePerSection) && VALID_REF(numElementsPerSection))); REQUIRE(0 <= ___3783); REQUIRE(0 <= ___2972); REQUIRE(0 <= ___2800); REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); REQUIRE(0 <= ___4190); REQUIRE(0 <= ___2784); REQUIRE(0 <= ___4186); REQUIRE(VALID_REF_OR_NULL(varTypes)); REQUIRE(VALID_REF_OR_NULL(___2980)); REQUIRE(VALID_REF_OR_NULL(___4323)); REQUIRE(VALID_REF_OR_NULL(___3549)); REQUIRE(0 <= ___3547); ZoneType_e tecplotZoneTypes[] = { ___4701, ___4693, ___4699, ___4697, ___4698, ___4692,
___4695, ___4696, ZoneType_FEMixed }; REQUIRE(0 <= ___4689 && ___4689 < (int)(sizeof(tecplotZoneTypes) / sizeof(tecplotZoneTypes[0]))); ZoneType_e tecplotZoneType = tecplotZoneTypes[___4689]; if (tecplotZoneType == ___4695 || tecplotZoneType == ___4696) throw Error("Polygon and Polyhedral zone types are currently not supported by SZL files."); FECellShape_e tecplotFECellShapes[] = { FECellShape_Bar, FECellShape_Triangle, FECellShape_Quadrilateral, FECellShape_Tetrahedron, FECellShape_Hexahedron, FECellShape_Pyramid, FECellShape_Prism }; FECellBasisFunction_e tecplotFECellBasisFunctions[] = { FECellBasisFunction_Lagrangian }; std::vector<FECellShape_e> cellShapesVector; std::vector<int32_t> gridOrdersVector; std::vector<FECellBasisFunction_e> basisFnsVector; std::vector<int64_t> numElementsPerSectionVector; if (tecplotZoneType == ZoneType_FEMixed) { try { for (int32_t section=0; section<numSections; ++section) { REQUIRE(0 <= cellShapePerSection[section] && cellShapePerSection[section] < (int)(sizeof(tecplotFECellShapes) / sizeof(tecplotFECellShapes[0]))); REQUIRE(numElementsPerSection[section] > 0); cellShapesVector.push_back(tecplotFECellShapes[cellShapePerSection[section]]); numElementsPerSectionVector.push_back(numElementsPerSection[section]); if (gridOrderPerSection != NULL) { REQUIRE(gridOrderPerSection[section] > 0); gridOrdersVector.push_back(gridOrderPerSection[section]); } else { gridOrdersVector.push_back(1); } if (basisFnPerSection != NULL) { REQUIRE(tecplotFECellBasisFunctions[basisFnPerSection[section]] == FECellBasisFunction_Lagrangian); basisFnsVector.push_back(tecplotFECellBasisFunctions[basisFnPerSection[section]]); } else { basisFnsVector.push_back(FECellBasisFunction_Lagrangian); } } } catch (std::bad_alloc const&) { std::cerr << "Out of memory while processing FEMixed section information\n"; throw; } }
 #if !defined TECIOMPI 
if (___3547 > 0 && m_zoneMap.find(static_cast<___4633>(___3547 - 1)) == m_zoneMap.end()) { try { std::ostringstream ostream; ostream << "Invalid zone specified for nodemap sharing.\n" "Specified non-existent zone " << ___3547 << "."; throw Error(ostream.str()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while attempting to report:" << std::endl << "Invalid zone specified for nodemap sharing." << std::endl << "Specified non-existent zone " << ___3547 << "." << std::endl; throw; } }
 #endif
std::vector<FieldDataType_e> fieldDataTypeVector; try { if (varTypes) { std::map<int32_t, FieldDataType_e> varTypeMap = boost::assign::map_list_of<int32_t, FieldDataType_e> (1, FieldDataType_Float) (2, FieldDataType_Double) (3, FieldDataType_Int32) (4, FieldDataType_Int16) (5, FieldDataType_Byte); for (size_t i = 0; i < ___2672.size(); ++i) { if (varTypeMap.find(varTypes[i]) == varTypeMap.end()) { std::ostringstream ___2890; ___2890 << "Invalid variable type for variable " << i + 1 << ": " << varTypes[i]; throw Error(___2890.str()); } fieldDataTypeVector.push_back(varTypeMap[varTypes[i]]); } } else { fieldDataTypeVector.assign(___2672.size(), (FieldDataType_e)m_defaultVarType); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2672.size() << " zone variable types." << std::endl; throw; } std::vector<int> passiveVarVector; try { for(size_t ___4289 = 0; ___4289 < ___2672.size(); ++___4289) { if (___2980 && ___2980[___4289] != 0) passiveVarVector.push_back(1); else passiveVarVector.push_back(0); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2672.size() << " zone passive variables." << std::endl; throw; } std::vector<ValueLocation_e> valueLocationVector; try { for(size_t ___4289 = 0; ___4289 < ___2672.size(); ++___4289) { if (___4323) valueLocationVector.push_back(static_cast<ValueLocation_e>(___4323[___4289])); else valueLocationVector.push_back(___4327); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2672.size() << " zone variable locations." << std::endl; throw; } std::vector<int> shareVarFromZoneVector; try { for(size_t ___4289 = 0; ___4289 < ___2672.size(); ++___4289) { if (___3549 && ___3549[___4289] != 0) {
 #if !defined TECIOMPI 
if (m_zoneMap.find(static_cast<___4633>(___3549[___4289] - 1)) == m_zoneMap.end()) { try { std::ostringstream ostream; ostream << "Invalid zone specified for variable sharing.\n" "Specified non-existent zone " << ___3549[___4289] << " for variable " << ___4289 << "."; throw Error(ostream.str()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while attempting to report:" << std::endl << "Invalid zone specified for variable sharing." << std::endl << "Specified non-existent zone " << ___3549[___4289] << " for variable " << ___4289 << "." << std::endl; throw; } } else
 #endif
{ shareVarFromZoneVector.push_back(___3549[___4289]); } } else { shareVarFromZoneVector.push_back(0); } } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2672.size() << " zone variable sharing settings." << std::endl; throw; } size_t titleLength = strlen(___4687); if (titleLength > (size_t)___2356) { titleLength = ___2356; std::cerr << "Warning: Zone title too long, truncating to " << titleLength << " chars." << std::endl; } std::string zoneTitleString; try { zoneTitleString.assign(___4687, titleLength); } catch(std::bad_alloc const&) { std::cerr << "Out of memory while processing zone title string." << std::endl; throw; } Zone_s* zone = NULL; try { zone = new Zone_s( zoneTitleString, tecplotZoneType, 1, 1, 1, ___1907, ___2114, ___2159, cellShapesVector, gridOrdersVector, basisFnsVector, numElementsPerSectionVector, ___3638, ___3783, static_cast<___1170>(___2972), ___2800, static_cast<FaceNeighborMode_e>(___1282), ___4190, ___2784, ___4186, fieldDataTypeVector, passiveVarVector, valueLocationVector, shareVarFromZoneVector, ___3547); } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while creating container to store zone settings." << std::endl; throw; } try { m_zoneMap[m_nextZoneIndex] = boost::shared_ptr<Zone_s>(zone); } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while storing zone settings." << std::endl; throw; } ++m_nextZoneIndex; } void ___3968::renumberZones(std::vector<int32_t> const& zoneNumbers) { INVARIANT(IMPLICATION(!m_zoneMap.empty(), m_nextZoneIndex > 0)); REQUIRE(zoneNumbers.size() == unflushedZoneSet().size()); std::set<___3491> zonesToRenumber = unflushedZoneSet(); size_t ind = zoneNumbers.size() - 1; BOOST_REVERSE_FOREACH(___3491 oldZoneNumber, zonesToRenumber) { int32_t newZoneNumber = zoneNumbers[ind]; ___476(newZoneNumber >= oldZoneNumber); if (newZoneNumber > oldZoneNumber) { m_zoneMap[static_cast<___4633>(newZoneNumber - 1)] = m_zoneMap[static_cast<___4633>(oldZoneNumber - 1)]; m_zoneMap.erase(static_cast<___4633>(oldZoneNumber - 1)); } --ind; } m_lastZoneFlushedToDisk = zoneNumbers[0] - 2; m_nextZoneIndex = zoneNumbers.back(); } void ___3968::dropLastZone() { INVARIANT(IMPLICATION(!m_zoneMap.empty(), m_nextZoneIndex > 0)); REQUIRE(!m_zoneMap.empty()); REQUIRE(m_nextZoneIndex > 0); ___4633 newestZoneIndex = m_nextZoneIndex - 1; REQUIRE(m_zoneMap.rbegin()->first == newestZoneIndex); m_zoneMap.erase(newestZoneIndex); } void ___3968::setPartitionOwners(std::vector<int> const& partitionOwners) { if (!m_zoneMap.rbegin()->second->m_partitionOwners.empty()) throw Error("Must be called only once, by only the main process, immediately after TECZNE."); m_zoneMap.rbegin()->second->m_partitionOwners = partitionOwners; } Zone_s* ___3968::getAndCheckZonePtr(int32_t zone) const { Zone_s::ZoneMap::const_iterator iter = m_zoneMap.find(static_cast<___4633>(zone - 1));
if (iter == m_zoneMap.end()) { std::ostringstream ___2890; ___2890 << "Specified non-existent zone " << zone << "."; throw Error(___2890.str()); } Zone_s* zonePtr = iter->second.get(); for (size_t i = 0; i < zonePtr->___2494.size(); ++i) { if (zonePtr->___2494[i]->storedValueCount() != 0) { std::ostringstream ___2890; ___2890 << "Called out-of-order (after caching data to the zone) for zone " << zone << "." << std::endl; ___2890 << "If the zone is partitioned, you must add a partition before calling TECDAT or TECNOD."; throw Error(___2890.str()); } } return zonePtr; } template <typename T> void ___3968::addFEZonePartition( int32_t                                 zone, int32_t                                 ___2975, int64_t                                 ___2819, tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<T const>       const& gnodes, tecplot::___3267<int32_t const> const& gnpartitions, tecplot::___3267<T const>       const& gnpnodes, tecplot::___3267<int64_t const> const& numGhostCellsPerSection, tecplot::___3267<T const>       const& gcells) { Zone_s* zonePtr = getAndCheckZonePtr(zone); ___4633 numPartitionsMPI = static_cast<___4633>(zonePtr->m_partitionOwners.size()); for(size_t i = 0; i < gnodes.size(); ++i) { if (gnodes[i] < 1 || ___2819 < gnodes[i]) { std::ostringstream ___2890; ___2890 << "Invalid ghost node (" << gnodes[i] << ") at position " << i + 1 << " in the ghost node list for partition " << ___2975 << " of zone " << zone << "." << std::endl; throw Error(___2890.str()); } if (gnpartitions[i] < 1 || (numPartitionsMPI > 0 && numPartitionsMPI < gnpartitions[i])) { std::ostringstream ___2890; ___2890 << "Invalid ghost node partition (" << gnpartitions[i] << ") at position " << i + 1 << " in the ghost node partition list for partition " << ___2975 << " of zone " << zone << "." << std::endl; throw Error(___2890.str()); } if (gnpnodes[i] < 1) { std::ostringstream ___2890; ___2890 << "Invalid ghost node partition node (" << gnpnodes[i] << ") at position " << i + 1 << " in the ghost node partition node list for partition " << ___2975 << " of zone " << zone << "." << std::endl; throw Error(___2890.str()); } } size_t baseOffset = 0; for (size_t section = 0; section < numGhostCellsPerSection.size(); ++section) { for (size_t i = 0; i < static_cast<size_t>(numGhostCellsPerSection[section]); ++i) { ___476(baseOffset+i < gcells.size()); if (gcells[baseOffset+i] < 1 || numCellsPerSection[section] < gcells[baseOffset+i]) { std::ostringstream ___2890; ___2890 << "Invalid ghost cell (" << gcells[i] << ") at position " << i + 1 << " in the ghost cell list for partition " << ___2975 << " of zone " << zone << "." << std::endl; throw Error(___2890.str()); } } baseOffset += static_cast<size_t>(numGhostCellsPerSection[section]); } int64_t const numCellsInPartition = std::accumulate(numCellsPerSection.begin(), numCellsPerSection.end(), int64_t(0));
boost::shared_ptr<Zone_s> newPartition = boost::shared_ptr<Zone_s>(new Zone_s( zonePtr->___2681, zonePtr->___2682, 1, 1, 1, ___2819, numCellsInPartition, zonePtr->___2680.___1667(), zonePtr->m_cellShapes, zonePtr->m_gridOrders, zonePtr->m_basisFns, std::vector<int64_t>(numCellsPerSection.begin(),numCellsPerSection.end()), zonePtr->___2619, zonePtr->___2620, zonePtr->___2612, 0, zonePtr->___2456, 0, 0, 0, zonePtr->___2458, zonePtr->m_passiveVars, zonePtr->___2668, zonePtr->m_shareVarFromZone, zonePtr->m_shareConnectivityFromZone)); for (size_t i = 0; i < zonePtr->m_shareVarFromZone.size(); ++i) { ___1170 shareZone = zonePtr->m_shareVarFromZone[i]; if (shareZone) { Zone_s* shareZonePtr = getAndCheckZonePtr(shareZone); if (shareZonePtr->m_partitionMap.empty() || shareZonePtr->m_partitionMap.find(___2975 - 1) == shareZonePtr->m_partitionMap.end()) { std::ostringstream ___2890; ___2890 << "Error in var share list for zone " << zone << " partition " << ___2975 << ": var " << i + 1 << " attempting to share with incompatible zone " << shareZone << "." << std::endl; throw Error(___2890.str()); } } } if (zonePtr->m_shareConnectivityFromZone) { Zone_s* shareZonePtr = getAndCheckZonePtr(zonePtr->m_shareConnectivityFromZone); if (shareZonePtr->m_partitionMap.empty() || shareZonePtr->m_partitionMap.find(___2975 - 1) == shareZonePtr->m_partitionMap.end()) { std::ostringstream ___2890; ___2890 << "Error in sharing connectivity for zone " << zone << " partition " << ___2975 << ": attempting to share with incompatible zone " << zonePtr->m_shareConnectivityFromZone << "." << std::endl; throw Error(___2890.str()); } } try { newPartition->m_ghostNodeInfo = GhostInfo_s(gnodes, gnpartitions, gnpnodes); } catch(std::exception const& e) { std::ostringstream ___2890; ___2890 << "Error in ghost node list for zone " << zone << " partition " << ___2975 << ": " << e.what(); throw Error(___2890.str()); } try { newPartition->m_ghostCellInfo = GhostInfo_s(numGhostCellsPerSection, gcells); } catch(std::exception const& e) { std::ostringstream ___2890; ___2890 << "Error in ghost cell list for zone " << zone << " partition " << ___2975 << ": " << e.what(); throw Error(___2890.str()); } zonePtr->m_partitionMap[___2975 - 1] = newPartition; } template void ___3968::addFEZonePartition<int32_t>( int32_t                                 zone, int32_t                                 ___2975, int64_t                                 ___2819, tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<int32_t const> const& gnodes, tecplot::___3267<int32_t const> const& gnpartitions, tecplot::___3267<int32_t const> const& gnpnodes, tecplot::___3267<int64_t const> const& numGhostCellsPerSection, tecplot::___3267<int32_t const> const& gcells); template void ___3968::addFEZonePartition<int64_t>( int32_t                                 zone,
int32_t                                 ___2975, int64_t                                 ___2819, tecplot::___3267<int64_t const> const& numCellsPerSection, tecplot::___3267<int64_t const> const& gnodes, tecplot::___3267<int32_t const> const& gnpartitions, tecplot::___3267<int64_t const> const& gnpnodes, tecplot::___3267<int64_t const> const& numGhostCellsPerSection, tecplot::___3267<int64_t const> const& gcells); namespace { void throwIfInvalidIndex(char const* indexName, int64_t value, int64_t maxValue) { if (value > maxValue) { std::ostringstream ___2890; ___2890 << "Invalid value for " << indexName << ": " << value << ". Max value is " << maxValue << "."; throw ___3968::Error(___2890.str()); } } } void ___3968::addIJKZonePartition(int32_t zone, int32_t ___2975, int64_t iMin, int64_t jMin, int64_t kMin, int64_t iMax, int64_t jMax, int64_t kMax) { REQUIRE(iMax > iMin && iMin > 0); REQUIRE(jMax > jMin && jMin > 0); REQUIRE(kMax > kMin && kMin > 0); Zone_s* zonePtr = getAndCheckZonePtr(zone); throwIfInvalidIndex("IMax", iMax, zonePtr->___2680.i());; throwIfInvalidIndex("JMax", jMax, zonePtr->___2680.___2103());; throwIfInvalidIndex("KMax", kMax, zonePtr->___2680.___2132());; zonePtr->m_partitionMap[___2975 - 1] = boost::make_shared<Zone_s>(zonePtr, iMin, jMin, kMin, iMax, jMax, kMax); } void ___3968::___8(std::string const& ___2683, std::string const& value) { ___2397->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4224, ___2683, value)); } void ___3968::___20(int32_t zone, std::string const& ___2683, std::string const& value) { REQUIRE(m_zoneMap.find(static_cast<___4633>(zone - 1)) != m_zoneMap.end()); m_zoneMap[zone - 1]->___2343->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4224, ___2683, value)); } void ___3968::___18(int32_t ___4333, std::string const& ___2683, std::string const& value) { REQUIRE(0 < ___4333 && ___4333 <= static_cast<___4349>(___2672.size())); ___2670[___4333 - 1]->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4224, ___2683, value)); } void ___3968::___6(std::vector<std::string> const& ___2171) { ___2396.push_back(___2171); } void ___3968::___9( double ___4571, double ___4588, double ___4712, CoordSys_e ___3157, ___372 ___2002, ___1170 zone, ___514 color, ___514 ___1409, ___372 ___2020, GeomType_e ___1649, LinePattern_e ___2261, double ___2984, double ___2287, uint16_t ___2791, ArrowheadStyle_e arrowheadStyle, ArrowheadAttachment_e arrowheadAttachment, double arrowheadSize, double arrowheadAngle, Scope_e ___3440, Clipping_e ___493, ___2225 ___2833, ___2225 const* ___2835, float const* ___4569, float const* ___4586, float const* ___4709, char const* ___2325) { REQUIRE(VALID_ENUM(___3157, CoordSys_e)); REQUIRE(VALID_BOOLEAN(___2002)); REQUIRE(___1418 <= color && color <= ___2193);
REQUIRE(___1418 <= ___1409 && ___1409 <= ___2193); REQUIRE(VALID_BOOLEAN(___2020)); REQUIRE(VALID_ENUM(___1649, GeomType_e)); REQUIRE(VALID_ENUM(___2261, LinePattern_e)); REQUIRE(VALID_ENUM(arrowheadStyle, ArrowheadStyle_e)); REQUIRE(VALID_ENUM(arrowheadAttachment, ArrowheadAttachment_e)); REQUIRE(VALID_ENUM(___3440, Scope_e)); REQUIRE(VALID_ENUM(___493, Clipping_e)); REQUIRE(VALID_REF(___2835)); REQUIRE(VALID_REF(___4569)); REQUIRE(IMPLICATION(___1649 != GeomType_Circle && ___1649 != GeomType_Square, VALID_REF(___4586))); REQUIRE(IMPLICATION( ___1649 == GeomType_LineSegs3D || (___1649 == GeomType_LineSegs && ___3157 == CoordSys_Grid3D), VALID_REF(___4709))); REQUIRE(VALID_REF_OR_NULL(___2325)); std::vector<std::vector<___4577> > ___1570; if (___1649 == ___1586) { ___1649 = GeomType_LineSegs; ___3157 = CoordSys_Grid3D; } switch(___1649) { case GeomType_LineSegs: { ___1570.resize(static_cast<size_t>(___2833)); int index = 0; for(___2225 i = 0; i < ___2833; ++i) { for(___2225 ___2103 = 0; ___2103 < ___2835[i]; ++___2103) { if (___3157 == CoordSys_Grid3D) ___1570[i].push_back(___4577(___4569[index], ___4586[index], ___4709[index])); else ___1570[i].push_back(___4577(___4569[index], ___4586[index], 0.0)); ++index; } } } break; case GeomType_Rectangle: case GeomType_Ellipse: ___1570.resize(1); ___1570[0].push_back(___4577(___4569[0], ___4586[0], 0.0)); break; case GeomType_Square: case GeomType_Circle: ___1570.resize(1); ___1570[0].push_back(___4577(___4569[0], 0.0, 0.0)); break; default: ___476(___1303); break; } ___2463.push_back(tecioszl::___1554( ___4571, ___4588, ___4712, ___3157, ___2002, zone, color, ___1409, ___2020, ___1649, ___2261, ___2984, ___2287, ___2791, arrowheadStyle, arrowheadAttachment, arrowheadSize, arrowheadAngle, ___3440, ___493, ___1570, ___2325 != NULL ? ___2325 : "")); } void ___3968::___9(tecioszl::___1554 const& ___1553) { ___2463.push_back(___1553); } void ___3968::___16( double ___4571, double ___4588, double ___4710, CoordSys_e ___3157, ___372 ___2002, ___1170 zone, Font_e ___1441, Units_e ___1450, double ___1448, TextBox_e ___410, double ___408, double ___406, ___514 ___402, ___514 ___404, double ___56, TextAnchor_e ___38, double ___2285, ___514 ___4078, Scope_e ___3440, Clipping_e ___493, char const* ___4040, char const* ___2325) { REQUIRE(VALID_ENUM(___3157, CoordSys_e)); REQUIRE(VALID_BOOLEAN(___2002)); REQUIRE(VALID_ENUM(___1441, Font_e) && ___1441 != ___1446); REQUIRE(VALID_ENUM(___1450, Units_e)); REQUIRE(___1448 > 0.0); REQUIRE(VALID_ENUM(___410, TextBox_e)); REQUIRE(0.0 <= ___408 && ___408 <= 100.0); REQUIRE(0.0001 <= ___406 && ___406 <= 100.0); REQUIRE(___1418 <= ___402 && ___402 <= ___2193); REQUIRE(___1418 <= ___404 && ___404 <= ___2193);
REQUIRE(VALID_ENUM(___38, TextAnchor_e)); REQUIRE(___2285 > 0.0); REQUIRE(___1418 <= ___4078 && ___4078 <= ___2193); REQUIRE(VALID_ENUM(___3440, Scope_e)); REQUIRE(VALID_ENUM(___493, Clipping_e)); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF_OR_NULL(___2325)); std::map<Font_e, std::string> textTypefaceFamilies = boost::assign::map_list_of<Font_e, std::string> (___1452,           "Helvetica") (___1453,       "Helvetica") (Font_HelveticaItalic,     "Helvetica") (Font_HelveticaItalicBold, "Helvetica") (___1447,               "Greek") (___1457,                "Math") (___1468,         "User Defined") (___1464,               "Times") (___1466,         "Times") (___1465,           "Times") (___1467,     "Times") (___1443,             "Courier") (___1444,         "Courier") (Font_CourierItalic,       "Courier") (Font_CourierItalicBold,   "Courier"); ___372 ___4130 = (___1441 == ___1453         || ___1441 == Font_HelveticaItalicBold   || ___1441 == ___1465             || ___1441 == ___1467       || ___1441 == ___1444           || ___1441 == Font_CourierItalicBold); ___372 ___4132 = (___1441 == ___1466         || ___1441 == ___1467     || ___1441 == Font_HelveticaItalic     || ___1441 == Font_HelveticaItalicBold || ___1441 == Font_CourierItalic       || ___1441 == Font_CourierItalicBold); ___2638.push_back(tecioszl::Text( ___4571, ___4588, ___4710, ___402, ___404, ___406, ___408, ___410, ___38, ___56, ___493, ___4078, ___1448, ___2285, ___2325 != NULL ? ___2325 : "", ___3157, ___3440, ___1450, ___4040, textTypefaceFamilies[___1441], ___4130, ___4132, zone, ___2002)); } void ___3968::___16(tecioszl::Text const& ___4040) { ___2638.push_back(___4040); } void ___3968::___429(___2225 count, void const* data, bool ___2011) { if (m_zoneMap.empty()) throw Error("No zones have been defined."); boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; if (zone->___2395 < zone->___2494.size() && zone->___2494[zone->___2395]->storedValueCount() == 0) { zone->___2494[zone->___2395]-> reserveValues(zone->___2494[zone->___2395]->___2666); } for(___2225 i = 0; i < count; ++i) { if (zone->___2395 >= zone->___2494.size()) throw Error("Too many data values for this zone."); double d; if (___2011) d = ((double const*)data)[i]; else d = static_cast<double>(((float const*)data)[i]); ___1360& ___1349 = *zone->___2494[zone->___2395]; ___1349.appendValue(d); if (zone->___2682 == ___4701 && ___1349.___2667 == ___4325) { padCCValuesIfNecessary(___1349, zone->___2680.i(), zone->___2680.___2103(), zone->___2680.___2132());
} if (zone->___2494[zone->___2395]->storedValueCount() == zone->___2494[zone->___2395]->___2666) { do { zone->___2395++; } while (zone->___2395 < zone->___2494.size() && zone->___2494[zone->___2395]->storedValueCount() == zone->___2494[zone->___2395]->___2666); if (zone->___2395 < zone->___2494.size()) zone->___2494[zone->___2395]->reserveValues( zone->___2494[zone->___2395]->___2666); } } } void ___3968::___431(___2225 count, int32_t const* ___2721) { boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; if (count + zone->___2495->storedValueCount() > zone->___2495->expectedValueCount()) throw Error("Too many node map values for this zone."); for (___2225 i = 0; i < count; ++i) { if (((int64_t)___2721[i] > zone->___2680.i()) || (___2721[i] < 1)) { std::ostringstream ___2890; ___2890 << "Err: (TECNODE142) Invalid node map value at position " << i << std::endl << "     node map value = " << ___2721[i] << ", max value = " << zone->___2680.i() << "."; throw ___3968::Error(___2890.str()); } zone->___2495->appendValue(___2721[i] - 1); } } namespace { void throwIf(bool doThrow, char const* ___2430, ___2225 value) { if (doThrow) { std::ostringstream ostream; ostream << ___2430 << value << "."; throw ___3968::Error(ostream.str()); } } } template <typename T> void ___3968::___430(Zone_s* zonePtr, T const* faceNeighbors) { ___2225 cellCount; ___2225 faceCount = 0; if (zonePtr->___2682 == ___4701) { cellCount = zonePtr->___2680.i() * zonePtr->___2680.___2103() * (zonePtr->___2680.___2132() - 1); int nDimensions = 0; if (zonePtr->___2680.i() > 1) ++nDimensions; if (zonePtr->___2680.___2103() > 1) ++nDimensions; if (zonePtr->___2680.___2132() > 1) ++nDimensions; if (nDimensions == 3) faceCount = 6; else if (nDimensions == 2) faceCount = 4; else faceCount = 0; } else { cellCount = zonePtr->___2680.___2103(); faceCount = zonePtr->___2680.___2132(); } ___2225 currentConnection = 0; ___2225 index = 0; while (currentConnection < zonePtr->___2501) { Zone_s::___456 ___455; ___455.first = (___1170)faceNeighbors[index++]; throwIf(___455.first < 1 || cellCount < ___455.first, "Invalid cell number in face connections: ", ___455.first); ___455.second = faceNeighbors[index++]; throwIf(___455.second < 1 || faceCount < ___455.second, "Invalid face number in face connections: ", ___455.second); Zone_s::___1273& ___1272 = zonePtr->___2455[___455]; ___2225 numNeighbors = 1; if (zonePtr->___2456 == ___1287 || zonePtr->___2456 == ___1284) { ___2225 isObscured = faceNeighbors[index++]; throwIf(isObscured != 0 && isObscured != 1, "Invalid face obscuration flag in face connections: ", isObscured);
___1272.___2486 = (isObscured == 1 ? ___4224 : ___1303); numNeighbors = faceNeighbors[index++]; throwIf(numNeighbors < 0, "Invalid number of neighbors in face connections: ", numNeighbors); } else { ___1272.___2486 = ___4224; } for(___2225 whichNeighbor = 0; whichNeighbor < numNeighbors; ++whichNeighbor) { Zone_s::___4604 zoneCell; if (zonePtr->___2456 == ___1285 || zonePtr->___2456 == ___1284) zoneCell.first = static_cast<___1170>(faceNeighbors[index++]); else zoneCell.first = 0; throwIf(zoneCell.first < 0, "Invalid neighbor zone in face connections: ", (___2225)zoneCell.first); zoneCell.second = faceNeighbors[index++]; throwIf(zoneCell.second < 0, "Invalid neighbor cell in face connections: ", zoneCell.second); ___1272.___2676.push_back(zoneCell); } ++currentConnection; } } template void ___3968::___430<int32_t>(Zone_s* zonePtr, int32_t const* faceNeighbors); template void ___3968::___430<int64_t>(Zone_s* zonePtr, int64_t const* faceNeighbors); void ___3968::copyConnectivity(___3968 const& ___2886) { for (Zone_s::ZoneMap::iterator zonePair = m_zoneMap.begin(); zonePair != m_zoneMap.end(); ++zonePair) { Zone_s::ZoneMap::const_iterator iter = ___2886.m_zoneMap.find(zonePair->first); throwIf(iter == ___2886.m_zoneMap.end(), "Non-matching zone structure between grid and solution files\nZone not found in grid file: ", zonePair->first); if (!zonePair->second->m_partitionMap.empty()) { for (Zone_s::ZoneMap::iterator partitionPair = zonePair->second->m_partitionMap.begin(); partitionPair != zonePair->second->m_partitionMap.end(); ++partitionPair) { Zone_s::ZoneMap::const_iterator subIter = iter->second->m_partitionMap.find(partitionPair->first); throwIf(subIter == iter->second->m_partitionMap.end(), "Non-matching zone structure between grid and solution files\npartition not found in grid file: ", partitionPair->first); partitionPair->second->___2495 = subIter->second->___2495; } } else { zonePair->second->___2495 = iter->second->___2495; } } } int32_t ___3968::___2844() const { return static_cast<int32_t>(m_nextZoneIndex); } int32_t ___3968::numZonePartitions(int32_t zone) const { Zone_s::ZoneMap::const_iterator iter = m_zoneMap.find(static_cast<___4633>(zone - 1)); REQUIRE(iter != m_zoneMap.end()); if (iter->second->m_partitionOwners.empty()) return static_cast<int32_t>(iter->second->m_partitionMap.size()); return static_cast<int32_t>(iter->second->m_partitionOwners.size()); } int32_t ___3968::___2841() const { return static_cast<int32_t>(___2672.size()); } void ___3968::___4164(bool checkConnectivity) const { if (!m_zoneMap.empty()) { boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; else if (!zone->m_partitionOwners.empty()) return; if (!zone->m_allVarsAreShared && zone->___2395 != ___2672.size())
{ std::ostringstream ostream; ___2225 valuesNeeded = zone->___2494[zone->___2395]->___2666 - (___2225)zone->___2494[zone->___2395]->storedValueCount(); ostream << "Not all variable values for the current zone have been written.\n" << "Currently need " << valuesNeeded << " for variable " << zone->___2395 + 1 << "."; throw Error(ostream.str()); } if (checkConnectivity) { if (zone->___2495 && zone->___2495->expectedValueCount() > zone->___2495->storedValueCount()) { ___2225 valuesNeeded = zone->___2495->expectedValueCount() - zone->___2495->storedValueCount(); std::ostringstream ostream; ostream << "Not all node map values for the current zone have been written.\n" << "Currently need " << valuesNeeded << " more values."; throw Error(ostream.str()); } } } } void ___3968::clear(int32_t numZonesToRetain, int32_t const* zonesToRetain) { if (!m_zoneMap.empty()) m_lastZoneFlushedToDisk = static_cast<___3931::___4633>(m_zoneMap.rbegin()->first); if (numZonesToRetain == 0) { m_zoneMap.clear(); } else { boost::unordered_set<Zone_s::ZoneMap::key_type>zoneSet; for (int32_t i = 0; i < numZonesToRetain; ++i) zoneSet.insert(zonesToRetain[i] - 1); for (Zone_s::ZoneMap::iterator it = m_zoneMap.begin(); it != m_zoneMap.end();) if (zoneSet.find(it->first) == zoneSet.end()) { Zone_s::ZoneMap::iterator eraseIt = it; ++it; m_zoneMap.erase(eraseIt); } else { ++it; } } if (___2397) ___2397->m_auxDataItems.clear(); for (size_t ___4333 = 0; ___4333 < ___2670.size(); ++___4333) if (___2670[___4333]) ___2670[___4333]->m_auxDataItems.clear(); ___2463.clear(); ___2638.clear(); ___2396.clear(); ENSURE(empty()); } bool ___3968::empty() { bool ___3356 = true; if (!m_zoneMap.empty() && m_zoneMap.rbegin()->first > m_lastZoneFlushedToDisk) ___3356 = false; if (!___2463.empty() || !___2638.empty() || !___2396.empty()) ___3356 = false; if (___2397 && !___2397->m_auxDataItems.empty()) ___3356 = false; for(size_t i = 0; i < ___2670.size(); ++i) if (___2670[i] && !___2670[i]->m_auxDataItems.empty()) ___3356 = false; return  ___3356; } std::set<___3491> ___3968::zoneSet() const { std::set<___3491> ___3356; for (Zone_s::ZoneMap::const_iterator it = m_zoneMap.begin(); it != m_zoneMap.end(); ++it) ___3356.insert(static_cast<___3491>(it->first + 1)); return ___3356; } std::set<___3491> ___3968::unflushedZoneSet() const { std::set<___3491> ___3356; for (Zone_s::ZoneMap::const_iterator it = m_zoneMap.upper_bound(m_lastZoneFlushedToDisk); it != m_zoneMap.end(); ++it) ___3356.insert(static_cast<___3491>(it->first + 1)); return ___3356; } bool ___3968::___894() const { return (!m_zoneMap.empty() && m_zoneMap.rbegin()->first > m_lastZoneFlushedToDisk); } Zone_s* ___3968::zonePtr(___4633 ___4655) const { REQUIRE(0 < ___4655); Zone_s::ZoneMap::const_iterator zoneIter = m_zoneMap.find(___4655 - 1); if (zoneIter != m_zoneMap.end()) return zoneIter->second.get();
else return NULL; } void ___3968::updateBaseZoneForVarCache() const { m_baseZoneForVar.resize(___2841()); for (___4349 varIndex = 0; varIndex < ___2841(); ++varIndex) { m_baseZoneForVar[varIndex].assign(m_nextZoneIndex, -1); for (___4633 ___4631 = 0; ___4631 < m_nextZoneIndex; ++___4631) { Zone_s* zPtr = zonePtr(___4631 + 1); if (zPtr) { ___4633 const sharedZoneIndex = zPtr->m_shareVarFromZone[varIndex] - 1; if (sharedZoneIndex >= 0 && validZoneNum(sharedZoneIndex + 1)) m_baseZoneForVar[varIndex][___4631] = m_baseZoneForVar[varIndex][sharedZoneIndex]; else m_baseZoneForVar[varIndex][___4631] = ___4631; } } } } ___4633 ___3968::baseZoneForVar(___4633 ___4655, ___4349 ___4365) const { REQUIRE(validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(___2672.size())); if (m_baseZoneForVar.empty() || checked_numeric_cast<___4633>(m_baseZoneForVar.size()) < ___2841() || checked_numeric_cast<___4633>(m_baseZoneForVar[0].size()) < m_nextZoneIndex) { updateBaseZoneForVarCache(); } ___4349 const varIndex = ___4365 - 1; ___4633 const ___4631 = ___4655 - 1; ___4633 ___3356 = m_baseZoneForVar[varIndex][___4631] + 1; ENSURE(validZoneNum(___3356)); return ___3356; } Zone_s* ___3968::zonePtrForVar(___4633 ___4655, ___4349 ___4365) const { REQUIRE(validZoneNum(___4655)); REQUIRE(0 < ___4365 && ___4365 <= static_cast<___4349>(___2672.size())); ___4633 ___341 = baseZoneForVar(___4655, ___4365); Zone_s* ___3356 = zonePtr(___341); ENSURE(VALID_REF(___3356)); return ___3356; } void ___3968::updateBaseZoneForConnectivityCache() const { m_baseZoneForConnectivity.assign(m_nextZoneIndex, -1); for (___4633 ___4631 = 0; ___4631 < m_nextZoneIndex; ++___4631) { Zone_s* zPtr = zonePtr(___4631 + 1); if (zPtr) { ___4633 const sharedZoneIndex = zPtr->m_shareConnectivityFromZone - 1; if (sharedZoneIndex >= 0) m_baseZoneForConnectivity[___4631] = sharedZoneIndex; else m_baseZoneForConnectivity[___4631] = ___4631; } } } ___4633 ___3968::baseZoneForConnectivity(___4633 ___4655) const { REQUIRE(validZoneNum(___4655)); if (m_baseZoneForConnectivity.empty() || checked_numeric_cast<___4633>(m_baseZoneForConnectivity.size()) < m_nextZoneIndex) updateBaseZoneForConnectivityCache(); ___4633 const ___4631 = ___4655 - 1; ___4633 ___3356 = m_baseZoneForConnectivity[___4631] + 1; ENSURE(validZoneNum(___3356)); return ___3356; } Zone_s* ___3968::zonePtrForConnectivity(___4633 ___4655) const { REQUIRE(validZoneNum(___4655)); ___4633 ___341 = baseZoneForConnectivity(___4655); Zone_s* ___3356 = zonePtr(___341); ENSURE(VALID_REF(___3356)); return ___3356; } bool ___3968::validPartitionNum(___3931::___4633 ___4655, ___3931::___4633 partitionNum) const { Zone_s* zPtr = zonePtr(___4655); return zPtr->m_partitionMap.find(partitionNum - 1) != zPtr->m_partitionMap.end(); } void ___3968::flattenSinglePartitionZones() { for (Zone_s::ZoneMap::iterator valuePair = m_zoneMap.begin();
valuePair != m_zoneMap.end(); ++valuePair) { Zone_s* zonePtr = valuePair->second.get();
 #if defined TECIOMPI
if (zonePtr->m_partitionMap.size() == 1 && zonePtr->m_partitionOwners.size() == 1)
 #else
if (zonePtr->m_partitionMap.size() == 1)
 #endif
{ Zone_s* partitionPtr = zonePtr->m_partitionMap.begin()->second.get(); zonePtr->___2494 = partitionPtr->___2494; zonePtr->___2495 = partitionPtr->___2495; zonePtr->m_partitionMap.clear(); } } } tecplot::___3931::___1391 ___3968::sizeInFile(bool ___4477) const { ___1391 size = 0; size += stringSizeInFile(___2647, ___4477); size += vectorSizeInFile(___2672, ___4477); size += scalarSizeInFile(m_defaultVarType, ___4477); size += scalarSizeInFile(m_nextZoneIndex, ___4477); size += scalarSizeInFile(m_lastZoneFlushedToDisk, ___4477); size += mapOfScalarsToPtrsSizeInFile(m_zoneMap, ___4477); size += ___2397->sizeInFile(___4477); size += vectorOfPtrsSizeInFile(___2670, ___4477); size += vectorOfObjectsSizeInFile(___2463, ___4477); size += vectorOfObjectsSizeInFile(___2638, ___4477); size += scalarSizeInFile((uint64_t)___2396.size(), ___4477); for (std::vector<std::vector<std::string> >::const_iterator vec = ___2396.begin(); vec != ___2396.end(); ++vec) { size += vectorSizeInFile(*vec, ___4477); } return size; } void ___3968::writeToFile(___3931::FileWriterInterface& outputFile, ___3931::___1391 fileLoc, bool ___4477) const { REQUIRE(outputFile.___2039()); outputFile.___3457(fileLoc); ___4541(outputFile, ___2647, ___4477); writeVector(outputFile, ___2672, ___4477); writeScalar(outputFile, m_defaultVarType, ___4477); writeScalar(outputFile, m_nextZoneIndex, ___4477); writeScalar(outputFile, m_lastZoneFlushedToDisk, ___4477); writeMapOfScalarsToPtrs(outputFile, m_zoneMap, ___4477); ___2397->writeToFile(outputFile, ___4477); writeVectorOfPtrs(outputFile, ___2670, ___4477); writeVectorOfObjects(outputFile, ___2463, ___4477); writeVectorOfObjects(outputFile, ___2638, ___4477); writeScalar(outputFile, (uint64_t)___2396.size(), ___4477); for (std::vector<std::vector<std::string> >::const_iterator vec = ___2396.begin(); vec != ___2396.end(); ++vec) { writeVector(outputFile, *vec, ___4477); } ENSURE(outputFile.fileLoc() == fileLoc + sizeInFile(___4477)); } ___3968::___3968(___3931::___1397& inputFile, bool readASCII) { REQUIRE(inputFile.___2039()); readString(inputFile, ___2647, readASCII); readVector(inputFile, ___2672, readASCII); readScalar(inputFile, m_defaultVarType, readASCII); readScalar(inputFile, m_nextZoneIndex, readASCII); readScalar(inputFile, m_lastZoneFlushedToDisk, readASCII); readMapOfScalarsToPtrs(inputFile, m_zoneMap, readASCII); ___2397 = AuxData_s::makePtr(inputFile, readASCII); readVectorOfPtrs(inputFile, ___2670, readASCII); readVectorOfObjects(inputFile, ___2463, readASCII); readVectorOfObjects(inputFile, ___2638, readASCII); uint64_t length; readScalar(inputFile, length, readASCII); ___2396.resize((size_t)length); for(size_t i = 0; i < ___2396.size(); ++i) readVector(inputFile, ___2396[i], readASCII);
} }}
