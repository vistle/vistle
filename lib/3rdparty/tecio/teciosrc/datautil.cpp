#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "Q_UNICODE.h"
#include "SYSTEM.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "SET.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "DATAIO.h"
#include "DATAIO4.h"
#include "DATAUTIL.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined MAKEARCHIVE
 #define ___1935
 #endif
#include "INPUT.h"
using namespace tecplot;
 #if defined MAKEARCHIVE
 #define ___58 1.0e-10
void ___1933() { LineThicknessInputSpec.___4234                                = ___1940; LineThicknessInputSpec.___2468                                 = 0.000001; LineThicknessInputSpec.___2344                                 = 1.0; LineThicknessInputSpec.___1976.___3432           = 100.0; LineThicknessInputSpec.___3882                      = NULL; PatternLengthInputSpec.___4234                                = ___1940; PatternLengthInputSpec.___2468                                 = 0.0001; PatternLengthInputSpec.___2344                                 = 1.0; PatternLengthInputSpec.___1976.___3432           = 100.0; PatternLengthInputSpec.___3882                      = NULL; TextBoxMarginInputSpec.___4234                                = ___1940; TextBoxMarginInputSpec.___2468                                 = 0.0; TextBoxMarginInputSpec.___2344                                 = 20.0; TextBoxMarginInputSpec.___1976.___3432           = 100.0; TextBoxMarginInputSpec.___3882                      = NULL; TextLineSpacingInputSpec.___4234                              = ___1940; TextLineSpacingInputSpec.___2468                               = 0.0; TextLineSpacingInputSpec.___2344                               = 5.0; TextLineSpacingInputSpec.___1976.___3432         = 1.0; TextLineSpacingInputSpec.___3882                    = NULL; ArrowheadSizeInputSpec.___4234                                = ___1940; ArrowheadSizeInputSpec.___2468                                 = 0.0; ArrowheadSizeInputSpec.___2344                                 = 0.5; ArrowheadSizeInputSpec.___1976.___3432           = 100.0; ArrowheadSizeInputSpec.___3882                      = NULL; TextAngleInputSpec.___4234                                    = ___1940; TextAngleInputSpec.___2468                                     = -M_PI - ___58; TextAngleInputSpec.___2344                                     =  M_PI + ___58; TextAngleInputSpec.___1976.___3432               = ___952; TextAngleInputSpec.___3882                          = NULL; ArrowheadAngleInputSpec.___4234                               = ___1940; ArrowheadAngleInputSpec.___2468                                = 1.0 / ___952 - ___58; ArrowheadAngleInputSpec.___2344                                = ___3086 + ___58; ArrowheadAngleInputSpec.___1976.___3432          = ___952; ArrowheadAngleInputSpec.___3882                     = NULL; }
 #endif
void LocalReadBlock(___1403   *___1399, double         *CurVPtr, FieldDataType_e ___1365, ___2225       ___2840, ___372      *___2038) { REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); REQUIRE(!(*___2038) || VALID_REF(___1399)); REQUIRE(!(*___2038) || VALID_FIELD_DATA_TYPE(___1365)); if (*___2038) { ___372 ___1097 = (CurVPtr != NULL); ___372 ReadByBlock = (___1365 == FieldDataType_Double) || !___1097; if (ReadByBlock) { ___3294(___1399, ___1097, (void *)CurVPtr, ___1365, 0, ___2840, ___2038); } else { for (___2225 N = 0; *___2038 && (N < ___2840); N++) { double const D = ___1760(___1399, ___1365, -___2177, ___2177, ___2038); if (___1097) CurVPtr[N] = D; } } } }
 #define READTEC_FREE(___3249,str) ( ((___3249)!=NULL) ? (___1528((___3249),(str)),(___3249)=NULL) : (NULL) )
___372 ___3295( ___372       ___1746, char const*     ___1392, int32_t        *fileVersion, DataFileType_e *___1405, char          **___901, ___1170     *___2845, ___1170     *NumVars, ___3837  *___4363, ___3837  *___4650, int32_t       **zoneVersions, ___2225     **___2828, ___2225     **___2829, ___2225     **___2830, ___2225     **___2803, ZoneType_e    **___4690, ___3837  *___4283, ___264     *___883, ___2225       **neighborCount, int32_t        ***valueLocations, FieldDataType_e***___1370, ___372      ***fieldDataPassive, int32_t        ***varSharing, int32_t         **connectSharing, ___372         RawDataSpaceAllocated, ___2730      ***___2722, double         ***___4392) { REQUIRE(VALID_BOOLEAN(___1746)); REQUIRE(VALID_NON_ZERO_LEN_STR(___1392)); REQUIRE(VALID_REF(fileVersion)); REQUIRE(VALID_REF(___1405)); REQUIRE(VALID_REF(___901) || ___901 == NULL); REQUIRE(VALID_REF(___2845)); REQUIRE(VALID_REF(NumVars)); REQUIRE(___4363  == NULL || VALID_REF(___4363)); REQUIRE(___4650 == NULL || VALID_REF(___4650)); REQUIRE(zoneVersions == NULL || VALID_REF(zoneVersions)); REQUIRE(___2828   == NULL || VALID_REF(___2828)); REQUIRE(___2829   == NULL || VALID_REF(___2829)); REQUIRE(___2830 == NULL || VALID_REF(___2830)); REQUIRE(___2803 == NULL || VALID_REF(___2803)); REQUIRE(___4690 == NULL || VALID_REF(___4690)); REQUIRE(___4283   == NULL || VALID_REF(___4283)); REQUIRE(VALID_REF_OR_NULL(neighborCount) && IMPLICATION(neighborCount, *neighborCount == NULL)); REQUIRE(VALID_REF_OR_NULL(valueLocations) && IMPLICATION(valueLocations, *valueLocations == NULL)); REQUIRE(VALID_REF_OR_NULL(___1370) && IMPLICATION(___1370, *___1370 == NULL)); REQUIRE(VALID_REF_OR_NULL(fieldDataPassive) && IMPLICATION(fieldDataPassive, *fieldDataPassive == NULL)); REQUIRE(VALID_REF_OR_NULL(varSharing) && IMPLICATION(varSharing, *varSharing == NULL)); REQUIRE(VALID_REF_OR_NULL(connectSharing) && IMPLICATION(connectSharing, *connectSharing == NULL)); REQUIRE(VALID_BOOLEAN(RawDataSpaceAllocated)); REQUIRE(IMPLICATION(!___1746 && RawDataSpaceAllocated, VALID_REF(___2722) && VALID_REF(___4392))); ___372     InputIsOk = ___1303; ___134  ___4679 = NULL; ___2225    *___1439 = NULL; ___1403 *ReadTecFileStream = NULL; ___3499       *___2073 = NULL; ___372 const getDataSegmentMetaData = (___1370 || fieldDataPassive || varSharing || connectSharing || neighborCount);
 #if defined MAKEARCHIVE
___1933();
 #endif
InputIsOk  = ___2874(&ReadTecFileStream, ___1392, 0, fileVersion); if (InputIsOk) InputIsOk = ___3277(ReadTecFileStream, short(*fileVersion), ___1303, ___2845, NumVars, (int32_t *)NULL, ___901, (___4116 **)NULL, (___1630 **)NULL, (___3837  **)NULL, ___4283, ___883, 0, &___2073, (___372 *)NULL, (___372 *)NULL, &___4679, ___4363, (___134 *)NULL, (___3499 *)NULL, &___1439, ___1405); if (InputIsOk) { if (*___2845 == 0) *NumVars = 0; else if (*fileVersion > 191) { ___1175(___4215("ReadTec does not yet support version %d " "Tecplot binary data files."), *fileVersion); InputIsOk = ___1303; } else if (!___1746) { for (___1170 Z = 0; Z < *___2845 && InputIsOk; Z++) { InputIsOk = ___2013(___2073[Z]); if (!InputIsOk) ___1175(___4215("Cell centered data not supported by ReadTec.")); } } } if (InputIsOk && ___2073 && valueLocations && *___2845 > 0) { *valueLocations = ___23(*___2845, int32_t*, "valueLocations base array"); InputIsOk = (*valueLocations != NULL); for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) (*valueLocations)[zn] = NULL; for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) { (*valueLocations)[zn] = ___23(*NumVars, int32_t, "valueLocations subarray"); InputIsOk = ((*valueLocations)[zn] != NULL); for (___1170 ___4333 = 0; ___4333 < *NumVars && InputIsOk; ++___4333) { if (___1954(___2073[zn], ___4333)) (*valueLocations)[zn][___4333] = 0; else (*valueLocations)[zn][___4333] = 1; } } } if (InputIsOk && ___1370 && *___2845 > 0) { *___1370 = ___23(*___2845, FieldDataType_e*, "fieldDataTypes base array"); InputIsOk = (*___1370 != NULL); for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) (*___1370)[zn] = NULL; } if (InputIsOk && fieldDataPassive && *___2845 > 0) { *fieldDataPassive = ___23(*___2845, ___372*, "fieldDataPassive base array"); InputIsOk = (*fieldDataPassive != NULL); for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) (*fieldDataPassive)[zn] = NULL; } if (InputIsOk && varSharing && *___2845 > 0) { *varSharing = ___23(*___2845, ___1170*, "varSharing base array"); InputIsOk = (*varSharing != NULL); for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) (*varSharing)[zn] = NULL; } if (InputIsOk && neighborCount && *___2845 > 0) { *neighborCount = ___23(*___2845, ___2225, "neighborCount array"); InputIsOk = (*neighborCount != NULL); for (___1170 zn = 0; zn < *___2845 && InputIsOk; ++zn) (*neighborCount)[zn] = 0; } if (InputIsOk && *___2845 > 0) { if (___4650) *___4650 = ___3819(); if (zoneVersions) *zoneVersions = ___23(*___2845, int32_t, "zoneVersions Array"); if (___2828) *___2828  = ___23(*___2845, ___2225, "numptsi"); if (___2829) *___2829  = ___23(*___2845, ___2225, "numptsj"); if (___2830) *___2830 = ___23(*___2845, ___2225, "numptsk"); if (___2803) *___2803 = ___23(*___2845, ___2225, "NumFaceNodes");
if (___4690) *___4690 = ___23(*___2845, ZoneType_e, "zonetype"); InputIsOk = (IMPLICATION(___4650, *___4650)       && IMPLICATION(zoneVersions, *zoneVersions) && IMPLICATION(___2828, *___2828)           && IMPLICATION(___2829, *___2829)           && IMPLICATION(___2830, *___2830)           && IMPLICATION(___2803, *___2803) && IMPLICATION(___4690, *___4690)); for (___1170 zn = 0; InputIsOk && zn < *___2845; zn++) { ___4680 const* const ___4674 = ___1801(___4679, zn); if (___4674 != NULL) { if (!InputIsOk) break; if (___4650) ___3821(*___4650, ___4674->___2683.c_str()); if (zoneVersions) (*zoneVersions)[zn] = ___4674->tecplotFileZoneVersion; if (___2828) (*___2828)[zn] = ___4674->numIPts(); if (___2829) (*___2829)[zn] = ___4674->numJPts(); if (___2830) (*___2830)[zn] = ___4674->numKPts(); if (___2803) (*___2803)[zn] = ___4674->___2802(); if (___4690) (*___4690)[zn] = ___4674->___4234; } else { if (___4650) ___3821(*___4650, NULL); if (zoneVersions) (*zoneVersions)[zn] = *fileVersion; if (___2828) (*___2828)[zn] = 0; if (___2829) (*___2829)[zn] = 0; if (___2830) (*___2830)[zn] = 0; if (___2803) (*___2803)[zn] = 0; if (___4690) (*___4690)[zn] = ___4700; } } } ___372 const readDataSegment = (*___2845 > 0) && (!___1746 || getDataSegmentMetaData); ___372 const allocateFieldDataAndConnectivity = (*___2845 > 0) && (!___1746 && !RawDataSpaceAllocated); if (readDataSegment && InputIsOk) { ___2225 const numZoneVars = ___2225(*___2845) * ___2225(*NumVars); ___1170      *VarSharesFromZone = NULL; ___372       *___2074               = NULL; ___1170      *ConnectivitySharesFromZone = NULL; FieldDataType_e *VarType = NULL; if (allocateFieldDataAndConnectivity) { *___4392 = ___23(numZoneVars, double *, "vdatabase array"); if (*___4392 == NULL) { ___1175(___4215("Cannot allocate space for field data")); InputIsOk = ___1303; } else { for (___2225 zv = 0; zv < numZoneVars; ++zv) (*___4392)[zv] = NULL; } if (InputIsOk) { *___2722 = ___23(*___2845, ___2730 *, "nodemap array"); if (*___2722 == NULL) { ___1175(___4215("Cannot allocate space for nodemap")); InputIsOk = ___1303; } else { for (___1170 zn = 0; zn < *___2845; ++zn) (*___2722)[zn] = NULL; } } } if (InputIsOk) { VarType           = ___23(*NumVars, FieldDataType_e, "VarType"); VarSharesFromZone = ___23(*NumVars, ___1170, "VarSharesFromZone"); ___2074      = ___23(*NumVars, ___372, "IsVarPassive"); ConnectivitySharesFromZone = ___23(*___2845, ___1170, "ConnectivitySharesFromZone"); InputIsOk = (VarType                    != NULL && VarSharesFromZone          != NULL && ___2074               != NULL && ConnectivitySharesFromZone != NULL); } for (___1170 zone = 0; zone < *___2845 && InputIsOk; ++zone) { double const ___4564 = ___1760(ReadTecFileStream, FieldDataType_Float, 0.0, 1000.0, &InputIsOk);
if (InputIsOk && (___4564 == ZoneMarkerFull32Bit || ___4564 == ZoneMarkerFace64Bit)) { ___4680& zoneSpec = *___1801(___4679, zone); ___372 ZoneIsFinite  = (zoneSpec.___4234 != ___4701); ___372 ZoneIsFEPoly  = (zoneSpec.___4234 == ___4695 || zoneSpec.___4234 == ___4696); ___372 InBlockFormat = zoneSpec.___4644.___2025; for (___1170 ___4333 = 0; ___4333 < *NumVars; ++___4333 ) { VarSharesFromZone[___4333] = -1; VarType[___4333]           = FieldDataType_Float; ___2074[___4333]      = ___1303; } if (*fileVersion > 45 && *fileVersion < 101 && InputIsOk) { ___1170 const numDupVars = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk); if ((numDupVars > 0) && (zone == 0)) { ___1175(___4215("Cannot duplicate variables from the first zone since there are " "no previous zones to duplicate from.")); InputIsOk = ___1303; } for (___1170 index = 0; index < numDupVars && InputIsOk; ++index) { ___1170 const ___4333 = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk) - 1; VarSharesFromZone[___4333] = zone - 1; } } if (*fileVersion >= 70 && InputIsOk) { for (___1170 ___4333 = 0; ___4333 < *NumVars; ++___4333) { VarType[___4333] = (FieldDataType_e)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___1363, &InputIsOk); if (!InputIsOk) { ___1175(___4215("Invalid data type - binary input file corrupted")); InputIsOk = ___1303; } } } ___2225 const ___2807 = InputIsOk ? zoneSpec.numIPts() : 0; ___2225 const ___2812 = InputIsOk ? zoneSpec.numJPts() : 0; ___2225 const ___2815 = InputIsOk ? zoneSpec.numKPts() : 0; ___2225 const TotalNumPts = (ZoneIsFinite ? ___2807 : ___2807 * ___2812 * ___2815); for (___1170 ___4333 = 0; ___4333 < *NumVars && InputIsOk; ++___4333) { if (allocateFieldDataAndConnectivity && TotalNumPts >= 1) (*___4392)[___4333 + zone*(*NumVars)] = ___23(TotalNumPts, double, "raw data"); } if (*fileVersion >= 105 && InputIsOk) { if ((___372)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1170 ___4333 = 0; ___4333 < *NumVars && InputIsOk; ++___4333) { ___2074[___4333] = (___372)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); } } } if (*fileVersion >= 101 && InputIsOk) { if ((___372)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1170 ___4333 = 0; ___4333 < *NumVars && InputIsOk; ++___4333) { ___1170 const SharedZone = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2380 - 1, &InputIsOk); if (SharedZone != -1 && InputIsOk) VarSharesFromZone[___4333] = SharedZone; } } if (InputIsOk) { ___1170 const SharedZone = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2380 - 1, &InputIsOk); if (InputIsOk) ConnectivitySharesFromZone[zone] = SharedZone; } } if (*fileVersion >= 103 && InputIsOk) { for (___1170 ___4333 = 0; ___4333 < *NumVars && InputIsOk; ++___4333) { if (VarSharesFromZone[___4333] == -1 && !___2074[___4333])
{ ___1760(ReadTecFileStream, FieldDataType_Double, -___2177, ___2177, &InputIsOk); ___1760(ReadTecFileStream, FieldDataType_Double, -___2177, ___2177, &InputIsOk); } } } if (___1746) { if (InBlockFormat) { for (___1170 ___4333 = 0; InputIsOk && ___4333 < *NumVars; ++___4333) { if (VarSharesFromZone[___4333] == -1 && !___2074[___4333]) { ___2225 numValues = TotalNumPts; if (___1954(___2073[zone], ___4333)) { if (ZoneIsFinite) numValues = ___2812; else if (___2807 > 1 && ___2812 > 1 && ___2815 > 1) numValues = ___2807 * ___2812 * (___2815 - 1); else if (___2807 > 1 && ___2812 > 1) numValues = ___2807 * (___2812 - 1); else if (___2812 > 1 && ___2815 > 1) numValues = ___2812 * (___2815 - 1); else if (___2807 > 1 && ___2815 > 1) numValues = ___2807 * (___2815 - 1); else if (___2807 > 1) numValues = (___2807 - 1); else if (___2812 > 1) numValues = (___2812 - 1); else if (___2815 > 1) numValues = (___2815 - 1); else numValues = 1; } LocalReadBlock( ReadTecFileStream, NULL, VarType[___4333], numValues, &InputIsOk); } } } else { ___1175(___4215("Zone in point format, not all meta data available.")); InputIsOk = ___1303; } } else if (InBlockFormat) { for (___1170 ___4333 = 0; InputIsOk && ___4333 < *NumVars; ++___4333) { if (TotalNumPts > 0) { double *CurVPtr = (*___4392)[___4333 + zone*(*NumVars)]; if (VarSharesFromZone[___4333] != -1) { ___1170 const ___3646 = VarSharesFromZone[___4333]; double *SourceVPtr = (*___4392)[___4333 + ___3646*(*NumVars)]; for (___2225 M = 0; M < TotalNumPts; M++) CurVPtr[M] = SourceVPtr[M]; } else if (!___2074[___4333]) { LocalReadBlock(ReadTecFileStream, CurVPtr, VarType[___4333], TotalNumPts, &InputIsOk); } } } if (!InputIsOk) ___1175(___4215("Invalid raw data section of binary file")); } else if (TotalNumPts > 0) { if (InputIsOk) { ___2225 N; N = 0; while (InputIsOk && (N < TotalNumPts)) { for (___1170 ___716 = 0; InputIsOk && (___716 < *NumVars); ___716++) { double *CurVPtr  = (*___4392)[___716+zone*(*NumVars)]; if (VarSharesFromZone[___716] != -1) { ___1170 ___3646 = VarSharesFromZone[___716]; double *SourceVPtr = (*___4392)[___716+___3646*(*NumVars)]; CurVPtr[N] = SourceVPtr[N]; } else if (!___2074[___716]) { double D = ___1760(ReadTecFileStream, VarType[___716], -___2177, ___2177, &InputIsOk); if (InputIsOk && CurVPtr) CurVPtr[N] = D; } } if (!InputIsOk) ___1175(___4215("Binary datafile corrupted!")); N++; } } } if (InputIsOk && *fileVersion < 101) { if (ZoneIsFinite) { ___372 DupConnectivity; if (*fileVersion > 61) DupConnectivity = (___372)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); else DupConnectivity = ___1303; if (DupConnectivity) ConnectivitySharesFromZone[zone] = zone - 1; else ConnectivitySharesFromZone[zone] = -1; } else ConnectivitySharesFromZone[zone] = -1; } if (InputIsOk && ZoneIsFinite && !ZoneIsFEPoly) { ___372   SkipNodemap; ___2730  *___2705 = NULL; ___2730  *ONM = NULL; if (allocateFieldDataAndConnectivity && ___2815*___2812 >= 1)
{ (*___2722)[zone] = ___23(___2815 * ___2812, ___2730, "node map"); if ((*___2722)[zone] == NULL) ___1175(___4215("Cannot allocate space for connectivity list", "See the Tecplot User's Manual for a definition of 'connectivity list'")); } if (InputIsOk && ___2722 && *___2722) ___2705 = (*___2722)[zone]; SkipNodemap = (___2705 == NULL); if (InputIsOk && ConnectivitySharesFromZone[zone] != -1) { ___1170 ___3646 = ConnectivitySharesFromZone[zone]; if (___3646 >= zone) { ___1175(___4215("Zone %d is attempting to share connectivity " "with a zone that has not yet been loaded."), zone + 1); InputIsOk = ___1303; } else { ONM = (*___2722)[___3646]; if (ONM == NULL) { ___1175(___4215("Zone %d is attempting to share connectivity " "with a zone that is not finite element."), zone + 1); InputIsOk = ___1303; } } } if (InputIsOk) { if (___1746) { if (ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846) { LocalReadBlock(ReadTecFileStream, NULL, FieldDataType_Int32, ___2812*___2815, &InputIsOk); } } else { for (___2225 ___2104 = 0; ___2104 < ___2812; ___2104++) for (___2225 ___1830 = 0; ___1830 < ___2815; ___1830++) { ___2225 ___2163 = ___2104 * ___2815 + ___1830; ___2225 M; if (ConnectivitySharesFromZone[zone] != -1) { M = ONM[___2163]; } else { int32_t const nodeShift = *fileVersion < 103 ? 1 : 0; M = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2747 + nodeShift, ___2180, &InputIsOk) - nodeShift; } if (!SkipNodemap) ___2705[___2163] = M; } } } } if (*fileVersion >= 101 && InputIsOk) { if ( ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846     && ___1439[zone] != 0 ) { if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = ___1439[zone]; ___2225 Connection = 0; while (Connection < ___1439[zone] && InputIsOk) { (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), -___2180, ___2180, &InputIsOk); if (!InputIsOk) ___1175(___4215("Unexpected end-of-file while reading face neighbor data.")); (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), -___2180, ___2180, &InputIsOk); if (InputIsOk) { ___476(zoneSpec.___1438 == ___1288  || zoneSpec.___1438 == ___1287 || zoneSpec.___1438 == ___1285 || zoneSpec.___1438 == ___1284); if (zoneSpec.___1438 == ___1288) (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2747, ___2180, &InputIsOk); else (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), -___2180, ___2180, &InputIsOk); if (zoneSpec.___1438 != ___1288 && InputIsOk) { ___2225 NumAssociations = 0; if (zoneSpec.___1438 == ___1287) { NumAssociations = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2180, &InputIsOk); } else if (zoneSpec.___1438 == ___1285) { (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2747, ___2180, &InputIsOk);
} else { ___476(zoneSpec.___1438 == ___1284); NumAssociations = ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2180, &InputIsOk); } if (zoneSpec.___1438 != ___1285 && InputIsOk) { ___2225 Assoc; if (zoneSpec.___1438 == ___1287) { for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2747, ___2180, &InputIsOk); } else { ___476(zoneSpec.___1438 == ___1284); for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) { (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2748, ___2380, &InputIsOk); (void)___1748<int32_t>(ReadTecFileStream, short(*fileVersion), ___2747, ___2180, &InputIsOk); } } if (InputIsOk) Connection += NumAssociations; } else if (InputIsOk) Connection += 1; } else if (InputIsOk) Connection += 1; if (!InputIsOk) ___1175(___4215("Corrupt input file: invalid face neighbors.")); } } } } if (InputIsOk                              && ZoneIsFEPoly                           && *fileVersion >= 110                    && ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846) { if (!InBlockFormat) { ___1175(___4215("Poly zones must be in block format")); InputIsOk = ___1303; } if (InputIsOk) { ___2225 const numIPts = zoneSpec.numIPts(); ___2225 const numJPts = zoneSpec.numJPts(); ___2225 const numKPts = zoneSpec.numKPts(); if (*fileVersion == 110) { zoneSpec.assignMetrics( numIPts, numJPts, numKPts, ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2180, &InputIsOk), ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2180, &InputIsOk), ___1748<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2180, &InputIsOk)); } ___2225 const ___4191  = zoneSpec.___2802(); ___2225 const TotalNumBndryFaces = zoneSpec.numFaceBndryFaces(); ___2225 const TotalNumBndryItems = zoneSpec.numFaceBndryItems(); ___2225 const ___2804 = numKPts; if (zoneSpec.___4234 == ___4696) { int64_t const numFaceMetaDataValues = (zoneSpec.tecplotFileZoneVersion >= 191) ? ___2804  : ___2804 + 1/*offsets*/; ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, numFaceMetaDataValues, &InputIsOk); } if (InputIsOk) { ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___4191, &InputIsOk); } if (InputIsOk) { ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___2804, &InputIsOk); } if (InputIsOk) { ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___2804, &InputIsOk); } if (TotalNumBndryFaces > 0) { ___476(*fileVersion <= 191); if (InputIsOk && *fileVersion <= 191) ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, 1, &InputIsOk); if (InputIsOk) ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryFaces + 1, &InputIsOk);
if (InputIsOk) ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk); if (InputIsOk) { if (*fileVersion >= 112) ___3290(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk); else ___3288(ReadTecFileStream, ___1303 , NULL, 0, TotalNumBndryItems, &InputIsOk); } } if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = zoneSpec.numFaceBndryItems(); } } } else { ___1175(___4215("Corrupt input file")); InputIsOk = ___1303; } if (InputIsOk && VarType && ___1370) { (*___1370)[zone] = VarType; VarType = ___23(*NumVars, FieldDataType_e, "VarType array"); InputIsOk = (VarType != NULL); } if (InputIsOk && ___2074 && fieldDataPassive) { (*fieldDataPassive)[zone] = ___2074; ___2074 = ___23(*NumVars, ___372, "IsVarPassive array"); InputIsOk = (___2074 != NULL); } if (InputIsOk && VarSharesFromZone && varSharing) { (*varSharing)[zone] = VarSharesFromZone; VarSharesFromZone = ___23(*NumVars, ___1170, "VarSharesFromZone array"); InputIsOk = (VarSharesFromZone != NULL); } } if (ConnectivitySharesFromZone) { if (connectSharing && InputIsOk) { *connectSharing = ConnectivitySharesFromZone; ConnectivitySharesFromZone = NULL; } else READTEC_FREE(ConnectivitySharesFromZone, "ConnectivitySharesFromZone"); } if (VarType) READTEC_FREE(VarType, "VarType"); if (___2074) READTEC_FREE(___2074, "IsVarPassive"); if (VarSharesFromZone) READTEC_FREE(VarSharesFromZone, "VarSharesFromZone"); if (!InputIsOk) { if (neighborCount) READTEC_FREE(*neighborCount, "neighborCount"); for (___1170 zn = 0; zn < *___2845; ++zn) { if (valueLocations && *valueLocations) READTEC_FREE((*valueLocations)[zn], "valueLocations subarray"); if (___1370 && *___1370) READTEC_FREE((*___1370)[zn], "fieldDataTypes subarray"); if (fieldDataPassive && *fieldDataPassive) READTEC_FREE((*fieldDataPassive)[zn], "fieldDataPassive subarray"); if (varSharing && *varSharing) READTEC_FREE((*varSharing)[zn], "varSharing subarray"); } if (valueLocations) READTEC_FREE(*valueLocations, "valueLocations"); if (___1370) READTEC_FREE(*___1370, "fieldDataTypes"); if (fieldDataPassive) READTEC_FREE(*fieldDataPassive, "fieldDataPassive"); if (varSharing) READTEC_FREE(*varSharing, "varSharing"); if (connectSharing) READTEC_FREE(*connectSharing, "connectSharing"); if (!RawDataSpaceAllocated) { if (___4392 && *___4392) { for (___2225 zv = 0; zv < numZoneVars; ++zv) { if ((*___4392)[zv]) READTEC_FREE((*___4392)[zv], "vdatabase array"); } READTEC_FREE(*___4392, "vdatabase pointer array"); } if (___2722 && *___2722) { for (___1170 zn = 0; zn < *___2845; ++zn) { if ((*___2722)[zn]) READTEC_FREE((*___2722)[zn], "connectivity list"); } READTEC_FREE(*___2722, "connectivity pointer array"); } } } } if (___2073) { for (___1170 zn = 0; zn < *___2845; ++zn) ___937(&___2073[zn]); READTEC_FREE(___2073, "Array of IsVarCellCentered sets");
} if (___1439 != NULL) READTEC_FREE(___1439, "FNNumBndryConns"); if (___4679) ArrayListDealloc(&___4679, ___4678, 0); if (ReadTecFileStream) { ___4193(ReadTecFileStream->File); free(ReadTecFileStream); } ENSURE(VALID_BOOLEAN(InputIsOk)); ENSURE(IMPLICATION(neighborCount, InputIsOk == (*neighborCount != NULL))); ENSURE(IMPLICATION(valueLocations, InputIsOk == (*valueLocations != NULL))); ENSURE(IMPLICATION(___1370, InputIsOk == (*___1370 != NULL))); ENSURE(IMPLICATION(fieldDataPassive, InputIsOk == (*fieldDataPassive != NULL))); ENSURE(IMPLICATION(varSharing, InputIsOk == (*varSharing != NULL))); ENSURE(IMPLICATION(connectSharing, InputIsOk == (*connectSharing != NULL))); return InputIsOk; } void* ___3955(size_t size) { return (void *)___23(size, char, "TecAlloc"); } void ___3966(void *___3249) { char *Tmp = (char *)___3249; READTEC_FREE(Tmp, "TecAlloc"); }
