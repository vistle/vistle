#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJKSubzoneInfo.h"
namespace tecplot { namespace ___3931 { ___372 IJKSubzoneInfo::getSubzonesOnIndexPlane( IJKPlanes_e                              whichPlane, ___81                               planeIndex, ___3267<ItemAddress64::SubzoneAddress>& szAddresses) const { REQUIRE(whichPlane == ___1865 || whichPlane == ___1870 || whichPlane == ___1872); REQUIRE(IMPLICATION(whichPlane == ___1865, planeIndex < m_zoneIJKDim.i()) && IMPLICATION(whichPlane == ___1870, planeIndex < m_zoneIJKDim.___2103()) && IMPLICATION(whichPlane == ___1872, planeIndex < m_zoneIJKDim.___2132())); REQUIRE(szAddresses.empty()); ___372 ___2037 = ___4224; try { switch (whichPlane) { case ___1865: { ___81 const iSzPlane = szIJKAtItemIJK(___1842(planeIndex,0,0)).i(); size_t const ___2810 = m_subzoneTilingIJKDim.___2103()*m_subzoneTilingIJKDim.___2132(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2132(); ++kSz ) { for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2103(); ++jSz ) { *szArray = szAddressAtSzIJK(___1842(iSzPlane,jSz,kSz)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1870: { ___81 const jSzPlane = szIJKAtItemIJK(___1842(0,planeIndex,0)).___2103(); size_t const ___2810 = m_subzoneTilingIJKDim.i()*m_subzoneTilingIJKDim.___2132(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2132(); ++kSz ) { for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1842(iSz,jSzPlane,kSz)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1872: { ___81 const kSzPlane = szIJKAtItemIJK(___1842(0,0,planeIndex)).___2132(); size_t const ___2810 = m_subzoneTilingIJKDim.i()*m_subzoneTilingIJKDim.___2103(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2103(); ++jSz ) { for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1842(iSz,jSz,kSzPlane)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; default: ___476(___1303); break; } } catch (...) { ___2037 = ___1184("getSubzonesOnIndexPlane failed"); } ENSURE(IMPLICATION(___2037, !szAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(szAddresses.begin(), szAddresses.end()))); ENSURE(IMPLICATION(___2037, szAddresses[szAddresses.size()-1].subzoneOffset() < getNumSzs())); return ___2037; } ___372 IJKSubzoneInfo::getSubzonesOnIndexLine( IJKLines_e                               whichLine, ___81                               mIndex, ___81                               nIndex, ___3267<ItemAddress64::SubzoneAddress>& szAddresses) const {
REQUIRE(whichLine == ___1855 || whichLine == ___1857 || whichLine == ___1858); REQUIRE(IMPLICATION(whichLine == ___1855, mIndex < m_zoneIJKDim.___2103() && nIndex < m_zoneIJKDim.___2132()) && IMPLICATION(whichLine == ___1857, mIndex < m_zoneIJKDim.i() && nIndex < m_zoneIJKDim.___2132()) && IMPLICATION(whichLine == ___1858, mIndex < m_zoneIJKDim.i() && nIndex < m_zoneIJKDim.___2103())); REQUIRE(szAddresses.empty()); ___372 ___2037 = ___4224; try { switch (whichLine) { case ___1855: { ___1842 const ijkSzBase(szIJKAtItemIJK(___1842(0,mIndex,nIndex))); ___81 const jSzBase = ijkSzBase.___2103(); ___81 const kSzBase = ijkSzBase.___2132(); size_t const ___2810 = m_subzoneTilingIJKDim.i(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1842(iSz,jSzBase,kSzBase)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1857: { ___1842 const ijkSzBase(szIJKAtItemIJK(___1842(mIndex,0,nIndex))); ___81 const iSzBase = ijkSzBase.i(); ___81 const kSzBase = ijkSzBase.___2132(); size_t const ___2810 = m_subzoneTilingIJKDim.___2103(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2103(); ++jSz ) { *szArray = szAddressAtSzIJK(___1842(iSzBase,jSz,kSzBase)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1858: { ___1842 const ijkSzBase(szIJKAtItemIJK(___1842(mIndex,nIndex,0))); ___81 const iSzBase = ijkSzBase.i(); ___81 const jSzBase = ijkSzBase.___2103(); size_t const ___2810 = m_subzoneTilingIJKDim.___2132(); szAddresses.reserve(___2810); szAddresses.___3501(___2810); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2132(); ++kSz ) { *szArray = szAddressAtSzIJK(___1842(iSzBase,jSzBase,kSz)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; default: ___476(___1303); break; } } catch (...) { ___2037 = ___1184("getSubzonesOnIndexPlane failed"); } ENSURE(IMPLICATION(___2037, !szAddresses.empty())); ENSURE(IMPLICATION(___2037, std::is_sorted(szAddresses.begin(), szAddresses.end()))); ENSURE(IMPLICATION(___2037, szAddresses[szAddresses.size()-1].___2975()==m_partition)); ENSURE(IMPLICATION(___2037, szAddresses[szAddresses.size()-1].subzoneOffset() < getNumSzs())); return ___2037; } }}
