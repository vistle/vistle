#include "MASTER.h"
#include "GLOBAL.h"
 #if defined _MSC_VER && _MSC_VER <= 1800
 #define FUNCTION_NAME __FUNCTION__
 #else
 #define FUNCTION_NAME __func__
 #endif
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/unordered_map.hpp>
#include <iostream>
#include <memory>
#include <numeric>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "TECIO.h"
#include "CHARTYPE.h"
 #if !defined TECIOMPI
#include "TecioPLT.h"
 #endif
#include "TecioSZL.h"
using namespace tecplot::tecioszl;
 #define ___2880 0
 #define ___1338 1
 #define ___1346 2
 #define ___1341 3
 #define ___1345 4
 #define FEBRICK 5
 #define ___1339 6
 #define ___1340 7
 #define FEMIXED 8
 #define ___1533 0
 #define ___1809 1
 #define ___3636 2
 #if defined MSWIN && defined _DEBUG
 #define ___3182(s) do { OutputDebugStringA(s); printf(s); } while (0)
 #define ___3183(s,a1) do { char ___416[512]; sprintf(___416,s,a1); OutputDebugStringA(___416); printf(___416); } while (0)
 #define ___3184(s,a1,a2) do { char ___416[512]; sprintf(___416,s,a1,a2); OutputDebugStringA(___416); printf(___416); } while (0)
 #else
 #define ___3182(s) printf(s)
 #define ___3183(s,a1) printf(s,a1)
 #define ___3184(s,a1,a2) printf(s,a1,a2)
 #endif
 #define ___23(n, T, s) (new T[n])
 #define ___1528(a, s) (delete[] a);
 #define ___2378 10
 #if !defined _WIN32
 #   define ___1232
 #endif
namespace { int32_t ___689 = -1; std::vector<int32_t> ___1389(___2378, 0); std::vector<int32_t> ___2040(___2378, 0); boost::unordered_map<void*, int32_t> fileFormatForHandle; int firstOpenFile() { ___476(___1389.size() == ___2378); ___476(___2040.size() == ___2378); for (int ___1830 = 0; ___1830 < ___2378; ++___1830) { if (!___2040[___1830]) return ___1830; } return -1; } struct FileInfo { int32_t m_fileFormat; void* m_typeSpecificData; explicit FileInfo(int32_t ___1388) : m_fileFormat(___1388) , m_typeSpecificData(NULL) {} }; } int32_t tecFileWriterOpen( char const* ___1392, char const* dataSetTitle, char const* variableList, int32_t     ___1388, int32_t     ___1405, int32_t     defaultVarType, void*       gridFileHandle, void**      fileHandle) { void* gridFileTypeSpecificData = NULL; if (___1405 == ___3636) { if (gridFileHandle) { gridFileTypeSpecificData = ((FileInfo*)gridFileHandle)->m_typeSpecificData; } else { ___3182("Err: (tecFileWriterOpen) invalid parameter gridFileHandle.\n"); return -1; } } try {
 #if !defined TECIOMPI
if (___1388 == FILEFORMAT_PLT) { ___3182("Err: (tecFileWriterOpen) .plt format not yet supported\n"); return -1; } else if (___1388 == FILEFORMAT_SZL) {
 #endif
FileInfo* fileInfo = new FileInfo(___1388); if (tecFileWriterOpen_SZL(___1392, dataSetTitle, variableList, ___1405, defaultVarType, gridFileTypeSpecificData, &fileInfo->m_typeSpecificData) == 0) { *fileHandle = fileInfo; } else { delete fileInfo; return -1; }
 #if !defined TECIOMPI
} else { ___3183("Err: (tecFileWriterOpen) invalid value for fileFormat: %d\n", ___1388); return -1; }
 #endif
} catch (std::exception const& e) { ___3183("tecFileWriterOpen: %s\n", e.what()); return -1; } return 0; } int32_t tecFileSetDiagnosticsLevel(void* fileHandle, int32_t level) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFileSetDiagnosticsLevel) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFileSetDiagnosticsLevel) .plt format not yet supported\n"); else if (fileInfo->m_fileFormat == FILEFORMAT_SZL)
 #else
else
 #endif
return tecFileSetDiagnosticsLevel_SZL(fileInfo->m_typeSpecificData, level); return -1; }
 #if defined TECIOMPI
int32_t tecMPIInitialize(void* fileHandle, MPI_Comm communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, communicator, mainRank); return -1; } EXTERNC tecio_API int32_t tecMPIInitializef(void*fileHandle, int32_t communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else if (!MPI_Comm_f2c(communicator)) ___3182("Err: (tecMPIInitialize) invalid communicator parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, MPI_Comm_f2c(communicator), mainRank); return -1; } int32_t tecMPIFileSetInfo(void* fileHandle, MPI_Info info) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecMPIFileSetInfo) invalid fileHandle parameter\n"); else return tecMPIFileSetInfo_SZL(fileInfo->m_typeSpecificData, info); return -1; } EXTERNC tecio_API int32_t tecMPIFileSetInfof(void*fileHandle, int32_t info) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecMPIFileSetInfo) invalid fileHandle parameter\n"); else if (!MPI_Info_f2c(info)) ___3182("Err: (tecMPIFileSetInfo) invalid info parameter\n"); else return tecMPIFileSetInfo_SZL(fileInfo->m_typeSpecificData, MPI_Info_f2c(info)); return -1; }
 #endif
int32_t tecZoneCreateIJK( void*          fileHandle, char const*    ___4687, int64_t        imax, int64_t        jmax, int64_t        kmax, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        shareFaceNeighborsFromZone, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneCreateIJK) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneCreateIJK) .plt format not yet supported\n");
 #endif
else return tecZoneCreateIJK_SZL( fileInfo->m_typeSpecificData, ___4687, imax, jmax, kmax, varTypes, ___3549, valueLocations, ___2980, shareFaceNeighborsFromZone, ___2800, ___1282, zone); return -1; } int32_t tecZoneCreateFE( void*          fileHandle, char const*    ___4687, int32_t        ___4689, int64_t        ___2819, int64_t        ___2779, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneCreateFE) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneCreateFE) .plt format not yet supported\n");
 #endif
else return tecZoneCreateFE_SZL( fileInfo->m_typeSpecificData, ___4687, ___4689, ___2819, ___2779, varTypes, ___3549, valueLocations, ___2980, ___3547, ___2800, ___1282, zone); return -1; } int32_t tecZoneCreateFEMixed( void*          fileHandle, char const*    ___4687, int64_t        ___2819, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneCreateFEMixed) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneCreateFEMixed) .plt format not yet supported\n");
 #endif
else return tecZoneCreateFEMixed_SZL( fileInfo->m_typeSpecificData, ___4687, ___2819, numSections, cellShapePerSection, gridOrderPerSection, basisFnPerSection, numElementsPerSection, varTypes, ___3549, valueLocations, ___2980, ___3547, ___2800, ___1282, zone); return -1; } int32_t tecZoneCreatePoly( void*          fileHandle, char const*    ___4687, int32_t        ___4689, int64_t        ___2819, int64_t        numFaces, int64_t        ___2779, int64_t        ___4190, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2784, int64_t        ___4186, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneCreatePoly) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneCreatePoly) .plt format not yet supported\n");
 #endif
else return tecZoneCreatePoly_SZL( fileInfo->m_typeSpecificData, ___4687, ___4689, ___2819, numFaces, ___2779, ___4190, varTypes, ___3549, valueLocations, ___2980, ___3547, ___2784, ___4186, zone); return -1; } int32_t tecZoneSetUnsteadyOptions( void*   fileHandle, int32_t zone, double  ___3638, int32_t ___3783) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneSetUnsteadyOptions) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneSetUnsteadyOptions) .plt format not yet supported\n");
 #endif
else return tecZoneSetUnsteadyOptions_SZL(fileInfo->m_typeSpecificData, zone, ___3638, ___3783); return -1; } int32_t tecZoneSetParentZone( void*   fileHandle, int32_t zone, int32_t  ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneSetParentZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneSetParentZone) .plt format not yet supported\n");
 #endif
else return tecZoneSetParentZone_SZL(fileInfo->m_typeSpecificData, zone, 0); return -1; } int32_t tecZoneMapPartitionsToMPIRanks( void*          fileHandle, int32_t&       zone, int32_t        numPartitions, int32_t const* mpiRanksForPartitions) {
 #if defined TECIOMPI
___4276(zone); FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneMapPartitionsToMPIRanks) invalid fileHandle parameter\n"); else if (zone < 0) ___3183("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter zone: %d.\n", zone); else if (numPartitions < 1) ___3183("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter numPartitions: %d.\n", numPartitions); else if (!mpiRanksForPartitions) ___3182("Err: (tecZoneMapPartitionsToMPIRanks) Bad value <NULL> for parameter mpiRanksForPartitions.\n"); else return tecZoneMapPartitionsToMPIRanks_SZL(fileInfo->m_typeSpecificData, numPartitions, mpiRanksForPartitions); return -1;
 #else
___4276(fileHandle); ___4276(zone); ___4276(numPartitions); ___4276(mpiRanksForPartitions); ___3182("Err: (mpiRanksForPartitions) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #endif
} int32_t tecFEPartitionCreate32( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t        ___2779, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t        numGhostCells, int32_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFEPartitionCreate32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFEPartitionCreate32) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate32_SZL( fileInfo->m_typeSpecificData, zone, ___2975, ___2819, &___2779, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, &numGhostCells, ghostCells); return -1; } int32_t tecFEPartitionCreate64( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t        ___2779, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t        numGhostCells, int64_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFEPartitionCreate64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFEPartitionCreate64) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate64_SZL( fileInfo->m_typeSpecificData, zone, ___2975, ___2819, &___2779, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, &numGhostCells, ghostCells); return -1; } int32_t tecFEMixedPartitionCreate32( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFEPartitionCreate32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFEPartitionCreate32) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate32_SZL( fileInfo->m_typeSpecificData, zone, ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); return -1; } int32_t tecFEMixedPartitionCreate64( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int64_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFEPartitionCreate64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFEPartitionCreate64) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate64_SZL( fileInfo->m_typeSpecificData, zone, ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); return -1; } int32_t tecIJKPartitionCreate( void*   fileHandle, int32_t zone, int32_t ___2975, int64_t imin, int64_t jmin, int64_t kmin, int64_t imax, int64_t jmax, int64_t kmax) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecIJKPartitionCreate) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecIJKPartitionCreate) .plt format does not support partitions\n");
 #endif
else return tecIJKPartitionCreate_SZL( fileInfo->m_typeSpecificData, zone, ___2975, imin, jmin, kmin, imax, jmax, kmax); return -1; } int32_t tecZoneVarWriteDoubleValues( void*         fileHandle, int32_t       zone, int32_t       ___4333, int32_t       ___2975, int64_t       count, double const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneVarWriteDoubleValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneVarWriteDoubleValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteDoubleValues_SZL(fileInfo->m_typeSpecificData, zone, ___4333, ___2975, count, values); return -1; } int32_t tecZoneVarWriteFloatValues( void*        fileHandle, int32_t      zone, int32_t      ___4333, int32_t      ___2975, int64_t      count, float const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneVarWriteFloatValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneVarWriteFloatValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteFloatValues_SZL(fileInfo->m_typeSpecificData, zone, ___4333, ___2975, count, values); return -1; } int32_t tecZoneVarWriteInt32Values( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, int32_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneVarWriteInt32Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneVarWriteInt32Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt32Values_SZL(fileInfo->m_typeSpecificData, zone, ___4333, ___2975, count, values); return -1; } int32_t tecZoneVarWriteInt16Values( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, int16_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneVarWriteInt16Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneVarWriteInt16Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt16Values_SZL(fileInfo->m_typeSpecificData, zone, ___4333, ___2975, count, values); return -1; } int32_t tecZoneVarWriteUInt8Values( void*          fileHandle, int32_t        zone, int32_t        ___4333, int32_t        ___2975, int64_t        count, uint8_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneVarWriteUInt8Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneVarWriteUInt8Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteUInt8Values_SZL(fileInfo->m_typeSpecificData, zone, ___4333, ___2975, count, values); return -1; } int32_t tecZoneNodeMapWrite32( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased, int64_t        count, int32_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneNodeMapWrite32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneNodeMapWrite32) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite32_SZL(fileInfo->m_typeSpecificData, zone, ___2975, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneNodeMapWrite64( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased, int64_t        count, int64_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneNodeMapWrite64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneNodeMapWrite64) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite64_SZL(fileInfo->m_typeSpecificData, zone, ___2975, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneFaceNbrWriteConnections32( void*          fileHandle, int32_t        zone, int32_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneFaceNbrWriteConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneFaceNbrWriteConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections32_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } EXTERNC tecio_API int32_t tecZoneFaceNbrWriteConnections64( void*          fileHandle, int32_t        zone, int64_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneFaceNbrWriteConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneFaceNbrWriteConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections64_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } int32_t tecZoneWritePolyFaces32( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        numFaces, int32_t const* faceNodeCounts, int32_t const* ___1294, int32_t const* faceLeftElems, int32_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneWritePolyFaces32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneWritePolyFaces32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces32_SZL( fileInfo->m_typeSpecificData, zone, ___2975, numFaces, faceNodeCounts, ___1294, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyFaces64( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        numFaces, int32_t const* faceNodeCounts, int64_t const* ___1294, int64_t const* faceLeftElems, int64_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneWritePolyFaces64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneWritePolyFaces64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces64_SZL( fileInfo->m_typeSpecificData, zone, ___2975, numFaces, faceNodeCounts, ___1294, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections32( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int32_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneWritePolyBoundaryConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneWritePolyBoundaryConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections32_SZL( fileInfo->m_typeSpecificData, zone, ___2975, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections64( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int64_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneWritePolyBoundaryConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneWritePolyBoundaryConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections64_SZL( fileInfo->m_typeSpecificData, zone, ___2975, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecDataSetAddAuxData( void*       fileHandle, char const* ___2683, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecDataSetAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecDataSetAddAuxData) .plt format not yet supported\n");
 #endif
else return tecDataSetAddAuxData_SZL(fileInfo->m_typeSpecificData, ___2683, value); return -1; } int32_t tecVarAddAuxData( void*       fileHandle, int32_t     ___4333, char const* ___2683, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecVarAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecVarAddAuxData) .plt format not yet supported\n");
 #endif
else return tecVarAddAuxData_SZL(fileInfo->m_typeSpecificData, ___4333, ___2683, value); return -1; } int32_t tecZoneAddAuxData( void*       fileHandle, int32_t     zone, char const* ___2683, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecZoneAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecZoneAddAuxData) .plt format not yet supported\n");
 #endif
else return tecZoneAddAuxData_SZL(fileInfo->m_typeSpecificData, zone, ___2683, value); return -1; } int32_t tecGeom2DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, int32_t       ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeom2DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeom2DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, numPoints, relativeX, relativeY, ___3157); return -1; } int32_t tecGeom2DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, int32_t        ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeom2DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeom2DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, ___2833, numSegmentPoints, relativeX, relativeY, ___3157); return -1; } int32_t tecGeom3DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, double        zOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, double const* relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeom3DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeom3DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, numPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeom3DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, double         zOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, double const*  relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeom3DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeom3DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, ___2833, numSegmentPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeomCircleBegin( void*   fileHandle, double  xCenter, double  yCenter, double  radius, int32_t ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomCircleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomCircleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomCircleBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, radius, ___3157); return -1; } int32_t tecGeomEllipseBegin( void*   fileHandle, double  xCenter, double  yCenter, double  ___4455, double  ___1824, int32_t ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomEllipseBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomEllipseBegin) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, ___4455, ___1824, ___3157); return -1; } int32_t tecGeomRectangleBegin( void*   fileHandle, double  xMin, double  yMin, double  xMax, double  yMax, int32_t ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomRectangleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomRectangleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomRectangleBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, xMax, yMax, ___3157); return -1; } int32_t tecGeomSquareBegin( void*   fileHandle, double  xMin, double  yMin, double  size, int32_t ___3157) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSquareBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSquareBegin) .plt format not yet supported\n");
 #endif
else return tecGeomSquareBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, size, ___3157); return -1; } int32_t tecGeomArrowheadSetInfo( void*   fileHandle, double  ___56, int32_t attachment, double  size, int32_t style) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomArrowheadSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomArrowheadSetInfo) .plt format not yet supported\n");
 #endif
else return tecGeomArrowheadSetInfo_SZL( fileInfo->m_typeSpecificData, ___56, attachment, size, style); return -1; } int32_t tecGeomEllipseSetNumPoints( void*   fileHandle, int32_t numEllipsePoints) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSetNumEllipsePoints) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSetNumEllipsePoints) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseSetNumPoints_SZL(fileInfo->m_typeSpecificData, numEllipsePoints); return -1; } int32_t tecGeomSetClipping( void*   fileHandle, int32_t ___493) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSetClipping) .plt format not yet supported\n");
 #endif
else return tecGeomSetClipping_SZL( fileInfo->m_typeSpecificData, ___493); return -1; } int32_t tecGeomSetLineInfo( void*   fileHandle, int32_t ___2261, double  ___2984, double  thickness, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSetLineInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSetLineInfo) .plt format not yet supported\n");
 #endif
else return tecGeomSetLineInfo_SZL( fileInfo->m_typeSpecificData, ___2261, ___2984, thickness, color); return -1; } int32_t tecGeomSetMacroFunctionCmd( void*       fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecGeomSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecGeomSetScope( void*   fileHandle, int32_t ___3440) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomSetScope) .plt format not yet supported\n");
 #endif
else return tecGeomSetScope_SZL(fileInfo->m_typeSpecificData, ___3440); return -1; } int32_t tecGeomAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomAttachToZone) .plt format not yet supported\n");
 #endif
else return tecGeomAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecGeomFill( void*  fileHandle, int32_t ___1409) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomFill) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomFill) .plt format not yet supported\n");
 #endif
else return tecGeomFill_SZL(fileInfo->m_typeSpecificData, ___1409); return -1; } int32_t tecGeomEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecGeomEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecGeomEnd) .plt format not yet supported\n");
 #endif
else return tecGeomEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecCustomLabelsAddSet( void*       fileHandle, char const* ___2171) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecCustomLabelsAddSet) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecCustomLabelsAddSet) .plt format not yet supported\n");
 #endif
else return tecCustomLabelsAddSet_SZL(fileInfo->m_typeSpecificData, ___2171); return -1; } int32_t tecText2DBegin( void*       fileHandle, char const* string, double      x, double      ___4580, int32_t     ___3157, double      ___1824, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecText2DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecText2DBegin) .plt format not yet supported\n");
 #endif
else return tecText2DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4580, ___3157, ___1824, sizeUnits); return -1; } int32_t tecText3DBegin( void*       fileHandle, char const* string, double      x, double      ___4580, double      z, double      ___1824, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecText3DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecText3DBegin) .plt format not yet supported\n");
 #endif
else return tecText3DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4580, z, ___1824, sizeUnits); return -1; } int32_t tecTextAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextAttachToZone) .plt format not yet supported\n");
 #endif
else return tecTextAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecTextBoxSetInfo( void*   fileHandle, int32_t ___410, int32_t lineColor, int32_t ___1409, double  ___2287, double  margin) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextBoxSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextBoxSetInfo) .plt format not yet supported\n");
 #endif
else return tecTextBoxSetInfo_SZL( fileInfo->m_typeSpecificData, ___410, lineColor, ___1409, ___2287, margin); return -1; } int32_t tecTextSetAnchor(void* fileHandle, int32_t ___38) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetAnchor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetAnchor) .plt format not yet supported\n");
 #endif
else return tecTextSetAnchor_SZL(fileInfo->m_typeSpecificData, ___38); return -1; } int32_t tecTextSetAngle( void*  fileHandle, double ___56) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetAngle) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetAngle) .plt format not yet supported\n");
 #endif
else return tecTextSetAngle_SZL(fileInfo->m_typeSpecificData, ___56); return -1; } int32_t tecTextSetClipping(void* fileHandle, int32_t ___493) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetClipping) .plt format not yet supported\n");
 #endif
else return tecTextSetClipping_SZL(fileInfo->m_typeSpecificData, ___493); return -1; } int32_t tecTextSetColor( void*  fileHandle, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetColor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetColor) .plt format not yet supported\n");
 #endif
else return tecTextSetColor_SZL(fileInfo->m_typeSpecificData, color); return -1; } int32_t tecTextSetTypeface( void*       fileHandle, char const* family, int32_t     isBold, int32_t     isItalic) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetTypeface) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetTypeface) .plt format not yet supported\n");
 #endif
else return tecTextSetTypeface_SZL(fileInfo->m_typeSpecificData, family, isBold, isItalic); return -1; } int32_t tecTextSetLineSpacing( void*  fileHandle, double ___2285) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetLineSpacing) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetLineSpacing) .plt format not yet supported\n");
 #endif
else return tecTextSetLineSpacing_SZL(fileInfo->m_typeSpecificData, ___2285); return -1; } int32_t tecTextSetMacroFunctionCmd( void* fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecTextSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecTextSetScope( void*   fileHandle, int32_t ___3440) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextSetScope) .plt format not yet supported\n");
 #endif
else return tecTextSetScope_SZL(fileInfo->m_typeSpecificData, ___3440); return -1; } int32_t tecTextEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecTextEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecTextEnd) .plt format not yet supported\n");
 #endif
else return tecTextEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecUserRecAdd( void*       fileHandle, char const* userRec) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecUserRecAdd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecUserRecAdd) .plt format not yet supported\n");
 #endif
else return tecUserRecAdd_SZL(fileInfo->m_typeSpecificData, userRec); return -1; } int32_t tecFileWriterFlush( void*          fileHandle, int32_t        numZonesToRetain, int32_t const* zonesToRetain) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3182("Err: (tecFileWriterFlush) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3182("Err: (tecFileWriterFlush) .plt format not yet supported\n");
 #endif
else return tecFileWriterFlush_SZL(fileInfo->m_typeSpecificData, numZonesToRetain, zonesToRetain); return -1; } int32_t tecFileWriterClose(void** fileHandle) { FileInfo* fileInfo = NULL; if (fileHandle) fileInfo = (FileInfo*)(*fileHandle); if (!fileInfo) { ___3182("Err: (tecFileWriterClose) invalid fileHandle parameter\n"); }
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) { ___3182("Err: (tecFileWriterClose) .plt format not yet supported\n"); }
 #endif
else { int32_t ___3356 = tecFileWriterClose_SZL(&fileInfo->m_typeSpecificData); delete fileInfo; *fileHandle = NULL; return ___3356; } return -1; } int32_t TECINTERNAL142( const char* command, int64_t*    value) { REQUIRE(VALID_REF(command)); REQUIRE(VALID_REF(value));
 #if !defined TECIOMPI
if (strcmp(command, "GETPOLY32BITFACELIMIT") == 0) { return TECIOPLT_InternalGetPolyFace32BitLimit(value); } else if (strcmp(command, "SETPOLY32BITFACELIMIT") == 0) { return TECIOPLT_InternalSetPolyFace32BitLimit(value); }
 #else
___4276(command); ___4276(value);
 #endif
return -1; } int32_t TECINI142( char const*    ___4175, char const*    ___4347, char const*    ___1392, char const*    ___3445, int32_t const* ___1388, int32_t const* ___1405, int32_t const* ___939, int32_t const* ___2011) { int ___2695 = firstOpenFile(); if (___2695 == -1) { ___3183("Err: (TECINI142) Too many files (%d) opened for writing.\n", ___2695); return (-1); } ___1389[___2695] = *___1388; if (___689 == -1) ___689 = 0; int32_t ___3357;
 #if !defined TECIOMPI
if (___1389[___2695] == FILEFORMAT_PLT) ___3357 = ___3975(___2695, ___4175, ___4347, ___1392, ___3445, ___1405, ___939, ___2011); else
 #endif
___3357 = ___3997(___2695, ___4175, ___4347, ___1392, ___3445, ___1405, ___939, ___2011); if (___3357 >= 0) ___2040[___2695] = 1; return ___3357; } int32_t TECINI112( char const*     ___4175, char const*     ___4347, char const*     ___1392, char const*     ___3445, int32_t const* ___1405, int32_t const* ___939, int32_t const* ___2011) { return TECINI142(___4175, ___4347, ___1392, ___3445, &FILEFORMAT_PLT, ___1405, ___939, ___2011); } int32_t TECINI111( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4436) { return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, ___1406, ___940, ___4436); } int32_t TECINI110( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); } int32_t TECINI100( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); } int32_t TECINI( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecini142_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___1389, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4436) { return TECINI142(___4176, ___4348, ___1437, ___3446, ___1389, ___1406, ___940, ___4436); } EXTERNC tecio_API int32_t tecini112_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4436) { return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, ___1406, ___940, ___4436); } EXTERNC tecio_API int32_t tecini111_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4436) { return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, ___1406, ___940, ___4436); } EXTERNC tecio_API int32_t tecini110_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); } EXTERNC tecio_API int32_t tecini100_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); } EXTERNC tecio_API int32_t tecini_( char const*     ___4176, char const*     ___4348, char const*     ___1437, char const*     ___3446, int32_t const* ___940, int32_t const* ___4436) { int32_t ___1532 = ___1533; return TECINI142(___4176, ___4348, ___1437, ___3446, &FILEFORMAT_PLT, &___1532, ___940, ___4436); }
 #endif
int32_t TECZNEFEMIXED142( char    const* ___4688, int64_t const* NumNodes, int32_t const* NumSections, int32_t const* CellShapePerSection, int32_t const* GridOrderPerSection, int32_t const* BasisFnPerSection, int64_t const* NumElementsPerSection, double  const* ___3639, int32_t const* ___3784, int32_t const* ___2801, int32_t const* ___1283, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3182("Err: (TECZNEFEMIXED142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
{ int32_t const FEMixedZoneType = FEMIXED; int64_t const ___2160 = 0; int32_t const ___2004 = 1; int64_t const NumElements = std::accumulate(NumElementsPerSection,NumElementsPerSection+(*NumSections), int64_t(0)); return ___4012( ___689, ___4688, &FEMixedZoneType, NumNodes, &NumElements, &___2160, *NumSections, CellShapePerSection, GridOrderPerSection, BasisFnPerSection, NumElementsPerSection, ___3639, ___3784, NULL  , &___2004, ___2801, ___1283, NULL, NULL, NULL, ___2981, ___4324, ___3550, ___3548); } } int32_t TECFEMIXEDPTN142( int32_t const* ___2975, int64_t const* ___2819, int64_t const* numCellsPerSection, int64_t const* numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3182("Err: (TECFEMIXEDPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
{ return TECIOSZL_FEMIXEDPTN( ___689, ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } } int32_t TECZNE142( char const*    ___4688, int32_t const* ___4690, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2160, int32_t const* , int32_t const* , int32_t const* , double const*  ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2004, int32_t const* ___2801, int32_t const* ___1283, int32_t const* ___4191, int32_t const* ___2785, int32_t const* ___4187, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { int64_t const KMxOrNumFaces64 = ___2160 ? *___2160 : 0; int64_t const TotalNumFaceNodes64 = ___4191 ? *___4191 : 0; return ___3990( "TECZNE142", ___689, ___4688, ___4690, ___1908, ___2115, (___2160 ? &KMxOrNumFaces64 : NULL), ___3639, ___3784, ___2973, ___2004, ___2801, ___1283, (___4191 ? &TotalNumFaceNodes64 : NULL), ___2785, ___4187, ___2981, ___4324, ___3550, ___3548); } else
 #endif
{ int64_t const IMxOrNumPts64      = *___1908; int64_t const JMxOrNumElements64 = *___2115; int64_t const KMxOrNumFaces64    = ___2160 ? *___2160 : 0; return ___4012( ___689, ___4688, ___4690, &IMxOrNumPts64, &JMxOrNumElements64, &KMxOrNumFaces64, 0, NULL, NULL, NULL, NULL, ___3639, ___3784, ___2973, ___2004, ___2801, ___1283, ___4191, ___2785, ___4187, ___2981, ___4324, ___3550, ___3548); } } int32_t TECPOLYZNE142( char const*     ___4688, INTEGER4 const* ___4690, INTEGER4 const* NumNodes, INTEGER4 const* NumCells, INTEGER8 const* ___2804, INTEGER8 const* ___4191, double const*   ___3639, INTEGER4 const* ___3784, INTEGER4 const* ___2973, INTEGER4 const* ___2785, INTEGER4 const* ___4187, INTEGER4 const* ___2981, INTEGER4 const* ___4324, INTEGER4 const* ___3550, INTEGER4 const* ___3548) { INTEGER4 const ___2004 = 1; INTEGER4 const ___1283 = 0; INTEGER4 const ___2801 = 0;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3990( "TECPOLYZNE142", ___689, ___4688, ___4690, NumNodes, NumCells, ___2804, ___3639, ___3784, ___2973, &___2004, &___2801, &___1283, ___4191, ___2785, ___4187, ___2981, ___4324, ___3550, ___3548); else
 #endif
{ INTEGER8 const NumNodes64 = *NumNodes; INTEGER8 const NumCells64 = *NumCells; INTEGER8 const NumFaces64 = (___2804 ? INTEGER8(*___2804) : 0); INTEGER4 const TotalNumFaceNodes32 = (___4191 ? INTEGER4(*___4191) : 0); return ___4012( ___689, ___4688, ___4690, &NumNodes64, &NumCells64, (___2804 ? &NumFaces64 : NULL), 0, NULL, NULL, NULL, NULL, ___3639, ___3784, ___2973, &___2004, &___2801, &___1283, (___4191 ? &TotalNumFaceNodes32 : NULL), ___2785, ___4187, ___2981, ___4324, ___3550, ___3548); } }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolyzne142_( char const*     ___4688, INTEGER4 const* ___4690, INTEGER4 const* NumNodes, INTEGER4 const* NumCells, INTEGER8 const* ___2804, INTEGER8 const* ___4191, double const*   ___3639, INTEGER4 const* ___3784, INTEGER4 const* ___2973, INTEGER4 const* ___2785, INTEGER4 const* ___4187, INTEGER4 const* ___2981, INTEGER4 const* ___4324, INTEGER4 const* ___3550, INTEGER4 const* ___3548) { return TECPOLYZNE142(___4688, ___4690, NumNodes, NumCells, ___2804, ___4191, ___3639, ___3784, ___2973, ___2785, ___4187, ___2981, ___4324, ___3550, ___3548); }
 #endif
int32_t TECZNE112( char const*     ___4595, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2160, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2803, int32_t const* ___2797, int32_t const* ___2796, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE142(___4595, ___4596, ___1908, ___2115, ___2160, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, ___2803, ___2797, ___2796, ___2981, ___4324, ___3550, ___3548); } int32_t TECZNE111( char const*     ___4595, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2160, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2803, int32_t const* ___2797, int32_t const* ___2796, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE142(___4595, ___4596, ___1908, ___2115, ___2160, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, ___2803, ___2797, ___2796, ___2981, ___4324, ___3550, ___3548); } int32_t TECZNE110( char const*     ___4595, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { int32_t ___2803      = 0; int32_t ___2797 = 0; int32_t ___2796 = 0; return TECZNE142(___4595, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, &___2803, &___2797, &___2796, ___2981, ___4324, ___3550, ___3548); } int32_t TECZNE100( char const*     ___4595, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, int32_t const* ___2003, int32_t const* ___2799,
int32_t const* ___1438, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { double   ___3639 = 0.0; int32_t ___3784   = ___3786 + 1; int32_t ___2973 = ___333 + 1; int32_t ___2803      = 0; int32_t ___2797 = 0; int32_t ___2796 = 0; return TECZNE142(___4595, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, &___3639, &___3784, &___2973, ___2003, ___2799, ___1438, &___2803, &___2797, &___2796, NULL, ___4324, ___3550, ___3548); }
 #if !defined INDEX_16_BIT 
namespace { ___372 ___2974( ___1170** ___3550, ___1170*  ___3548, char const* ___1132) { ___372 ___2038 = ___4224; REQUIRE(VALID_REF(___3550) && *___3550 == NULL); REQUIRE(VALID_REF(___3548)); REQUIRE(VALID_REF(___1132)); ___1170 ___2846; ___1170 ___2842;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___2846 = ___3980(___689); ___2842  = ___3979(___689); } else
 #endif
{ ___2846 = ___4002(___689); ___2842  = ___4001(___689); } while (___2038 && *___1132) { while (*___1132 && *___1132 == ' ') ___1132++; if (*___1132 && !strncmp(___1132, "FECONNECT", 9)) { *___3548 = ___2846; } else if (*___1132 && !tecplot::___2010(*___1132)) { ___2038 = ___1303; } else if (*___1132) { char *___2754 = NULL; ___1170 ___4451 = strtol(___1132, &___2754, 10); if (0 < ___4451 && ___4451 < ___2842) { if (!(*___3550)) { *___3550 = ___23(___2842, ___1170, "Variable sharing list"); if (*___3550) memset(*___3550, (char)0, ___2842 * sizeof(___1170)); } if (*___3550) (*___3550)[___4451 - 1] = ___2846; else ___2038 = ___1303; } else { ___2038 = ___1303; } } while (*___1132 && *___1132 != ',') ___1132++; while (*___1132 && *___1132 == ',') ___1132++; } return ___2038; } }
 #endif
 #if !defined INDEX_16_BIT 
int32_t TECZNE( char const*     ___4688, int32_t const* ___1906, int32_t const* ___2113, int32_t const* ___2158, char const*     ___4593, char const*     ___1132) { int32_t    ___4690; int32_t    ___2004; int32_t   *___3550 = NULL; int32_t    ___3548; int32_t    ___3357 = 0; if (___4593 == NULL) ___3357 = -1; else if (!strcmp(___4593, "BLOCK")) { ___2004 = 1; ___4690 = ___4701; } else if (!strcmp(___4593, "FEBLOCK")) { ___2004 = 1; switch (*___2158) { case 0: ___4690 = 2; break; case 1: ___4690 = 3; break; case 2: ___4690 = 4; break; case 3: ___4690 = 5; break; } } else if (!strcmp(___4593, "POINT")) { ___2004 = 0; ___4690 = ___4701; } else if (!strcmp(___4593, "FEPOINT")) { ___2004 = 0; switch (*___2158) { case 0: ___4690 = 2; break; case 1: ___4690 = 3; break; case 2: ___4690 = 4; break; case 3: ___4690 = 5; break; } } else ___3357 = -1; ___3548 = 0; if (___3357 == 0 && ___1132 && !___2974(&___3550, &___3548, ___1132)) { ___3357 = -1; } if (___3357 == 0) { int32_t ___1834 = 0; int32_t ___2107 = 0; int32_t ___2136 = 0; int32_t ___2801 = 0; int32_t ___1283   = ___1288; double   ___3639 = 0.0; int32_t ___3784   = ___3786 + 1; int32_t ___2973 = ___333 + 1; int32_t ___2803      = 0; int32_t ___2797 = 0; int32_t ___2796 = 0; ___3357 = TECZNE142((char *)___4688, &___4690, ___1906, ___2113, ___2158, &___1834, &___2107, &___2136, &___3639, &___3784, &___2973, &___2004, &___2801, &___1283, &___2803, &___2797, &___2796, NULL, NULL, ___1132 ? ___3550 : NULL, &___3548); } if (___3550) ___1528(___3550, "Variable sharing list"); return (int32_t) ___3357; }
 #endif 
 #if defined ___1232
EXTERNC tecio_API int32_t TECZNEFEMIXED142_( char    const* ___4688, int64_t const* NumNodes, int32_t const* NumSections, int32_t const* CellShapePerSection, int32_t const* GridOrderPerSection, int32_t const* BasisFnPerSection, int64_t const* NumElementsPerSection, double  const* ___3639, int32_t const* ___3784, int32_t const* ___2801, int32_t const* ___1283, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNEFEMIXED142( ___4688, NumNodes, NumSections, CellShapePerSection, GridOrderPerSection, BasisFnPerSection, NumElementsPerSection, ___3639, ___3784, ___2801, ___1283, ___2981, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t TECFEMIXEDPTN142_( int32_t const* ___2975, int64_t const* ___2819, int64_t const* numCellsPerSection, int64_t const* numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { return TECFEMIXEDPTN142( ___2975, ___2819, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } EXTERNC tecio_API int32_t teczne142_( char const*     ___4688, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2803, int32_t const* ___2797, int32_t const* ___2796, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE142(___4688, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, ___2803, ___2797, ___2796, ___2981, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t teczne112_( char const*     ___4688, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2803, int32_t const* ___2797, int32_t const* ___2796, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE142(___4688, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438,
___2803, ___2797, ___2796, ___2981, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t teczne111_( char const*     ___4688, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2803, int32_t const* ___2797, int32_t const* ___2796, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE142(___4688, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, ___2803, ___2797, ___2796, ___2981, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t teczne110_( char const*     ___4688, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, double const*   ___3639, int32_t const* ___3784, int32_t const* ___2973, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___2981, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { int32_t ___2803      = 0; int32_t ___2797 = 0; int32_t ___2796 = 0; return TECZNE142(___4688, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___3639, ___3784, ___2973, ___2003, ___2799, ___1438, &___2803, &___2797, &___2796, ___2981, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t teczne100_( char const*     ___4688, int32_t const* ___4596, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2158, int32_t const* ___1834, int32_t const* ___2107, int32_t const* ___2136, int32_t const* ___2003, int32_t const* ___2799, int32_t const* ___1438, int32_t const* ___4324, int32_t const* ___3550, int32_t const* ___3548) { return TECZNE100(___4688, ___4596, ___1908, ___2115, ___2158, ___1834, ___2107, ___2136, ___2003, ___2799, ___1438, ___4324, ___3550, ___3548); } EXTERNC tecio_API int32_t teczne_( char const*     ___4688, int32_t const* ___1906, int32_t const* ___2113, int32_t const* ___2158, char const*     ___4593, char const*     ___1132) { return TECZNE(___4688, ___1906, ___2113, ___2158, ___4593, ___1132); }
 #endif
int32_t TECDAT142( int32_t const* N, void const*     ___1350, int32_t const* ___2012) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3970(___689, N, ___1350, ___2012); else
 #endif
return ___3992(___689, N, ___1350, ___2012); } int32_t TECDATD142( int32_t const* N, double const*  ___1350) { int32_t ___2011 = 1; return TECDAT142(N, ___1350, &___2011); } int32_t TECDATF142( int32_t const* N, float const*   ___1350) { int32_t ___2011 = 0; return TECDAT142(N, ___1350, &___2011); } int32_t TECDAT112( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } int32_t TECDAT111( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } int32_t TECDAT110( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } int32_t TECDAT100( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } int32_t TECDAT( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecdat142_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } EXTERNC tecio_API int32_t tecdatd142_( int32_t const* N, double const*  ___1350) { return TECDATD142(N, ___1350); } EXTERNC tecio_API int32_t tecdatf142_( int32_t const* N, float const*   ___1350) { return TECDATF142(N, ___1350); } EXTERNC tecio_API int32_t tecdat112_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } EXTERNC tecio_API int32_t tecdat111_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } EXTERNC tecio_API int32_t tecdat110_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } EXTERNC tecio_API int32_t tecdat100_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); } EXTERNC tecio_API int32_t tecdat_( int32_t const* N, void const*     ___1350, int32_t const* ___2012) { return TECDAT142(N, ___1350, ___2012); }
 #endif
int32_t TECNOD142(int32_t const* ___2687) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3977(___689, ___2687); else
 #endif
return ___3999(___689, ___2687); } int32_t TECNOD112(int32_t const* ___2687) { return TECNOD142(___2687); } int32_t TECNOD111(int32_t const* ___2687) { return TECNOD142(___2687); } int32_t TECNOD110(int32_t const* ___2687) { return TECNOD142(___2687); } int32_t TECNOD100(int32_t const* ___2687) { return TECNOD142(___2687); } int32_t TECNOD(int32_t const* ___2687) { return TECNOD142(___2687); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecnod142_(int32_t const* ___2687) { return TECNOD142(___2687); } EXTERNC tecio_API int32_t tecnod112_(int32_t const* ___2687) { return TECNOD142(___2687); } EXTERNC tecio_API int32_t tecnod111_(int32_t const* ___2687) { return TECNOD142(___2687); } EXTERNC tecio_API int32_t tecnod110_(int32_t const* ___2687) { return TECNOD142(___2687); } EXTERNC tecio_API int32_t tecnod100_(int32_t const* ___2687) { return TECNOD142(___2687); } EXTERNC tecio_API int32_t tecnod_(int32_t const* ___2687) { return TECNOD142(___2687); }
 #endif
int32_t TECNODE142( int32_t const* N, int32_t const* ___2687) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3978(___689, N, ___2687); else
 #endif
return ___4000(___689, N, ___2687); } int32_t TECNODE112( int32_t const* N, int32_t const* ___2687) { return TECNODE142(N, ___2687); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecnode142_( int32_t const* N, int32_t const* ___2687) { return TECNODE142(N, ___2687); } EXTERNC tecio_API int32_t tecnode112_( int32_t const* N, int32_t const* ___2687) { return TECNODE142(N, ___2687); }
 #endif
int32_t TECFLUSH142( int32_t const* numZonesToRetain, int32_t const* zonesToRetain) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3182("Err: TECFLUSH does not yet support .plt format\n"); return -1; } else
 #endif
return TECIOSZL_FLUSH(___689, numZonesToRetain, zonesToRetain); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecflush142_( int32_t const* numZonesToRetain, int32_t const* zonesToRetain) { return TECFLUSH142(numZonesToRetain, zonesToRetain); }
 #endif
int32_t TECEND142(void) { int32_t ___3357;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) ___3357 = ___3971(___689); else
 #endif
___3357 = ___3993(___689); ___2040[___689] = 0; ___689 = 0; while ((___689 < ___2378) && !___2040[___689]) ___689++; if (___689 == ___2378) ___689 = -1; return ___3357; } int32_t TECEND112(void) { return TECEND142(); } int32_t TECEND111(void) { return TECEND142(); } int32_t TECEND110(void) { return TECEND142(); } int32_t TECEND100(void) { return TECEND142(); } int32_t TECEND(void) { return TECEND142(); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecend142_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend112_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend111_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend110_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend100_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend_(void) { return TECEND142(); }
 #endif
int32_t TECLAB142(char const* S) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3976(___689, S); else
 #endif
return ___3998(___689, S); } int32_t TECLAB112(char const* S) { return TECLAB142(S); } int32_t TECLAB111(char const* S) { return TECLAB142(S); } int32_t TECLAB110(char const* S) { return TECLAB142(S); } int32_t TECLAB100(char const* S) { return TECLAB142(S); } int32_t TECLAB(char const* S) { return TECLAB142(S); }
 #if defined ___1232
EXTERNC tecio_API int32_t teclab142_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab112_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab111_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab110_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab100_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab_(char const* S) { return TECLAB142(S); }
 #endif
int32_t TECUSR142(char const* S) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3987(___689, S); else
 #endif
return ___4009(___689, S); } int32_t TECUSR112(char const* S) { return TECUSR142(S); } int32_t TECUSR111(char const* S) { return TECUSR142(S); } int32_t TECUSR110(char const* S) { return TECUSR142(S); } int32_t TECUSR100(char const* S) { return TECUSR142(S); } int32_t TECUSR(char const* S) { return TECUSR142(S); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecusr142_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr112_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr111_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr110_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr100_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr_(char const* S) { return TECUSR142(S); }
 #endif
int32_t TECGEO142( double const*  ___4572, double const*  ___4589, double const*  ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*  ___2985, double const*  ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*  ___187, double const*  ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*   ___4570, float const*   ___4587, float const*   ___4594, char const*    mfc) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3974(___689, ___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); else
 #endif
return ___3996(___689, ___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } int32_t TECGEO112( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } int32_t TECGEO111( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } int32_t TECGEO110( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171,
int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } int32_t TECGEO100( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } int32_t TECGEO( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { int ___494 = (int)___496; return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, &___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecgeo142_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } EXTERNC tecio_API int32_t tecgeo112_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } EXTERNC tecio_API int32_t tecgeo111_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410,
___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } EXTERNC tecio_API int32_t tecgeo110_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } EXTERNC tecio_API int32_t tecgeo100_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___494, int32_t const* ___2834, int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO142(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___494, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); } EXTERNC tecio_API int32_t tecgeo_( double const*   ___4572, double const*   ___4589, double const*   ___4713, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2021, int32_t const* ___1650, int32_t const* ___2262, double const*   ___2985, double const*   ___2288, int32_t const* ___2792, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3441, int32_t const* ___2834,
int32_t const* ___2836, float const*    ___4570, float const*    ___4587, float const*    ___4594, char const*     mfc) { return TECGEO(___4572, ___4589, ___4713, ___3158, ___227, ___4597, Color, ___1410, ___2021, ___1650, ___2262, ___2985, ___2288, ___2792, ___188, ___176, ___187, ___171, ___3441, ___2834, ___2836, ___4570, ___4587, ___4594, mfc); }
 #endif
int32_t TECTXT142( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3986(___689, ___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); else
 #endif
return ___4008(___689, ___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } int32_t TECTXT112( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } int32_t TECTXT111( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } int32_t TECTXT110( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } int32_t TECTXT100( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597,
int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } int32_t TECTXT( double const*   ___4573, double const*   ___4590, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, char const*     Text, char const*     mfc) { double    ___4713     = 0.0; int       ___494 = (int)___496; return TECTXT142(___4573, ___4590, &___4713, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, &___494, Text, mfc); }
 #if defined ___1232
EXTERNC tecio_API int32_t tectxt142_( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } EXTERNC tecio_API int32_t tectxt112_( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } EXTERNC tecio_API int32_t tectxt111_( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } EXTERNC tecio_API int32_t tectxt110_( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403,
int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } EXTERNC tecio_API int32_t tectxt100_( double const*   ___4572, double const*   ___4589, double const*   ___4711, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, int32_t const* ___494, char const*     ___3811, char const*     mfc) { return TECTXT142(___4572, ___4589, ___4711, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, ___494, ___3811, mfc); } EXTERNC tecio_API int32_t tectxt_( double const*   ___4573, double const*   ___4590, int32_t const* ___3158, int32_t const* ___227, int32_t const* ___4597, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2286, int32_t const* ___4079, int32_t const* ___3441, char const*     Text, char const*     mfc) { return TECTXT(___4573, ___4590, ___3158, ___227, ___4597, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2286, ___4079, ___3441, Text, mfc); }
 #endif
int32_t TECFIL142(int32_t const* F) { if ((*F < 1) || (*F > ___2378)) { ___3184("Err: (TECFIL142) Invalid file %d. Number must be between 1 and %d.\n", *F, ___2378); return (-1); } if (!___2040[*F-1]) { ___3183("Err: (TECFIL142) Invalid file %d. File must first be opened with TECINI.\n", *F); return (-1); } ___689 = *F-1; return 0; } int32_t TECFIL112(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL111(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL110(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL100(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL(int32_t const* F) { return TECFIL142(F); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecfil142_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil112_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil111_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil110_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil100_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil_(int32_t const* F) { return TECFIL142(F); }
 #endif
void TECFOREIGN142(int32_t const* ___2889) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) ___3973(___689, ___2889); else
 #endif
___3995(___689, ___2889); } void TECFOREIGN112(int32_t const* ___2889) { TECFOREIGN142(___2889); } void TECFOREIGN111(int32_t const* ___2889) { TECFOREIGN142(___2889); } void TECFOREIGN110(int32_t const* ___2889) { TECFOREIGN142(___2889); } void TECFOREIGN100(int32_t const* ___2889) { TECFOREIGN142(___2889); }
 #if defined ___1232
EXTERNC tecio_API void tecforeign142_(int32_t const* ___2889) { TECFOREIGN142(___2889); } EXTERNC tecio_API void tecforeign112_(int32_t const* ___2889) { TECFOREIGN142(___2889); } EXTERNC tecio_API void tecforeign111_(int32_t const* ___2889) { TECFOREIGN142(___2889); } EXTERNC tecio_API void tecforeign110_(int32_t const* ___2889) { TECFOREIGN142(___2889); } EXTERNC tecio_API void tecforeign100_(int32_t const* ___2889) { TECFOREIGN142(___2889); }
 #endif
int32_t TECAUXSTR142( char const* ___2684, char const* ___4312) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3969(___689, ___2684, ___4312); else
 #endif
return ___3991(___689, ___2684, ___4312); } int32_t TECAUXSTR112( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } int32_t TECAUXSTR111( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } int32_t TECAUXSTR110( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } int32_t TECAUXSTR100( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecauxstr142_( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t tecauxstr112_( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t tecauxstr111_( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t tecauxstr110_( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t tecauxstr100_( char const* ___2684, char const* ___4312) { return TECAUXSTR142(___2684, ___4312); }
 #endif
int32_t TECZAUXSTR142( char const* ___2684, char const* ___4312) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3989(___689, ___2684, ___4312); else
 #endif
return ___4011(___689, ___2684, ___4312); } int32_t TECZAUXSTR112( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } int32_t TECZAUXSTR111( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } int32_t TECZAUXSTR110( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } int32_t TECZAUXSTR100( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); }
 #if defined ___1232
EXTERNC tecio_API int32_t teczauxstr142_( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t teczauxstr112_( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t teczauxstr111_( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t teczauxstr110_( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); } EXTERNC tecio_API int32_t teczauxstr100_( char const* ___2684, char const* ___4312) { return TECZAUXSTR142(___2684, ___4312); }
 #endif
int32_t TECVAUXSTR142( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3988(___689, ___4334, ___2684, ___4312); else
 #endif
return ___4010(___689, ___4334, ___2684, ___4312); } int32_t TECVAUXSTR112( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } int32_t TECVAUXSTR111( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } int32_t TECVAUXSTR110( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } int32_t TECVAUXSTR100( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecvauxstr142_( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } EXTERNC tecio_API int32_t tecvauxstr112_( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } EXTERNC tecio_API int32_t tecvauxstr111_( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } EXTERNC tecio_API int32_t tecvauxstr110_( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); } EXTERNC tecio_API int32_t tecvauxstr100_( int32_t const* ___4334, char const*     ___2684, char const*     ___4312) { return TECVAUXSTR142(___4334, ___2684, ___4312); }
 #endif
int32_t TECFACE142(int32_t const* ___1256) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3972(___689, ___1256); else
 #endif
return ___3994(___689, ___1256); } int32_t TECFACE112(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE111(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE110(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE100(int32_t const* ___1256) { return TECFACE142(___1256); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecface142_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface112_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface111_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface110_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface100_(int32_t const* ___1256) { return TECFACE142(___1256); }
 #endif
int32_t TECPOLY142( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3981(___689, ___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); else
 #endif
return ___4003(___689, ___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); } int32_t TECPOLY112( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); } int32_t TECPOLY111( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int16_t const* ___1254) { int32_t    ___3357 = 0; ___1170 *___1305 = NULL; int32_t ___4188; int32_t ___4189;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___4188 = ___3984(___689); ___4189 = ___3985(___689); } else
 #endif
{ ___4188 = ___4006(___689); ___4189 = ___4007(___689); } if (___4188 > 0) { ___23(___4188, ___1170, "32-bit FaceBndryConnectionZones"); if (___1305 != NULL) { for (___2225 face = 0; face < ___4189; face++) ___1305[face] = (___1170)___1254[face]; } else { ___3182("Err: (TECPOLY111) Out of memory allocating temporary data.\n"); return (-1); } } ___3357 = TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1305); if (___1305 != NULL) ___1528(___1305, "32-bit FaceBndryConnectionZones"); return ___3357; }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpoly142_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpoly112_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpoly111_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int16_t const* ___1254) { return TECPOLY111(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); }
 #endif
int32_t TECPOLYFACE142( int32_t const* ___2804, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3983(___689, ___2804, ___1292, ___1295, ___1257, ___1301); else
 #endif
return ___4005(___689, ___2804, ___1292, ___1295, ___1257, ___1301); } int32_t TECPOLYFACE112( int32_t const* ___2804, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2804, ___1292, ___1295, ___1257, ___1301); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolyface142_( int32_t const* ___2804, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2804, ___1292, ___1295, ___1257, ___1301); } EXTERNC tecio_API int32_t tecpolyface112_( int32_t const* ___2804, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2804, ___1292, ___1295, ___1257, ___1301); }
 #endif
int32_t TECPOLYBCONN142( int32_t const* ___2776, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3982(___689, ___2776, ___1251, ___1252, ___1254); else
 #endif
return ___4004(___689, ___2776, ___1251, ___1252, ___1254); } int32_t TECPOLYBCONN112( int32_t const* ___2776, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2776, ___1251, ___1252, ___1254); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolybconn142_( int32_t const* ___2776, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2776, ___1251, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpolybconn112_( int32_t const* ___2776, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2776, ___1251, ___1252, ___1254); }
 #endif
int32_t TECFEPTN142( int32_t const* ___2975, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3182("Err: (TECFEPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_FEPTN( ___689, ___2975, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecfeptn142_( int32_t const* ___2975, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) { return TECFEPTN142( ___2975, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #endif
int32_t TECIJKPTN142( int32_t const* ___2975, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3182("Err: (TECIJKPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_IJKPTN( ___689, ___2975, imin, jmin, kmin, imax, jmax, kmax); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecijkptn142_( int32_t const* ___2975, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) { return TECIJKPTN142( ___2975, imin, jmin, kmin, imax, jmax, kmax); }
 #endif
int32_t TECMPIINIT142(void* communicator, int32_t const* mainrank) {
 #   if !defined TECIOMPI
___4276(communicator); ___4276(mainrank); ___3182("Err: (TECMPIINIT142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!communicator) return 1; else if (!mainrank || *mainrank < 0) return 2; return TECIOSZL_MPIINIT(&___689, communicator, mainrank);
 #   endif
}
 #if defined ___1232
EXTERNC tecio_API int32_t tecmpiinit142_(void* communicator, int32_t const* mainrank) { return TECMPIINIT142(communicator, mainrank); }
 #endif
int32_t TECZNEMAP142(int32_t const* npartitions, int32_t const* ptnranks) {
 #   if !defined TECIOMPI
___4276(npartitions); ___4276(ptnranks); ___3182("Err: (TECZNEMAP142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!npartitions) ___3182("Err: (TECZNEMAP142) Bad value <NULL> for parameter npartitions.\n"); else if (*npartitions < 1) ___3183("Err: (TECZNEMAP142) Bad value for parameter npartitions: %d.\n", *npartitions); else if (!ptnranks) ___3182("Err: (TECZNEMAP142) Bad value <NULL> for parameter ptnranks.\n"); else return TECIOSZL_ZNEMAP(___689, npartitions, ptnranks); return -1;
 #   endif
}
 #if defined ___1232
EXTERNC tecio_API int32_t tecznemap142_(int32_t* npartitions, int32_t* ptnworkers) { return TECZNEMAP142(npartitions, ptnworkers); }
 #endif
EXTERNC tecio_API int32_t convertrawdata(char const* ___1392) { return tecioszl_convertrawdata(___1392); } namespace { bool validFileHandle(void* fileHandle, char const* routine) { if (fileFormatForHandle.find(fileHandle) == fileFormatForHandle.end()) { std::cerr << "Invalid file handle passed to routine " << routine << std::endl; return false; } else { return true; } } } int32_t tecCustomLabelsGetNumSets(void* fileHandle, int32_t* numSets) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numSets)) { std::cerr << "Invalid 'numSets' parameter to tecCustomLabelsGetNumSets. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_CustomLabelsGetNumSets(fileHandle, numSets); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numCustomLabelSets(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t numSets; if (tecCustomLabelsGetNumSets(fileHandle, &numSets) == 0) return numSets; return 0; } } int32_t tecCustomLabelsGetSet(void* fileHandle, int32_t ___4450, char** labelSet) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4450 <= 0 || numCustomLabelSets(fileHandle) < ___4450) { std::cerr << "Invalid 'whichSet' parameter to tecCustomLabelsGetSet. Must be 0 < whichSet <= numSets (" << numCustomLabelSets(fileHandle) << ")." << std::endl; } else if (!VALID_REF(labelSet) || *labelSet != NULL) { std::cerr << "Invalid 'labelSet' parameter to tecCustomLabelsGetSet. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_CustomLabelsGetSet(fileHandle, ___4450, labelSet); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numDataSetAuxDataItems(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356; tecDataSetAuxDataGetNumItems(fileHandle, &___3356); return ___3356; } } int32_t tecDataSetAuxDataGetItem(void* fileHandle, int32_t whichItem, char** ___2683, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (whichItem <= 0 || numDataSetAuxDataItems(fileHandle) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecDataSetAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; } else if (!VALID_REF(___2683) || *___2683 != NULL) { std::cerr << "Invalid 'name' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetAuxDataGetItem(fileHandle, whichItem, ___2683, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetAuxDataGetNumItems(void* fileHandle, int32_t* ___2810) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (!VALID_REF(___2810)) { std::cerr << "Invalid 'numItems' parameter to tecDataSetAuxDataGetNumItems. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetAuxDataGetNumItems(fileHandle, ___2810); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetGetNumVars(void* fileHandle, int32_t* ___2841) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2841)) { std::cerr << "Invalid 'numVars' parameter to tecDataSetGetNumVars. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetNumVars(fileHandle, ___2841); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2841(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356 = 0; if (tecDataSetGetNumVars(fileHandle, &___3356) == 0) return ___3356; return 0; } } int32_t tecDataSetGetNumZones(void* fileHandle, int32_t* ___2844) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2844)) { std::cerr << "Invalid 'numZones' parameter to tecDataSetGetNumZones. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetNumZones(fileHandle, ___2844); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetGetTitle(void* fileHandle, char** ___4175) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___4175) || *___4175 != NULL) { std::cerr << "Invalid 'title' parameter to tecDataSetGetTitle. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetTitle(fileHandle, ___4175); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecFileGetType(void* fileHandle, int32_t* ___1405) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___1405)) { std::cerr << "Invalid 'fileType' parameter to tecFileGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_FileGetType(fileHandle, ___1405); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecFileReaderClose(void** fileHandle) { int32_t returnCode = -1; if (validFileHandle(*fileHandle, "tecFileReaderClose")) { if (fileFormatForHandle[*fileHandle] == FILEFORMAT_SZL) { returnCode = tecioSZL_FileReaderClose(fileHandle); } else { ___476(!"Not implemented for .plt"); } fileFormatForHandle.erase(*fileHandle); } return returnCode; } int32_t tecFileReaderOpen(char const* ___1392, void** fileHandle) { int32_t ___3356 = 0; if (!___1392 || strlen(___1392) == 0) { std::cerr << "tecFileReaderOpen: Bad fileName parameter."; ___3356 = -1; } if (!fileHandle) { std::cerr << "tecFileReaderOpen: Bad fileHandle parameter.";
___3356 = -1; } *fileHandle = NULL; switch (tecioSZL_FileReaderOpen(___1392, fileHandle)) { case TecioSZLFileOpenResult_OK: fileFormatForHandle[*fileHandle] = FILEFORMAT_SZL; break; case TecioSZLFileOpenResult_ErrorOpeningFile: std::cerr << "tecFileReaderOpen: Error opening file \"" << ___1392 << "\" for reading." << std::endl; ___3356 = -1; break; case TecioSZLFileOpenResult_BadFormat: std::cerr << "tecFileReaderOpen: File \"" << ___1392 << "\" does not appear to be a .szplt file"; ___3356 = -1; break; case TecioSZLFileOpenResult_OutOfMemory: std::cerr << "Error reading file \"" << ___1392 << ".\" Out of memory." << std::endl; ___3356 = -1; break; default: ___476(___1303); ___3356 = -1; break; } ENSURE(EQUIVALENCE(___3356 == 0, VALID_REF(*fileHandle))); return ___3356; } namespace { int32_t numGeoms(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356; if (tecGeomGetNumGeoms(fileHandle, &___3356) == 0) return ___3356; return 0; } bool validGeom(void* fileHandle, int32_t ___1553, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___1553 <= 0 || numGeoms(fileHandle) < ___1553) { std::cerr << "Invalid '___1553' parameter to " << routineName << ". Must be 0 < ___1553 <= numGeoms (" << numGeoms(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecGeomArrowheadGetAngle(void* fileHandle, int32_t ___1553, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___56)) { std::cerr << "Invalid '___56' parameter to tecGeomArrowheadGetAngle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetAngle(fileHandle, ___1553, ___56); } else { ___476(!"Not ___1905 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetAttach(void* fileHandle, int32_t ___1553, int32_t* attachment) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(attachment)) { std::cerr << "Invalid 'attachment' parameter to tecGeomArrowheadGetAttach. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetAttach(fileHandle, ___1553, attachment); } else { ___476(!"Not ___1905 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetSize(void* fileHandle, int32_t ___1553, double* arrowheadSize) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadSize)) { std::cerr << "Invalid 'arrowheadSize' parameter to tecGeomArrowheadGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetSize(fileHandle, ___1553, arrowheadSize); } else { ___476(!"Not ___1905 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetStyle(void* fileHandle, int32_t ___1553, int32_t* arrowheadStyle)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadStyle)) { std::cerr << "Invalid 'arrowheadStyle' parameter to tecGeomArrowheadGetStyle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetStyle(fileHandle, ___1553, arrowheadStyle); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { GeomType_e ___1649(void* fileHandle, int32_t ___1553) { int32_t type; if (tecGeomGetType(fileHandle, ___1553, &type) == 0) return (GeomType_e)type; return GeomType_Invalid; } } int32_t tecGeomCircleGetRadius(void* fileHandle, int32_t ___1553, double* radius) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_Circle) { std::cerr << "Invalid 'geom' parameter to tecGeomCircleGetRadius. The referenced geometry must be a circle." << std::endl; } else if (!VALID_REF(radius)) { std::cerr << "Invalid 'radius' parameter to tecGeomCircleGetRadius. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomCircleGetRadius(fileHandle, ___1553, radius); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomEllipseGetNumPoints(void* fileHandle, int32_t ___1553, int32_t* numEllipsePoints) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_Ellipse && ___1649(fileHandle, ___1553) != GeomType_Circle) { std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetNumPoints. The referenced geometry must be an ellipse or a circle." << std::endl; } else if (!VALID_REF(numEllipsePoints)) { std::cerr << "Invalid 'numEllipsePoints' parameter to tecGeomEllipseGetNumPoints. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomEllipseGetNumPoints(fileHandle, ___1553, numEllipsePoints); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomEllipseGetSize(void* fileHandle, int32_t ___1553, double* horizontalAxis, double* verticalAxis) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_Ellipse) { std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetSize. The referenced geometry must be an ellipse." << std::endl; } else if (!VALID_REF(horizontalAxis)) { std::cerr << "Invalid 'horizontalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(verticalAxis)) { std::cerr << "Invalid 'verticalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomEllipseGetSize(fileHandle, ___1553, horizontalAxis, verticalAxis);
} else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetAnchorPos(void* fileHandle, int32_t ___1553, double* x, double* ___4580, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4580)) { std::cerr << "Invalid 'y' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetAnchorPos(fileHandle, ___1553, x, ___4580, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetClipping(void* fileHandle, int32_t ___1553, int32_t* ___493) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___493)) { std::cerr << "Invalid 'clipping' parameter to tecGeomGetClipping. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetClipping(fileHandle, ___1553, ___493); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetColor(void* fileHandle, int32_t ___1553, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(color)) { std::cerr << "Invalid 'color' parameter to tecGeomGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetColor(fileHandle, ___1553, color); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetCoordMode(void* fileHandle, int32_t ___1553, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(coordMode)) { std::cerr << "Invalid 'coordMode' parameter to tecGeomGetCoordMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetCoordMode(fileHandle, ___1553, coordMode); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetFillColor(void* fileHandle, int32_t ___1553, int32_t* ___1409) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___1409)) { std::cerr << "Invalid 'fillColor' parameter to tecGeomGetFillColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetFillColor(fileHandle, ___1553, ___1409); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetLinePattern(void* fileHandle, int32_t ___1553, int32_t* ___2261)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2261)) { std::cerr << "Invalid 'linePattern' parameter to tecGeomGetLinePattern. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetLinePattern(fileHandle, ___1553, ___2261); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetLineThickness(void* fileHandle, int32_t ___1553, double* ___2287) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2287)) { std::cerr << "Invalid 'lineThickness' parameter to tecGeomGetLineThickness. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetLineThickness(fileHandle, ___1553, ___2287); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetMacroFunctionCmd(void* fileHandle, int32_t ___1553, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL) { std::cerr << "Invalid 'macroFunctionCmd' parameter to tecGeomGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetMacroFunctionCmd(fileHandle, ___1553, macroFunctionCmd); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetNumGeoms(void* fileHandle, int32_t* numGeoms) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numGeoms)) { std::cerr << "Invalid 'numGeoms' parameter to tecGeomGetNumGeoms. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetNumGeoms(fileHandle, numGeoms); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetPatternLength(void* fileHandle, int32_t ___1553, double* ___2984) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2984)) { std::cerr << "Invalid 'patternLength' parameter to tecGeomGetPatternLength. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetPatternLength(fileHandle, ___1553, ___2984); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetScope(void* fileHandle, int32_t ___1553, int32_t* ___3440) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___3440)) { std::cerr << "Invalid 'scope' parameter to tecGeomGetScope. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
{ return tecioSZL_GeomGetScope(fileHandle, ___1553, ___3440); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetType(void* fileHandle, int32_t ___1553, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecGeomGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetType(fileHandle, ___1553, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetZone(void* fileHandle, int32_t ___1553, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(zone)) { std::cerr << "Invalid 'zone' parameter to tecGeomGetZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetZone(fileHandle, ___1553, zone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomIsAttached(void* fileHandle, int32_t ___1553, int32_t* ___2002) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2002)) { std::cerr << "Invalid 'isAttached' parameter to tecGeomIsAttached. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomIsAttached(fileHandle, ___1553, ___2002); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomIsFilled(void* fileHandle, int32_t ___1553, int32_t* ___2020) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2020)) { std::cerr << "Invalid 'isFilled' parameter to tecGeomIsFilled. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomIsFilled(fileHandle, ___1553, ___2020); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2833(void* fileHandle, int32_t ___1553) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356; if (tecGeomLineGetSegmentCount(fileHandle, ___1553, &___3356) == 0) return ___3356; return 0; } int32_t segmentPointCount(void* fileHandle, int32_t ___1553, int32_t segment) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(___1553 > 0); REQUIRE(segment > 0); int32_t pointCount; if (tecGeomLineSegmentGetPointCount(fileHandle, ___1553, segment, &pointCount) == 0) return pointCount; return 0; } } int32_t tecGeomLineGetPoint(void* fileHandle, int32_t ___1553, int32_t segment, int32_t index, double* x, double* ___4580, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_LineSegs && ___1649(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineGetPoint. Must be a line-type geometry." << std::endl;
} else if (segment <= 0 || ___2833(fileHandle, ___1553) < segment) { std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2833(fileHandle, ___1553) << ")." << std::endl; } else if (index < 1 || segmentPointCount(fileHandle, ___1553, segment) < index) { std::cerr << "Invalid 'index' parameter to tecGeomLineGetPoint. Must be 0 < index < segmentPointCount (" << segmentPointCount(fileHandle, ___1553, segment) << " for this segment)." << std::endl; } else if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4580)) { std::cerr << "Invalid 'y' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineGetPoint(fileHandle, ___1553, segment, index, x, ___4580, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomLineGetSegmentCount(void* fileHandle, int32_t ___1553, int32_t* segmentCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_LineSegs && ___1649(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineGetSegmentCount. Must be a line-type geometry." << std::endl; } else if (!VALID_REF(segmentCount)) { std::cerr << "Invalid 'segmentCount' parameter to tecGeomLineGetSegmentCount. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineGetSegmentCount(fileHandle, ___1553, segmentCount); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomLineSegmentGetPointCount(void* fileHandle, int32_t ___1553, int32_t segment, int32_t* pointCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_LineSegs && ___1649(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineSegmentGetPointCount. Must be a line-type geometry." << std::endl; } else if (segment <= 0 || ___2833(fileHandle, ___1553) < segment) { std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2833(fileHandle, ___1553) << ")." << std::endl; } else if (!VALID_REF(pointCount)) { std::cerr << "Invalid 'pointCount' parameter to tecGeomLineSegmentGetPointCount. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineSegmentGetPointCount(fileHandle, ___1553, segment, pointCount); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomRectangleGetSize(void* fileHandle, int32_t ___1553, double* ___4455, double* ___1824)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_Rectangle) { std::cerr << "Invalid 'geom' parameter to tecGeomRectangleGetSize. The referenced geometry must be a rectangle." << std::endl; } else if (!VALID_REF(___4455)) { std::cerr << "Invalid 'width' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___1824)) { std::cerr << "Invalid 'height' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomRectangleGetSize(fileHandle, ___1553, ___4455, ___1824); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomSquareGetSize(void* fileHandle, int32_t ___1553, double* size) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1649(fileHandle, ___1553) != GeomType_Square) { std::cerr << "Invalid 'geom' parameter to tecGeomSquareGetSize. The referenced geometry must be a square." << std::endl; } else if (!VALID_REF(size)) { std::cerr << "Invalid 'size' parameter to tecGeomSquareGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomSquareGetSize(fileHandle, ___1553, size); } else { ___476(!"Not implemented for .plt files"); } return -1; } void tecStringFree(char** string) { delete[] *string; *string = NULL; } int32_t tecStringLength(char const* string) { if (!VALID_REF(string)) return -1; return static_cast<int32_t>(strlen(string)); } namespace { int32_t numTexts(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356; if (tecTextGetNumTexts(fileHandle, &___3356) == 0) return ___3356; return 0; } bool validText(void* fileHandle, int32_t ___4040, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter passed to " << routineName << ". must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecTextBoxGetColor(void* fileHandle, int32_t ___4040, int32_t* ___402) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validText(fileHandle, ___4040, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___402)) { std::cerr << "Invalid 'boxColor' parameter to tecTextBoxGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetColor(fileHandle, ___4040, ___402); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetFillColor(void* fileHandle, int32_t ___4040, int32_t* ___404) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetFillColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___404)) { std::cerr << "Invalid 'boxFillColor' parameter to tecTextBoxGetFillColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetFillColor(fileHandle, ___4040, ___404); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetLineThickness(void* fileHandle, int32_t ___4040, double* ___406) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetLineThickness. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___406)) { std::cerr << "Invalid 'boxLineThickness' parameter to tecTextBoxGetLineThickness. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetLineThickness(fileHandle, ___4040, ___406); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetMargin(void* fileHandle, int32_t ___4040, double* ___408) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetMargin. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___408)) { std::cerr << "Invalid 'boxMargin' parameter to tecTextBoxGetMargin. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetMargin(fileHandle, ___4040, ___408); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetType(void* fileHandle, int32_t ___4040, int32_t* ___410) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetType. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___410)) { std::cerr << "Invalid 'boxType' parameter to tecTextBoxGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetType(fileHandle, ___4040, ___410); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAnchor(void* fileHandle, int32_t ___4040, int32_t* ___38) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetAnchor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___38)) { std::cerr << "Invalid 'anchor' parameter to tecTextGetAnchor. Must be a valid memory reference." << std::endl;
} else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAnchor(fileHandle, ___4040, ___38); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAnchorPos(void* fileHandle, int32_t ___4040, double* x, double* ___4580, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetAnchorPos. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4580)) { std::cerr << "Invalid 'y' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAnchorPos(fileHandle, ___4040, x, ___4580, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAngle(void* fileHandle, int32_t ___4040, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetAngle. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___56)) { std::cerr << "Invalid 'angle' parameter to tecTextGetAngle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAngle(fileHandle, ___4040, ___56); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetClipping(void* fileHandle, int32_t ___4040, int32_t* ___493) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetClipping. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___493)) { std::cerr << "Invalid 'clipping' parameter to tecTextGetClipping. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetClipping(fileHandle, ___4040, ___493); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetColor(void* fileHandle, int32_t ___4040, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(color)) { std::cerr << "Invalid 'color' parameter to tecTextGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetColor(fileHandle, ___4040, color);
} else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetCoordMode(void* fileHandle, int32_t ___4040, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetCoordMode. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(coordMode)) { std::cerr << "Invalid 'coordMode' parameter to tecTextGetCoordMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetCoordMode(fileHandle, ___4040, coordMode); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetHeight(void* fileHandle, int32_t ___4040, double* ___1824) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetHeight. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___1824)) { std::cerr << "Invalid 'height' parameter to tecTextGetHeight. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetHeight(fileHandle, ___4040, ___1824); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetLineSpacing(void* fileHandle, int32_t ___4040, double* ___2285) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetLineSpacing. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___2285)) { std::cerr << "Invalid 'lineSpacing' parameter to tecTextGetLineSpacing. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetLineSpacing(fileHandle, ___4040, ___2285); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetMacroFunctionCmd(void* fileHandle, int32_t ___4040, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetMacroFunctionCmd. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL) { std::cerr << "Invalid 'macroFunctionCmd' parameter to tecTextGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetMacroFunctionCmd(fileHandle, ___4040, macroFunctionCmd); } else { ___476(!"Not implemented for .plt files"); } return -1; } EXTERNC tecio_API int32_t tecTextGetNumTexts(void* fileHandle, int32_t* numTexts) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1;
if (!VALID_REF(numTexts)) { std::cerr << "Invalid 'numTexts' parameter to tecTextGetNumTexts. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetNumTexts(fileHandle, numTexts); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetScope(void* fileHandle, int32_t ___4040, int32_t* ___3440) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetScope. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___3440)) { std::cerr << "Invalid 'scope' parameter to tecTextGetScope. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetScope(fileHandle, ___4040, ___3440); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetSizeUnits(void* fileHandle, int32_t ___4040, int32_t* sizeUnits) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetSizeUnits. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(sizeUnits)) { std::cerr << "Invalid 'sizeUnits' parameter to tecTextGetSizeUnits. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetSizeUnits(fileHandle, ___4040, sizeUnits); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetString(void* fileHandle, int32_t ___4040, char** string) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetString. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(string) || *string != NULL) { std::cerr << "Invalid 'string' parameter to tecTextGetString. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetString(fileHandle, ___4040, string); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetTypeface(void* fileHandle, int32_t ___4040, char** typeface) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetTypeface. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(typeface) || *typeface != NULL) { std::cerr << "Invalid 'typeface' parameter to tecTextGetTypeface. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetTypeface(fileHandle, ___4040, typeface); } else { ___476(!"Not implemented for .plt files");
} return -1; } int32_t tecTextGetZone(void* fileHandle, int32_t ___4040, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextGetZone. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(zone)) { std::cerr << "Invalid 'zone' parameter to tecTextGetZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetZone(fileHandle, ___4040, zone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsAttached(void* fileHandle, int32_t ___4040, int32_t* ___2002) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextIsAttached. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___2002)) { std::cerr << "Invalid 'isAttached' parameter to tecTextIsAttached. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsAttached(fileHandle, ___4040, ___2002); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsBold(void* fileHandle, int32_t ___4040, int32_t* isBold) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextIsBold. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(isBold)) { std::cerr << "Invalid 'isBold' parameter to tecTextIsBold. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsBold(fileHandle, ___4040, isBold); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsItalic(void* fileHandle, int32_t ___4040, int32_t* isItalic) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4040 < 0 || numTexts(fileHandle) < ___4040) { std::cerr << "Invalid 'text' parameter to tecTextIsItalic. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(isItalic)) { std::cerr << "Invalid 'isItalic' parameter to tecTextIsItalic. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsItalic(fileHandle, ___4040, isItalic); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numVarAuxDataItems(void* fileHandle, int32_t ___4333) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(___4333 > 0); int32_t ___2810; if (tecVarAuxDataGetNumItems(fileHandle, ___4333, &___2810) == 0) return ___2810; return 0; } } int32_t tecVarAuxDataGetItem(void* fileHandle, int32_t ___4333, int32_t whichItem, char** ___2683, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetItem. Must be 0 < var <= numVars." << std::endl; } else if (whichItem < 0 || numVarAuxDataItems(fileHandle, ___4333) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecVarAuxDataGetItem. Must be 0 < whichItem <= numItems (" << numVarAuxDataItems(fileHandle, ___4333) << ")." << std::endl; } else if (!VALID_REF(___2683) || *___2683 != NULL) { std::cerr << "Invalid 'name' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarAuxDataGetItem(fileHandle, ___4333, whichItem, ___2683, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarAuxDataGetNumItems(void* fileHandle, int32_t ___4333, int32_t* ___2810) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetNumItems. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(___2810)) { std::cerr << "Invalid 'numItems' parameter to tecVarAuxDataGetNumItems. Must be a valid reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarAuxDataGetNumItems(fileHandle, ___4333, ___2810); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarGetName(void* fileHandle, int32_t ___4333, char** ___2683) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecVarGetName. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(___2683) || *___2683 != NULL) { std::cerr << "Invalid 'name' parameter to tecVarGetName. Must be a valid reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarGetName(fileHandle, ___4333, ___2683); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarIsEnabled(void* fileHandle, int32_t ___4333, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecVarIsEnabled. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(isEnabled)) { std::cerr << "Invalid 'isEnabled' parameter to tecVarIsEnabled. Must be a valid reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarIsEnabled(fileHandle, ___4333, isEnabled); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2844(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3356 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { tecioSZL_DataSetGetNumZones(fileHandle, &___3356);
} else { ___476(!"Not implemented for .plt files"); } return ___3356; } } namespace { int32_t numZoneAuxDataItems(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(0 < zone && zone <= ___2844(fileHandle)); int32_t ___3356 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, &___3356); } else { ___476(!"Not implemented for .plt files"); } return ___3356; } } int32_t tecZoneAuxDataGetItem(void* fileHandle, int32_t zone, int32_t whichItem, char** ___2683, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetItem. Must be 0 < zone <= numZones." << std::endl; } else if (whichItem <= 0 || numZoneAuxDataItems(fileHandle, zone) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecZoneAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; } else if (!VALID_REF(___2683) || *___2683 != NULL) { std::cerr << "Invalid 'name' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneAuxDataGetItem(fileHandle, zone, whichItem, ___2683, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneAuxDataGetNumItems(void* fileHandle, int32_t zone, int32_t* ___2810) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetNumItems. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2810)) { std::cerr << "Invalid 'numItems' parameter to tecZoneAuxDataGetNumItems. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, ___2810); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneConnectivityGetSharedZone(void* fileHandle, int32_t zone, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneConnectivityGetSharedZone. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(sharedZone)) { std::cerr << "Invalid 'sharedZone' parameter to tecZoneConnectivityGetSharedZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneConnectivityGetSharedZone(fileHandle, zone, sharedZone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetConnections(void* fileHandle, int32_t zone, int32_t* connections) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetConnections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(connections)) { std::cerr << "Invalid 'connections' parameter to tecZoneFaceNbrGetConnections. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetConnections(fileHandle, zone, connections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetConnections64(void* fileHandle, int32_t zone, int64_t* connections) { ___4276(fileHandle); ___4276(zone); ___4276(connections); ___476(!"Not implemented"); return -1; } int32_t tecZoneFaceNbrGetMode(void* fileHandle, int32_t zone, int32_t* ___2502) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetMode. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2502)) { std::cerr << "Invalid 'mode' parameter to tecZoneFaceNbrGetMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetMode(fileHandle, zone, ___2502); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetNumConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumConnections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numConnections)) { std::cerr << "Invalid 'numConnections' parameter to tecZoneFaceNbrGetNumConnections. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetNumConnections(fileHandle, zone, numConnections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetNumValues(void* fileHandle, int32_t zone, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumValues. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneFaceNbrGetNumValues. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetNumValues(fileHandle, zone, numValues); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrsAre64Bit(void* fileHandle, int32_t zone, int32_t* are64Bit) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrsAre64Bit. Must be 0 < zone <= numZones." << std::endl;
} else if (!VALID_REF(are64Bit)) { std::cerr << "Invalid 'are64Bit' parameter to tecZoneFaceNbrsAre64Bit. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrsAre64Bit(fileHandle, zone, are64Bit); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetIJK(void* fileHandle, int32_t zone, int64_t* iMax, int64_t* jMax, int64_t* kMax) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetIJK. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(iMax)) { std::cerr << "Invalid 'iMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(jMax)) { std::cerr << "Invalid 'jMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(kMax)) { std::cerr << "Invalid 'kMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetIJK(fileHandle, zone, iMax, jMax, kMax); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetParentZone(void* fileHandle, int32_t zone, int32_t* ___2972) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetParentZone. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2972)) { std::cerr << "Invalid 'parentZone' parameter to tecZoneGetParentZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { *___2972 = 0; return 0; } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetSolutionTime(void* fileHandle, int32_t zone, double* ___3638) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetSolutionTime. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___3638)) { std::cerr << "Invalid 'solutionTime' parameter to tecZoneGetSolutionTime. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetSolutionTime(fileHandle, zone, ___3638); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetStrandID(void* fileHandle, int32_t zone, int32_t* ___3783) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetStrandID. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___3783)) { std::cerr << "Invalid 'strandID' parameter to tecZoneGetStrandID. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
{ return tecioSZL_ZoneGetStrandID(fileHandle, zone, ___3783); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetTitle(void* fileHandle, int32_t zone, char** ___4175) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetTitle. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___4175) || *___4175 != NULL) { std::cerr << "Invalid 'title' parameter to tecZoneGetTitle. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetTitle(fileHandle, zone, ___4175); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetType(void* fileHandle, int32_t zone, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetType. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecZoneGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetType(fileHandle, zone, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetNumSections(void* fileHandle, int32_t zone, int32_t* numSections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetNumSections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numSections)) { std::cerr << "Invalid 'numSections' parameter to tecZoneGetNumSections. Must be a valid memory " "reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetNumSections(fileHandle, zone, numSections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetSectionMetrics( void* fileHandle, int32_t zone, int32_t section, int32_t* cellShape, int32_t* gridOrder, int32_t* basisFunction, int64_t* numElemsInSection, int32_t* numNodesPerCell) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; int32_t numSections{0}; tecZoneGetNumSections(fileHandle, zone, &numSections); if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetSectionMetrics. Must be 0 < zone <= numZones." << std::endl; } else if (section <= 0 || numSections < section) { std::cerr << "Invalid 'section' parameter to tecZoneGetSectionMetrics. Must be 0 < " "section <= numSections(zone)." << std::endl; } else if (!VALID_REF(cellShape)) { std::cerr << "Invalid 'cellShape' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(gridOrder)) { std::cerr << "Invalid 'gridOrder' parameter to tecZoneGetSectionMetrics. Must be a valid memory "
"reference." << std::endl; } else if (!VALID_REF(basisFunction)) { std::cerr << "Invalid 'basisFunction' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(numElemsInSection)) { std::cerr << "Invalid 'numElemsInSection' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(numNodesPerCell)) { std::cerr << "Invalid 'numNodesPerCell' parameter to tecZoneGetSectionMetrics. Must be a " "valid memory " "reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetSectionMetrics(fileHandle, zone, section, cellShape, gridOrder, basisFunction, numElemsInSection, numNodesPerCell); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneIsEnabled(void* fileHandle, int32_t zone, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneIsEnabled. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(isEnabled)) { std::cerr << "Invalid 'isEnabled' parameter to tecZoneIsEnabled. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneIsEnabled(fileHandle, zone, isEnabled); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___4689(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); int32_t type; tecZoneGetType(fileHandle, zone, &type); return type; } bool zoneHasNodeMap(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); int32_t type; tecZoneGetType(fileHandle, zone, &type); return ((1 <= type && type <= 5) || type == 8); } int64_t zoneNumCells(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) return jMax; else return 0; } int32_t nodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2779, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) { *numValues = ___2779 * kMax; return 0; } return -1; } } int32_t tecZoneNodeMapGet(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int32_t* ___2721) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGet. Must be 0 < zone <= numZones." << std::endl; } else if (!zoneHasNodeMap(fileHandle, zone)) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl;
} else if (startCell <= 0) { std::cerr << "Invalid 'startCell' parameter to tecZoneNodeMapGet. Must be > 0." << std::endl; } else if (___2779 <= 0 || zoneNumCells(fileHandle, zone) < startCell + ___2779 - 1) { std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGet. Must be 0 < numCells <= zoneNumCells - startCell + 1." << std::endl; } else if (!VALID_REF(___2721)) { std::cerr << "Invalid 'nodeMap' parameter to tecZoneNodeMapGet. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneNodeMapGet(fileHandle, zone, startCell, ___2779, ___2721); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneNodeMapGet64(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int64_t* ___2721) { ___4276(fileHandle); ___4276(zone); ___4276(startCell); ___4276(___2779); ___4276(___2721); ___476(!"Not implemented"); return 1; } int32_t tecZoneNodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2779, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be 0 < zone <= numZones." << std::endl; } else if (!zoneHasNodeMap(fileHandle, zone)) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl; } else if (___2779 <= 0) { std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGetNumValues. Must be > 0." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneNodeMapGetNumValues. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return nodeMapGetNumValues(fileHandle, zone, ___2779, numValues); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneSectionNodeMapGetNumValues(void* fileHandle, int32_t zone, int32_t section, int64_t ___2779, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; int32_t numSections{0}; tecZoneGetNumSections(fileHandle, zone, &numSections); if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneSectionNodeMapGetNumValues. Must be 0 < zone <= " "numZones." << std::endl; } else if (section <= 0 || numSections < section) { std::cerr << "Invalid 'section' parameter to tecZoneSectionNodeMapGetNumValues. Must be 0 < " "section <= numSections(zone)." << std::endl; } else if (___4689(fileHandle, zone) != 8) { std::cerr << "Invalid 'zone' parameter to tecZoneSectionNodeMapGetNumValues. Must be an " "FEMixed zone." << std::endl; } else if (___2779 <= 0) { std::cerr << "Invalid 'numCells' parameter to tecZoneSectionNodeMapGetNumValues. Must be > 0." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneSectionNodeMapGetNumValues. Must be a valid "
"memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { int32_t cellShape{0}; int32_t gridOrder{0}; int32_t basisFunction{0}; int64_t numElemsInSection{0}; int32_t numNodesPerCell{0}; int32_t ___3356 = tecZoneGetSectionMetrics( fileHandle, zone, section, &cellShape, &gridOrder, &basisFunction, &numElemsInSection, &numNodesPerCell); *numValues = numNodesPerCell * ___2779; return ___3356; } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneNodeMapIs64Bit(void* fileHandle, int32_t zone, int32_t* is64Bit) { ___4276(fileHandle); ___4276(zone); *is64Bit = 0; return 0; } int32_t tecZonePolyGetBoundaryConnectionCounts(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectionCounts) { ___4276(fileHandle); ___4276(zone); ___4276(startConnection); ___4276(numConnections); ___4276(connectionCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetBoundaryConnections(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectedElements, int32_t* connectedZones) { ___4276(fileHandle); ___4276(zone); ___4276(startConnection); ___4276(numConnections); ___4276(connectedElements); ___4276(connectedZones); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceElems(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* leftElems, int32_t* rightElems) { ___4276(fileHandle); ___4276(zone); ___4276(startFace); ___4276(numFaces); ___4276(leftElems); ___4276(rightElems); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodeCounts(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* nodeCounts) { ___4276(fileHandle); ___4276(zone); ___4276(startFace); ___4276(numFaces); ___4276(nodeCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodes(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* ___1294) { ___4276(fileHandle); ___4276(zone); ___4276(startFace); ___4276(numFaces); ___4276(___1294); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetNumConnectedBoundaryFaces(void* fileHandle, int32_t zone, int64_t* numFaces) { ___4276(fileHandle); ___4276(zone); ___4276(numFaces); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumFaceNodes(void* fileHandle, int32_t zone, int64_t* ___2819) { ___4276(fileHandle); ___4276(zone); ___4276(___2819); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumBoundaryConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { ___4276(fileHandle); ___4276(zone); ___4276(numConnections); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl;
return -1; } namespace { int32_t zoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); REQUIRE(VALID_REF(numValues)); *numValues = 0; int32_t isPassive = 0; int32_t ___3356 = tecZoneVarIsPassive(fileHandle, zone, ___4333, &isPassive); if (___3356 == 0 && isPassive == 0) { int64_t iMax; int64_t jMax; int64_t kMax; ___3356 = tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax); if (___3356 == 0) { int32_t ___4689; ___3356 = tecZoneGetType(fileHandle, zone, &___4689); if (___3356 == 0) { int64_t ___2819; int64_t ___2779; if (___4689 == 0) { ___2819 = iMax * jMax * kMax; ___2779 = std::max((int64_t)1, iMax - 1) * std::max((int64_t)1, jMax - 1) * std::max((int64_t)1, kMax - 1); } else { ___2819 = iMax; ___2779 = jMax; } int32_t ___4323; ___3356 = tecZoneVarGetValueLocation(fileHandle, zone, ___4333, &___4323); if (___3356 == 0) { if (___4323 == 0) *numValues = ___2779; else *numValues = ___2819; } } } } return ___3356; } int64_t zoneVarNumValues(void* fileHandle, int32_t zone, int32_t ___4333) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); int64_t numValues; zoneVarGetNumValues(fileHandle, zone, ___4333, &numValues); return numValues; } FieldDataType_e zoneVarType(void* fileHandle, int32_t zone, int32_t ___4333) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4333 > 0); int32_t type; tecZoneVarGetType(fileHandle, zone, ___4333, &type); return static_cast<FieldDataType_e>(type); } bool checkZoneVarGetValuesParameters(char const* routine, FieldDataType_e type, void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, void* values) { REQUIRE(VALID_REF(routine)); REQUIRE(VALID_ENUM(type, FieldDataType_e)); int32_t nZones = ___2844(fileHandle); int64_t nValues = zoneVarNumValues(fileHandle, zone, ___4333); FieldDataType_e actualType = zoneVarType(fileHandle, zone, ___4333); boost::unordered_map<FieldDataType_e, char const*> varTypeNames = boost::assign::map_list_of<FieldDataType_e, char const*> (FieldDataType_Float, "float") (FieldDataType_Double, "double") (FieldDataType_Int32, "int32_t") (FieldDataType_Int16, "int16_t") (FieldDataType_Byte, "uint8_t") (___1363, "bit"); if (!validFileHandle(fileHandle, routine)) return false; else if (zone <= 0 || nZones < zone) std::cerr << "Invalid 'zone' parameter to " << routine << ". Must be 0 < zone <= " << nZones << "." << std::endl; else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) std::cerr << "Invalid 'var' parameter to " << routine << ". Must be 0 < var <= " << ___2841(fileHandle) << "." << std::endl; else if (actualType != type) std::cerr << routine << " called for non-" << varTypeNames[type] << " variable. Variable " << ___4333 << " of zone " << zone << " is of type " << varTypeNames[actualType] << "." << std::endl; else if (startIndex <= 0 || nValues < startIndex) std::cerr << "Invalid 'startIndex' parameter to " << routine << " for zone " << zone << ", var " << ___4333 <<
". Must be 0 < startIndex <= numVarValues (" << nValues << ")." << std::endl; else if (numValues <= 0 || nValues - startIndex + 1 < numValues) std::cerr << "Invalid 'numValues' parameter to " << routine << " for zone " << zone << ", var " << ___4333 << ". Must be 0 < numValues <= numVarValues - startIndex + 1 (" << nValues - startIndex + 1 << ")." << std::endl; else if (!VALID_REF(values)) std::cerr << "Invalid 'values' parameter to " << routine << ". Must be a valid memory reference." << std::endl; else return true; return false; } } int32_t tecZoneVarGetDoubleValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, double* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetDoubleValues", FieldDataType_Double, fileHandle, zone, ___4333, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetDoubleValues(fileHandle, zone, ___4333, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetFloatValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, float* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetFloatValues", FieldDataType_Float, fileHandle, zone, ___4333, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetFloatValues(fileHandle, zone, ___4333, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetInt16Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, int16_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt16Values", FieldDataType_Int16, fileHandle, zone, ___4333, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetInt16Values(fileHandle, zone, ___4333, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetInt32Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, int32_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt32Values", FieldDataType_Int32, fileHandle, zone, ___4333, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetInt32Values(fileHandle, zone, ___4333, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4333, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetNumValues. Must be 0 < zone <= numZones." << std::endl; else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) std::cerr << "Invalid 'var' parameter to tecZoneVarGetNumValues. Must be 0 < var <= numVars." << std::endl;
else if (!VALID_REF(numValues)) std::cerr << "Invalid 'numValues' parameter to tecZoneVarGetNumValues. Must be a valid memory reference." << std::endl; else return zoneVarGetNumValues(fileHandle, zone, ___4333, numValues); return -1; } int32_t tecZoneVarGetSharedZone(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetSharedZone. Must be 0 < zone <= numZones." << std::endl; } else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetSharedZone. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(sharedZone)) { std::cerr << "Invalid 'sharedZone' parameter to tecZoneVarGetSharedZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetSharedZone(fileHandle, zone, ___4333, sharedZone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetType(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetType. Must be 0 < zone <= numZones." << std::endl; } else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetType. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecZoneVarGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetType(fileHandle, zone, ___4333, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetUInt8Values(void* fileHandle, int32_t zone, int32_t ___4333, int64_t startIndex, int64_t numValues, uint8_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetUInt8Values", FieldDataType_Byte, fileHandle, zone, ___4333, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetUInt8Values(fileHandle, zone, ___4333, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetValueLocation(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* location) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetValueLocation. Must be 0 < zone <= numZones." << std::endl; } else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetValueLocation. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(location)) { std::cerr << "Invalid 'location' parameter to tecZoneVarGetValueLocation. Must be a valid memory reference." << std::endl;
} else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetValueLocation(fileHandle, zone, ___4333, location); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarIsPassive(void* fileHandle, int32_t zone, int32_t ___4333, int32_t* isPassive) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2844(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarIsPassive. Must be 0 < zone <= numZones." << std::endl; } else if (___4333 <= 0 || ___2841(fileHandle) < ___4333) { std::cerr << "Invalid 'var' parameter to tecZoneVarIsPassive. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(isPassive)) { std::cerr << "Invalid 'isPassive' parameter to tecZoneVarIsPassive. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarIsPassive(fileHandle, zone, ___4333, isPassive); } else { ___476(!"Not implemented for .plt files"); } return -1; }
