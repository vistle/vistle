#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "ALLOC.h"
#include "SET.h"
 #define SetInitSize          (___2894(1,___3477))
 #define SetExpansionFactor   2
using tecplot::___4215; namespace { void ShiftSetForDelete( ___3500*     ___3474, ___3491 DeletePos); } namespace { ___3481* newSetData(___3491 ___2793) { REQUIRE(___2793 > 0 && ___2793 % ___3477 == 0); { return ___23(___2793 / ___3477, ___3481, "Set data"); } } } namespace { void deleteSetData(___3481* setData) { REQUIRE(VALID_REF(setData)); { ___1528(setData, "Set data"); } } }
 #if defined(_MSC_VER)
 #pragma optimize( "", off )
 #endif
___3500* ___29(___372 ___3572) { ___3500* ___3474 = ALLOC_ITEM(struct ___3500, "Set header"); if (___3474) { ___3474->size = SetInitSize; ___3474->data = newSetData(SetInitSize); if (___3474->data == NULL) ___937(&___3474); else ___491(___3474); } if ((___3474 == NULL) && ___3572) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4215("Out of memory for sets"));
 #endif
 #else
 #endif
} return ___3474; }
 #if defined(_MSC_VER)
 #pragma optimize( "", on )
 #endif
void ___937(___3500** ___3474) { if (___3474 && *___3474) { if ((*___3474)->data) deleteSetData((*___3474)->data); ___1529(*___3474, "Set header"); *___3474 = NULL; } } ___372 ___3494( void       *___2096, ___90  ___492) { ___3500** SetRef = (___3500**)___2096; REQUIRE(VALID_REF(SetRef)); REQUIRE(VALID_REF(*SetRef) || *SetRef == NULL); ___4276(___492); if (*SetRef != NULL) ___937(SetRef); ENSURE(*SetRef == NULL); return ___4224; } namespace { void copySetData( ___3481*       targetSetData, ___3481 const* sourceSetData, ___3491       sourceSetSize) { { size_t sourceSetSizeInBytes = sizeof(sourceSetData[0]) * (sourceSetSize / ___3477); memcpy(targetSetData, sourceSetData, sourceSetSizeInBytes); } } } namespace { void initSetData( ___3481* setData, ___3491 startMember, ___3491 numMembers) { { size_t startOffsetInBytes = sizeof(setData[0]) * (startMember / ___3477); size_t numBytesToInit     = sizeof(setData[0]) * (numMembers / ___3477); memset(((char*)setData) + startOffsetInBytes, 0, numBytesToInit); } } } ___372 ___1199( ___3500*     ___3474, ___3491 max_val, ___372  ___3572) { ___3481  *data; ___3491  new_size; REQUIRE(max_val >= 0); if (!___3474) { if (___3572) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4215("Null Set expand"));
 #endif
 #else
 #endif
} return ___1303; } if (max_val <= ___3474->size) return ___4224; new_size = ___3474->size; while (new_size < max_val) new_size *= SetExpansionFactor; new_size = ___2894(new_size, ___3477); data = newSetData(new_size); if (!data) { if (___3572) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4215("Out of memory for sets"));
 #endif
 #else
 #endif
} return ___1303; } copySetData(data, ___3474->data, ___3474->size); initSetData(data, ___3474->size, (new_size - ___3474->size)); deleteSetData(___3474->data); ___3474->data = data; ___3474->size = new_size; return ___4224; } ___372 ___674( ___3500*       ___1119, ___3500 const* ___3654, ___372    ___3572) { if (___1119 && ___1119->data && ___3654 && ___3654->data && ___1199(___1119, ___3654->size, ___3572)) { copySetData(___1119->data, ___3654->data, ___3654->size); if (___1119->size > ___3654->size) initSetData(___1119->data, ___3654->size, (___1119->size - ___3654->size)); return ___4224; } else return ___1303; } ___372 AllocAndCopySet( ___3500*&      ___1119, ___3500 const* ___3654) { ___372 ___2037 = ___4224; ___1119 = ___29(___1303); ___2037 = ___1119 != NULL && ___674(___1119,___3654,___1303); if (!___2037) ___937(&___1119); ENSURE(IMPLICATION(!___2037,___1119 == NULL)); return ___2037; } ___372 ___83( ___3500*       ___1119, ___3500 const* ___3654, ___372    ___3572) { if (___1119 && ___1119->data && ___3654 && ___3654->data) { ___3491 ___2399; ___1470(___2399, ___3654) { if (!___17(___1119, ___2399, ___3572)) return ___1303; } return ___4224; } else return ___1303; } void ___491(___3500* ___3474) { if (___3474 && ___3474->data) initSetData(___3474->data, 0, ___3474->size); }
 #if defined USE_FUNCTIONS_FOR_SETS
___372 ___17( ___3500*     ___3474, ___3491 ___2399, ___372  ___3572) { REQUIRE(___2399 >= 0); if (___3474 && (___2399 + 1 <= ___3474->size || ___1199(___3474, ___2399 + 1, ___3572))) { ___3491 word = ___2399 / ___3477; ___3478 bit = (___3478)1 << (___2399 % ___3477); ___3474->data[word] |= bit; return ___4224; } else return ___1303; }
 #endif
___372 AddRangeToSet( ___3500*     ___3474, ___3491 memberStart, ___3491 memberEnd) { ___372 ___2037 = ___4224; REQUIRE(memberStart >= 0); REQUIRE(memberEnd >= memberStart); if (___3474 && (memberEnd + 1 <= ___3474->size || ___1199(___3474, memberEnd + 1, ___1303))) { for (___3491 ___2399 = memberStart; ___2037 && ___2399 <= memberEnd; ++___2399) { ___2037 = ___17(___3474,___2399,___1303); } } else { ___2037 = ___1303; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } void ___3332( ___3500*     ___3474, ___3491 ___2399) { REQUIRE(___2399 >= 0); if (___3474 && (___2399 < ___3474->size) && ___3474->data) { ___3491 word = ___2399 / ___3477; ___3478  bit = (___3478)1 << (___2399 % ___3477); ___3474->data[word] &= (((___3478)(-1)) ^ bit); } } void ___955( ___3500*     ___3474, ___3491 ___2400) { REQUIRE(VALID_REF(___3474)); REQUIRE(___2400 >= 0); ShiftSetForDelete(___3474, ___2400); } ___372 ___1953( ___3500*     ___3474, ___3491 ___2400, ___372  ___3569) { ___372  ___2038 = ___4224; ___3491 OrigLastMember; REQUIRE(VALID_REF(___3474)); OrigLastMember = ___1767(___3474, ___333); if (___2400 <= OrigLastMember) { ___2038 = ___1199(___3474, (OrigLastMember + 1) + 1, ___3569); ___3558(___3474, ___2400, OrigLastMember, 1); } if (___2038) ___2038 = ___17(___3474, ___2400, ___3569); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #if defined USE_FUNCTIONS_FOR_SETS
___372 ___1954( ___3500 const* ___3474, ___3491   ___2399) { if (___3474 && (0 <= ___2399 && ___2399 < ___3474->size)) { ___3491 word = ___2399 / ___3477; ___3478  bit = (___3478)1 << (___2399 % ___3477); return (___3474->data[word]&bit) != 0; } else return ___1303; }
 #endif
___372 ___2013(___3500 const* ___3474) { if (___3474 && ___3474->data) { ___3491 set_size_in_words = ___3474->size / ___3477; ___3491 word; for (word = 0; word < set_size_in_words; word++) { ___3478 word_val = ___3474->data[word]; if (word_val != 0) return ___1303; } } return ___4224; } ___372 ___1820(___3500 const* ___3474) { ___372  ___3357 = ___1303; ___3491 ContiguousMember = 0; ___3491 ___2400 = 0; REQUIRE(VALID_REF(___3474)); ___1470(___2400, ___3474) { if (___2400 == ContiguousMember) { ContiguousMember++; } else { ___3357 = ___4224; break; } } ENSURE(VALID_BOOLEAN(___3357)); return ___3357; } ___3491 ___2401(___3500 const* ___3474) { ___3491 count = 0; if (___3474 && ___3474->data) { ___3491 set_size_in_words = ___3474->size / ___3477; ___3491 word; for (word = 0; word < set_size_in_words; word++) { ___3478 word_val = ___3474->data[word]; while (word_val) { if (word_val&1) count++; word_val = word_val >> 1; } } } return count; } ___372 ___2031(___3500 const* ___3474) { ___3491 count = 0; if (___3474 && ___3474->data) { ___3491 set_size_in_words = ___3474->size / ___3477; for (___3491 word = 0; word < set_size_in_words; ++word) { ___3478 word_val = ___3474->data[word]; while (word_val) { if (word_val & 1) { if(++count > 1) return ___1303; } word_val = word_val >> 1; } } } return count == 1; }
 #if !defined UNITTEST
___3491 ___1759( ___3500 const* ___3474, ___3491   ___3680) { ___3491 next_member = ___333; if (___3474 && ___3474->data) { ___3491 set_size_in_words = ___3474->size / ___3477; ___3491 word; ___3478 word_val = 0; int bit; if (___3680 == ___333) { word = 0; bit = 0; if (word < set_size_in_words) { word_val = ___3474->data[0]; } } else if (___3680 + 1 < ___3474->size) { word = (___3680 + 1) / ___3477; bit = static_cast<int>((___3680 + 1) % ___3477); if (word < set_size_in_words) { word_val = ___3474->data[word] >> bit; } } else { return ___333; } while ((word < set_size_in_words) && (word_val == 0)) { word++; bit = 0; if (word < set_size_in_words) { word_val = ___3474->data[word]; } } if (word < set_size_in_words) { while (!(word_val&1)) { word_val >>= 1; bit++; } next_member = word * ___3477 + bit; } } return next_member; }
 #endif
___3491 ___1767( ___3500 const* ___3474, ___3491   ___3680) { ___3491 next_member = ___333; if (___3474 && ___3474->data) { ___3491 set_size_in_words = ___3474->size / ___3477; ___3491 word; ___3478 word_val = 0; int bit; if (___3680 == ___333) { word = set_size_in_words - 1; bit = ___3477 - 1; if (word >= 0) { word_val = ___3474->data[word]; } } else if (___3680 > 0) { word = (___3680 - 1) / ___3477; bit = static_cast<int>((___3680 - 1) % ___3477); if (word >= 0) { word_val = ___3474->data[word] << (___3477 - bit - 1); } } else { return ___333; } while ((word >= 0) && (word_val == 0)) { word--; bit = static_cast<int>(___3477 - 1); if (word >= 0) { word_val = ___3474->data[word] << (___3477 - bit - 1); } } if (word >= 0) { while (!(word_val&___3496)) { word_val <<= 1; bit--; } next_member = word * ___3477 + bit; } } return next_member; } ___372 ___1173( ___3500 const* ___3475, ___3500 const* ___3476) { ___3491 set1_size_in_words, set2_size_in_words, min_set_size_in_words, ___1839; if (!___3475 || !___3476) return ___1303; set1_size_in_words = ___3475->size / ___3477; set2_size_in_words = ___3476->size / ___3477; min_set_size_in_words = MIN(set1_size_in_words, set2_size_in_words); for (___1839 = 0; ___1839 < min_set_size_in_words; ___1839++) { { if (___3475->data[___1839] != ___3476->data[___1839]) return ___1303; } } for (___1839 = min_set_size_in_words; ___1839 < set1_size_in_words; ___1839++) { { if (___3475->data[___1839] != 0) return ___1303; } } for (___1839 = min_set_size_in_words; ___1839 < set2_size_in_words; ___1839++) { { if (___3476->data[___1839] != 0) return ___1303; } } return ___4224; } ___3500* intersection( ___3500 const* ___3475, ___3500 const* ___3476) { ___3500* ___3356 = ___29(___1303); ___3491 const largestMember = MAX(___1749(___3475),___1749(___3476)); if (___3356 && !___1199(___3356, largestMember, ___1303)) ___937(&___3356); if (___3356 && !___2013(___3475) && !___2013(___3476)) { ___3491 mOffset1 = ___1744(___3475); ___3491 mOffset2 = ___1744(___3476); for (; mOffset1 != ___333 && mOffset2 != ___333; ) { if (mOffset1 == mOffset2) (void)___17(___3356, mOffset1, ___1303); bool const advance1 = mOffset1 <= mOffset2; bool const advance2 = mOffset2 <= mOffset1; if (advance1) mOffset1 = ___1759(___3475, mOffset1); if (advance2) mOffset2 = ___1759(___3476, mOffset2); } } ENSURE(VALID_REF_OR_NULL(___3356)); return ___3356; } ___372 ___2060( ___3500 const* ___484, ___3500 const* ___2971) { ___3491 s; ___1470(s, ___484) { if (!___1954(___2971, s)) return (___1303); } return (___4224); } ___3491 ___2402( ___3500 const* ___3474, ___3491   ___2400) { ___3491 ___1830; ___3491 ___2864 = -1; if (___1954(___3474, ___2400)) { for (___1830 = 0; ___1830 <= ___2400; ___1830++) { if (___1954(___3474, ___1830)) ___2864++; } } return (___2864); } ___3491 ___2865( ___3500 const* ___3474, ___3491   ___2864) { ___3491 ___1830; ___3491 ___2400 = ___333; for (___1830 = 0; ___1830 <= ___2864; ___1830++) { ___2400 = ___1759(___3474, ___2400); if (___2400 == ___333) break; } return (___2400);
} ___372 ___675( ___3500*       ___1124, ___3491   ___1123, ___3500 const* ___3661, ___3491   ___3660) { if (___1954(___3661, ___3660)) return (___17(___1124, ___1123, ___4224)); else ___3332(___1124, ___1123); return (___4224); } void ___3558( ___3500*     ___3474, ___3491 ___3556, ___3491 ___3557, ___3491 ___3554) { ___3500*     NewSet; ___3491 DPos; ___3491 SPos; if ((___3474 == NULL) || (___2013(___3474))) return; NewSet = ___29(___4224); if (NewSet == NULL) return; if (!___674(NewSet, ___3474, ___4224)) return; if (___3554 < 0) { DPos = ___3557; SPos = ___3556 - 1; while (DPos > ___3557 + ___3554) ___675(NewSet, DPos--, ___3474, SPos--); SPos = ___3557; while (SPos >= ___3556) ___675(NewSet, DPos--, ___3474, SPos--); } else if (___3554 > 0) { DPos       = ___3556; SPos       = ___3557 + 1; while (DPos < ___3556 + ___3554) ___675(NewSet, DPos++, ___3474, SPos++); SPos = ___3556; while (SPos <= ___3557) ___675(NewSet, DPos++, ___3474, SPos++); } ___674(___3474, NewSet, ___4224); ___937(&NewSet); } namespace {
 #if defined DEBUG_SET
void printWord(unsigned long word) { ___3478 ___2342 = 0x00000001; ___3478 shiftedw = word; for (int i = 0; i < ___3477; ++i) { if (___2342 & shiftedw) putchar('1'); else putchar('0'); shiftedw >>= 1; } } void printSet(___3500 const* ___3474) { ___3491 nWords = ___3474->size / ___3477; for (___3491 i = 0; i < nWords; ++i) { printWord(___3474->data[i]); putchar('|'); } putchar('\n'); }
 #endif 
void ShiftSetForDelete(___3500* ___3474, ___3491 DeletePos) { if ((___3474 == NULL) || (___2013(___3474))) return;
 #if defined DEBUG_SET
printf("Deleting member at %8ld in set: ",(long)DeletePos); printSet(___3474);
 #endif
___3491 nWords = ___3474->size / ___3477; ___3491 word_start_shift = DeletePos / ___3477; for (___3491 word = word_start_shift; word < nWords; ++word) { ___3478 word_val = ___3474->data[word]; ___3478 word_val_final = word_val; if (word > word_start_shift) { word_val_final >>= 1; } else { ___3478 mask1 = ((___3478)1 << DeletePos) - 1; ___3478 mask2 = ~mask1; ___3478 word_val_shifted = word_val; word_val_shifted >>= 1; word_val_shifted |= mask1; word_val |= mask2; word_val_final = (word_val & word_val_shifted); } if( word < nWords-1) { ___3478 word_val_next = ___3474->data[word+1]; ___3478 bit = (((___3478)1 & word_val_next) << (___3477-1)); word_val_final |= bit; } ___3474->data[word] = word_val_final; }
 #if defined DEBUG_SET
printf("Resulting set                     : "); printSet(___3474);
 #endif
} }
