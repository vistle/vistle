#include "SZLFEPartitionedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <new>
#include <set>
#include "ThirdPartyHeadersEnd.h"
#include "FEZoneInfo.h"
#include "FieldData.h"
#include "ItemSetIterator.h"
#include "SZLFEPartitionWriter.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
namespace tecplot { namespace ___3931 { SZLFEPartitionedZoneWriter::SZLFEPartitionedZoneWriter( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4633                   zone, ___4633                   ___341, std::vector<___372> const& ___4561, ___372                     ___4496, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache) : ___4706(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36) , m_headerWriter( fileVersion, varIter, zone, ___341, ___36, m_partitionFileNums, m_partitionHeaderFilePositions, m_secPtnNumCells, m_partitionNumNodes, m_varPartitionMinMaxes) , ___2678(zoneInfoCache) , m_partitionTecUtil(___36, zone + 1) { REQUIRE(0 <= zone && ___36.___4635(zone + 1)); REQUIRE(VALID_BOOLEAN(___4496)); REQUIRE(___36.zoneIsPartitioned(zone + 1)); size_t const numVarsToWrite = static_cast<size_t>(m_varIter.___2810()); size_t const numPartitions = static_cast<size_t>(___36.zoneGetNumPartitions(zone + 1)); ___4262 const datasetID = ___2335.datasetGetUniqueID(); ___1170 numSections = 1; if (___2335.___4617(zone + 1) == ZoneType_FEMixed) { if (!___2335.zoneGetNumSections(datasetID, zone + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } if (!m_partitionFileNums.alloc(numPartitions, 0) || !m_partitionHeaderFilePositions.alloc(numPartitions, ___330) || !___3354(m_secPtnNumCells, numSections, numPartitions) || !m_partitionNumNodes.alloc(numPartitions, 0) || !___3354(m_varPartitionMinMaxes, numVarsToWrite, numPartitions)) throw std::bad_alloc(); } SZLFEPartitionedZoneWriter::~SZLFEPartitionedZoneWriter() {} namespace { template <typename NODE_TYPE> bool gatherConnectedCellInfoForTypedNode( SubzoneAddressUnorderedSet&                        cellSubzones, std::vector<___2477>&                               varMinMaxes, int64_t                                            ___2707, ___2722 const&                                     ___2721, PartitionTecUtilDecorator const&                   partitionTecUtil, std::vector<___1350> const&                      fieldDatas, ___1348 const&                                  zoneInfo, std::vector<boost::unordered_set<int64_t> > const& secGhostCellSet) { REQUIRE(cellSubzones.empty()); REQUIRE(varMinMaxes.size() == fieldDatas.size()); REQUIRE(0 < ___2707); REQUIRE(___2721.___2065()); REQUIRE(IMPLICATION(fieldDatas[0].___2065(), fieldDatas[0].___1784() == ___4327)); REQUIRE(IMPLICATION(fieldDatas.back().___2065(), fieldDatas.back().___1784() == ___4327)); REQUIRE(secGhostCellSet.size() == static_cast<size_t>(___2721.numSections())); bool foundConnectedNonGhostCell = false; ___2740 nodeToElemMap = partitionTecUtil.dataNodeToElemMapGetReadableRef(zoneInfo.getPartition() + 1); for(___463 elemIndex = 1; elemIndex <= partitionTecUtil.dataNodeToElemMapGetNumElems(nodeToElemMap, ___2707); ++elemIndex)
{ ___463 globalCell = partitionTecUtil.dataNodeToElemMapGetElem(nodeToElemMap, ___2707, elemIndex); ___2722::SectionCell const sectionCell = ___2721.convertGlobalCell(globalCell); if (secGhostCellSet[sectionCell.sectionIndex-1].find(sectionCell.___460) != secGhostCellSet[sectionCell.sectionIndex-1].end()) continue; foundConnectedNonGhostCell = true; ItemAddress64 const& szCoordinate = zoneInfo.itemAddressAtCell(sectionCell.sectionIndex-1, sectionCell.___460-1); cellSubzones.insert(szCoordinate.subzoneAddress()); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ___2721.getElemNodes<NODE_TYPE>(sectionCell.sectionIndex, sectionCell.___460, 1, elemNodes.data()); int32_t const numNodesPerCell = zoneInfo.getNumNodesPerCell(sectionCell.sectionIndex-1); for(int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { int64_t cellNode = elemNodes[nOffset]; for(size_t i = 0; i < varMinMaxes.size(); ++i) { if (fieldDatas[i].___2065()) { double ___4296 = fieldDatas[i].___1778(cellNode); varMinMaxes[i].include(___4296); } else { varMinMaxes[i].include(0.0); } } } } return foundConnectedNonGhostCell; } } namespace { bool gatherConnectedCellInfoForNode( SubzoneAddressUnorderedSet&                        cellSubzones, std::vector<___2477>&                               varMinMaxes, int64_t                                            ___2707, ___2722 const&                                     ___2721, PartitionTecUtilDecorator const&                   partitionTecUtil, std::vector<___1350> const&                      fieldDatas, ___1348 const&                                  zoneInfo, std::vector<boost::unordered_set<int64_t> > const& secGhostCellSet) { return ___2721.getOffsetDataType() == OffsetDataType_32Bit ? gatherConnectedCellInfoForTypedNode<int32_t>( cellSubzones,varMinMaxes,___2707,___2721,partitionTecUtil,fieldDatas,zoneInfo,secGhostCellSet) : gatherConnectedCellInfoForTypedNode<int64_t>( cellSubzones,varMinMaxes,___2707,___2721,partitionTecUtil,fieldDatas,zoneInfo,secGhostCellSet); } } void SZLFEPartitionedZoneWriter::gatherNeighborCellSubzoneInfo( NeighborCellSubzoneInfoMap&   neighborCellSubzoneInfoMap, ItemAddress64::___2978    ___2975, ___4349                    ___2841, ___2722&                      ___2721, std::vector<___1350> const& fieldDatas, ___1348 const&             zoneInfo) { std::vector<boost::unordered_set<int64_t> > secGhostCellSet(___2721.numSections()); for (___1170 section = 0; section < ___2721.numSections(); ++section) { GhostInfo_pa partitionGhostCellInfo = ___2335.zonePartitionGhostCellInfoGetRef(___2675 + 1, ___2975 + 1); for(___81 itemNum = 1; itemNum <= ___2335.ghostInfoGetNumItemsByRef(partitionGhostCellInfo, section+1); ++itemNum) { ___81 ___447 = ___2335.ghostInfoGetItemByRef(partitionGhostCellInfo, section+1, itemNum); secGhostCellSet[section].insert(static_cast<int32_t>(___447)); } } GhostInfo_pa partitionGhostNodeInfo = ___2335.zonePartitionGhostNodeInfoGetRef(___2675 + 1, ___2975 + 1);
for(___81 itemNum = 1; itemNum <= ___2335.ghostInfoGetNumItemsByRef(partitionGhostNodeInfo,1 ); ++itemNum) { ___81 ___2707 = ___2335.ghostInfoGetItemByRef(partitionGhostNodeInfo, 1 , itemNum); ItemAddress64::___2978 neighbor = ___2335.ghostInfoGetNeighborByRef(partitionGhostNodeInfo, itemNum); ___81 neighborNode = ___2335.ghostInfoGetNeighborItemByRef(partitionGhostNodeInfo, itemNum); SubzoneAddressUnorderedSet cellSubzones; std::vector<___2477> varMinMaxes(___2841); if (gatherConnectedCellInfoForNode(cellSubzones, varMinMaxes, ___2707, ___2721, m_partitionTecUtil, fieldDatas, zoneInfo, secGhostCellSet)) { NeighborCellSubzoneInfo& neighborCellSubzoneInfo = neighborCellSubzoneInfoMap[neighbor - 1]; neighborCellSubzoneInfo.m_nodes.push_back(___2707 - 1); neighborCellSubzoneInfo.m_neighborNodes.push_back(neighborNode - 1); neighborCellSubzoneInfo.m_cellSubzones.push_back(cellSubzones); neighborCellSubzoneInfo.m_varMinMaxes.push_back(varMinMaxes); } } } void SZLFEPartitionedZoneWriter::exchangeGhostInfo(std::vector<boost::shared_ptr<___1348> >& partitionInfos) { PartitionTecUtilDecorator partitionTecUtilDecorator(___2335, ___2675 + 1); ___4349 const numVarsToWrite = m_varIter.___2810(); ItemAddress64::___2978 const numPartitions = static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1)); for(ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { ___2722 ___2721(&partitionTecUtilDecorator, ___2975 + 1); std::vector<___1350> fieldDatas(numVarsToWrite); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (___2335.___4350(datasetVar + 1) && !___2335.___924(___2675 + 1, datasetVar + 1)) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4327) fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, false); else fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, true); } } NeighborCellSubzoneInfoMap neighborCellSubzoneInfoMap; gatherNeighborCellSubzoneInfo(neighborCellSubzoneInfoMap, ___2975, numVarsToWrite, ___2721, fieldDatas, *(partitionInfos[___2975])); std::set<ItemAddress64::___2978> referencedPartitions; for(ItemAddress64::___2978 i = 0; i < partitionInfos[___2975]->getNumReferencedPartitions(); ++i) referencedPartitions.insert(partitionInfos[___2975]->getReferencedPartitions()[i]); for (NeighborCellSubzoneInfoMap::iterator valuePair = neighborCellSubzoneInfoMap.begin(); valuePair != neighborCellSubzoneInfoMap.end(); ++valuePair) { ItemAddress64::___2978 const neighbor = valuePair->first; NeighborCellSubzoneInfo const& neighborCellSubzoneInfo = valuePair->second; referencedPartitions.insert(neighbor); partitionInfos[neighbor]->addNeighborCszInfo(___2975, neighborCellSubzoneInfo.m_neighborNodes,
neighborCellSubzoneInfo.m_cellSubzones, neighborCellSubzoneInfo.m_varMinMaxes); for(size_t i = 0; i < neighborCellSubzoneInfo.m_nodes.size(); ++i) { ItemAddress64 const& szCoordinate = partitionInfos[neighbor]->itemAddressAtNode(neighborCellSubzoneInfo.m_neighborNodes[i]); partitionInfos[___2975]->addNeighborNodeCoordinate(neighborCellSubzoneInfo.m_nodes[i], szCoordinate); } } if (!referencedPartitions.empty()) partitionInfos[___2975]->addReferencedPartitions(referencedPartitions); } } void SZLFEPartitionedZoneWriter::createPartitionWriters() { ___4262 const datasetID = ___2335.datasetGetUniqueID(); ___1170 numSections = 1; if (___2335.___4617(___2675 + 1) == ZoneType_FEMixed) { if (!___2335.zoneGetNumSections(datasetID, ___2675 + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } ___476(m_secPtnNumCells.size() == static_cast<size_t>(numSections)); std::vector<boost::shared_ptr<___1348> > partitionInfos; for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { partitionInfos.push_back(___2678.getFEZonePartitionInfo(___2675, ___2975, m_partitionTecUtil)); for (___1170 section = 0; section < numSections; ++section) m_secPtnNumCells[section][___2975] = partitionInfos[___2975]->numCellsInSection(section) - partitionInfos[___2975]->getNumGhostCells(section); m_partitionNumNodes[___2975] = partitionInfos[___2975]->___1766() - partitionInfos[___2975]->getNumGhostNodes(); } exchangeGhostInfo(partitionInfos); for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { m_partitionWriters[___2975] = boost::make_shared<SZLFEPartitionWriter> ( m_fileVersion, boost::ref(m_varIter), ___2675, m_baseZone, ___2975, boost::ref(m_writeVariables), m_writeConnectivity, boost::ref(m_partitionTecUtil), partitionInfos[___2975]); } } ___372 SZLFEPartitionedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) { if (m_partitionWriters.empty()) createPartitionWriters(); for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { m_partitionWriters[___2975]->writeZone(szpltFile, szpltFile.fileLoc()); m_partitionHeaderFilePositions[___2975] = m_partitionWriters[___2975]->getZoneHeaderFilePosition(); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; m_varPartitionMinMaxes[fileVar][___2975] = m_partitionWriters[___2975]->varMinMax(datasetVar); } } return ___4224; } uint64_t SZLFEPartitionedZoneWriter::zoneDataFileSize(bool ___2000) { if (m_partitionWriters.empty()) createPartitionWriters(); uint64_t ___3356 = 0; for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) ___3356 += m_partitionWriters[___2975]->zoneFileSize(___2000); return ___3356;
} ___372 SZLFEPartitionedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4224; } uint64_t SZLFEPartitionedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } ___372 SZLFEPartitionedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2039()); return m_headerWriter.write(szpltFile); } uint64_t SZLFEPartitionedZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } }}
