 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
 #define _USE_MATH_DEFINES
#include <cmath> 
 #if defined MSWIN
 #define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
 #pragma warning (disable:4996) 
 #endif
#include <cstdarg>
#include <cstdlib>
#include <cstring>
#include <set>
#include <string>
#include <utility>
#include <vector>
#include <boost/functional/hash.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "ClassMacros.h"
#include "MinMax.h"
#include "basicTypes.h"
#include "IJK.h"
#include "ItemAddress.h"
#include "LightweightVector.h"
#include "AnyTypeLightweightVector.h"
#include "RawArray.h"
#include "showMessage.h"
#include "xyz.h"
namespace tecplot { namespace ___3931 { class CszConnectivity;
 #define MAX_ERROR_MESSAGE_SIZE 500
 #define countOf(staticArray) ( sizeof((staticArray))/sizeof((staticArray)[0]) )
 #define numItemsOf(someArray) ( sizeof((someArray))/sizeof(*(someArray)) )
static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_I_DIM = 6; static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_J_DIM = 6; static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_K_DIM = 6;
 #define DEFAULT_SUBZONE_MAX_IJK_DIM ___1842(DEFAULT_SUBZONE_MAX_I_DIM, DEFAULT_SUBZONE_MAX_J_DIM, DEFAULT_SUBZONE_MAX_K_DIM)
static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_FE_SIZE = 256; static bool const DEFAULT_MINIMIZE_IJK_NUM_SUBZONES = false; static bool const DEFAULT_MINIMIZE_SYNTHETIC_FE_NUM_SUBZONES = false; static ___4633 const NOT_SHARED = static_cast<___4633>(-1); static ItemAddress64::SectionOffset_t const MAX_NUM_SECTIONS = ItemAddress64::MAX_SECTION_OFFSET+1; typedef ___2238<ItemAddress64>                 ItemAddressArray; typedef ___2238<ItemAddress64::SubzoneAddress> SubzoneAddressArray; template<typename T> inline bool reserveVectorSpace(std::vector<T>& vectorToReserve, size_t newSize) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToReserve.reserve(newSize); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToReserve.capacity()>=newSize)); return ___2037; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToResize, size_t newSize) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToResize.resize(newSize); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToResize.size()==newSize)); return ___2037; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToSize, size_t newSize, T padValue) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToSize.resize(newSize, padValue); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToSize.size()==newSize)); return ___2037; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2037 = false; try { vector2D.resize(newDim1); for ( size_t ___1839 = 0; ___1839 < newDim1; ___1839++ ) vector2D[___1839].resize(newDim2); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2037, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1-1].size()==newDim2)); return ___2037; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2, T padValue) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2037 = false; try { vector2D.resize(newDim1); for ( size_t ___1839 = 0; ___1839 < newDim1; ___1839++ ) vector2D[___1839].resize(newDim2, padValue); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2037, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1-1].size()==newDim2)); return ___2037; } template<typename T> inline void clearAndDeallocStdSet(std::set<T>& setToClear) { std::set<T>().swap(setToClear); } typedef ___2238<char>     ___471; typedef ___2238<uint8_t>  UInt8Array; typedef ___2238<uint16_t> UInt16Array; typedef ___2238<uint32_t> UInt32Array; typedef ___2238<uint64_t> UInt64Array; typedef ___2238<int32_t>  ___1963;
typedef ___2238<int64_t>  Int64Array; typedef ___2238<double>   ___1103; typedef ___2238<float>    ___1433; typedef ___2238<___463>                    ___462; typedef ___2238<___2716>                    ___2715; typedef ___2238<___4633>                    ___4632; typedef ___2238<ItemAddress64::SubzoneOffset_t> SubzoneOffsetArray; typedef ___2238<ItemAddress64::ItemOffset_t>    ItemOffsetArray; typedef ___2238<___372>                      BooleanArray; typedef ___2238<std::string>                    ___3814; typedef std::set<ItemAddress64::SubzoneAddress> SubzoneAddressSet; typedef ___2238<SubzoneAddressSet>  SubzoneAddressSetArray; struct SubzoneAddressHasher { inline std::size_t operator()(ItemAddress64::SubzoneAddress const& ___3878) const { std::size_t seed = 0; boost::hash_combine(seed, ___3878.___2975()); boost::hash_combine(seed, ___3878.sectionOffset()); boost::hash_combine(seed, ___3878.subzoneOffset()); return seed; } }; struct SubzoneAddressPredicate { inline bool operator()( ItemAddress64::SubzoneAddress const& ___2227, ItemAddress64::SubzoneAddress const& ___3390) const { return ___2227 == ___3390; } }; typedef boost::unordered_set< ItemAddress64::SubzoneAddress, SubzoneAddressHasher, SubzoneAddressPredicate> SubzoneAddressUnorderedSet; typedef std::set<ItemAddress64::SubzoneOffset_t> SubzoneOffsetSet; typedef ___2238<SubzoneOffsetSet>    SubzoneOffsetSetArray; typedef ___2238<UInt8Array>       VarZoneUInt8Array; typedef ___2238<___1391>        ___1390; typedef ___2238<___1390>     FileLoc2DArray; typedef ___2238<FileLoc2DArray>   FileLoc3DArray; typedef ___2238<FileLoc3DArray>   FileLoc4DArray; typedef ___2238<FileLoc4DArray>   FileLoc5DArray;
 #if 0
typedef ___1390                             SzFileLocArray; typedef ___2238<SzFileLocArray>        PtnSzFileLocArray; typedef ___2238<PtnSzFileLocArray>     ZonePtnSzFileLocArray; typedef ___2238<ZonePtnSzFileLocArray> VarZonePtnSzFileLocArray; typedef ___1390                             PtnFileLocArray; typedef ___2238<PtnFileLocArray>       ZnPtnFileLocArray; typedef ___1390                             VarFileLocArray; typedef ___2238<VarFileLocArray>       PtnVarFileLocArray; typedef ___2238<PtnVarFileLocArray>    ZonePtnVarFileLocArray; typedef ___1390                             ZoneFileLocArray; typedef ___2238<ZoneFileLocArray>      VarZoneFileLocArray;
 #endif
typedef AnyTypeLightweightVector                 FieldDataArray; typedef ___2238<FieldDataArray>        SzFieldData; typedef ___2238<SzFieldData>           PtnSzFieldData; typedef ___2238<PtnSzFieldData>        SecPtnSzFieldData; typedef ___2238<SecPtnSzFieldData>     ZoneSecPtnSzFieldData; typedef ___2238<ZoneSecPtnSzFieldData> VarZoneSecPtnSzFieldData; typedef uint16_t InterpCount_t; static InterpCount_t const MAX_INTERP_COUNT = InterpCount_t(-1); typedef ___2238<InterpCount_t>                InterpCountArray; typedef ___2238<InterpCountArray>             SzInterpCountArray; typedef ___2238<SzInterpCountArray>           PtnSzInterpCountArray; typedef ___2238<PtnSzInterpCountArray>        SecPtnSzInterpCountArray; typedef ___2238<SecPtnSzInterpCountArray>     ZoneSecPtnSzInterpCountArray; typedef ___2238<ZoneSecPtnSzInterpCountArray> VarZoneSecPtnSzInterpCountArray; typedef ___2238<BooleanArray>            PtnBooleanArray; typedef ___2238<PtnBooleanArray>         SecPtnBooleanArray; typedef ___2238<SecPtnBooleanArray>      ZoneSecPtnBooleanArray; typedef ___2238<ZoneSecPtnBooleanArray>  VarZoneSecPtnBooleanArray; typedef ___2238<uint8_t>                ValueLocationArray; typedef ___2238<ValueLocationArray>     ___4388; typedef ___2238<uint8_t>                FieldDataTypeArray; typedef ___2238<FieldDataTypeArray>     ___4379; typedef ___2238<uint8_t>        IsPassiveArray; typedef ___2238<IsPassiveArray> ___4382; typedef ___2238<___4632> ___4385; typedef ___2238<___1103> VarZoneDoubleArray; typedef ___2238<ItemAddress64::___2978> PartitionArray; struct ___230 { std::string ___2493; std::string ___2665; AuxDataLocation_e m_location; ___1170 m_entity; AuxDataType_e m_type; ___230() {} ___230( std::string const& ___2683, std::string const& value, AuxDataLocation_e location, ___1170 entity, AuxDataType_e type) : ___2493(___2683) , ___2665(value) , m_location(location) , m_entity(entity) , m_type(type) {} }; struct ___1554 { double ___2615[3]; CoordSys_e ___2614; ___372 ___2482; ___1170 ___2675; ___514 ___2393; ___514 ___2460; ___372 ___2484; GeomType_e ___2464; LinePattern_e ___2487; double ___2613; double ___2488; uint16_t ___2500; ArrowheadStyle_e ___2341; ArrowheadAttachment_e ___2339; double ___2340; double ___2338; Scope_e ___2617; Clipping_e ___2392; std::vector<std::vector<class ___4577> > ___2462; std::string ___2489; ___1554() {} ___1554( double ___4571, double ___4588, double ___4712, CoordSys_e ___3157, ___372 ___2002, ___1170 zone, ___514 color, ___514 ___1409, ___372 ___2020,
GeomType_e ___1649, LinePattern_e ___2261, double ___2984, double ___2287, uint16_t ___2791, ArrowheadStyle_e arrowheadStyle, ArrowheadAttachment_e arrowheadAttachment, double arrowheadSize, double arrowheadAngle, Scope_e ___3440, Clipping_e ___493, std::vector<std::vector<___4577> > const& ___1570, std::string const& ___2328) : ___2614(___3157) , ___2482(___2002) , ___2675(zone) , ___2393(color) , ___2460(___1409) , ___2484(___2020) , ___2464(___1649) , ___2487(___2261) , ___2613(___2984) , ___2488(___2287) , ___2500(___2791) , ___2341(arrowheadStyle) , ___2339(arrowheadAttachment) , ___2340(arrowheadSize) , ___2338(arrowheadAngle) , ___2617(___3440) , ___2392(___493) , ___2462(___1570) , ___2489(___2328) { ___2615[0] = ___4571; ___2615[1] = ___4588; ___2615[2] = ___4712; } }; struct Text { ___514 ___2626; ___514 ___2627; double ___2628; double ___2629; TextBox_e ___2630; TextAnchor_e ___2623; double ___2624[3]; double ___2625; Clipping_e ___2631; ___514 ___2632; double ___2633; double ___2635; std::string ___2636; CoordSys_e ___2637; Scope_e ___2639; Units_e ___2640; std::string ___2641; std::string ___2642; ___372 ___2643; ___372 ___2644; ___1170 ___2645; ___372 ___2634; Text() {} Text( double ___4571, double ___4588, double ___4710, ___514 ___4057, ___514 ___4059, double ___4069, double ___4071, TextBox_e ___4076, TextAnchor_e ___4041, double ___4054, Clipping_e ___4077, ___514 ___4078, double ___4101, double ___4105, std::string ___4107, CoordSys_e ___4113, Scope_e ___4117, Units_e ___4122, std::string ___4124, std::string ___4127, ___372 ___4130, ___372 ___4132, ___1170 ___4136, ___372 ___4103) : ___2626(___4057) , ___2627(___4059) , ___2628(___4069) , ___2629(___4071) , ___2630(___4076) , ___2623(___4041) , ___2625(___4054) , ___2631(___4077) , ___2632(___4078) , ___2633(___4101) , ___2635(___4105) , ___2636(___4107) , ___2637(___4113) , ___2639(___4117) , ___2640(___4122) , ___2641(___4124) , ___2642(___4127) , ___2643(___4130) , ___2644(___4132) , ___2645(___4136) , ___2634(___4103) { ___2624[0] = ___4571;
___2624[1] = ___4588; ___2624[2] = ___4710; } }; struct CustomLabelSet { uint32_t m_numLabels; ___3814 m_labels; }; typedef ___2238<___230> AuxDataArray; typedef ___2238<___1554> GeomArray; typedef ___2238<Text> TextArray; typedef ___2238<CustomLabelSet> CustomLabelsArray; typedef ___2238<RefSubzoneOffset_t>    RefSubzoneOffsetArray; class NszConnectivity { UNCOPYABLE_CLASS(NszConnectivity); public: SubzoneAddressArray m_refCszs; RefSubzoneOffset_t   m_numRefCszs; NszConnectivity() : m_numRefCszs(0) { } ~NszConnectivity() { ___935(); } uint64_t numBytesAllocated(void) const { return m_refCszs.numBytesAllocated(m_numRefCszs); } void ___935() { m_numRefCszs = 0; m_refCszs.___935(); ENSURE(empty()); } bool setNumRszs(RefSubzoneOffset_t numRszs) { REQUIRE(___2065()); REQUIRE(numRszs != BAD_REFSZ_INDEX); bool ___2037; if ( numRszs == 0 ) { m_numRefCszs = numRszs; ___476(m_refCszs.empty()); ___2037 = true; } else { ___2037 = m_refCszs.alloc(numRszs); if ( ___2037 ) m_numRefCszs = numRszs; else ___935(); } ENSURE(___2065()); return ___2037; } inline bool ___2065() const { ___476(EQUIVALENCE(m_refCszs.empty(), m_numRefCszs == 0)); ___476(IMPLICATION(!m_refCszs.empty(), m_refCszs.size() == size_t(m_numRefCszs))); return true; } inline bool empty() const { REQUIRE(___2065()); return m_numRefCszs==0; } inline RefSubzoneOffset_t getNumRszs() const { REQUIRE(___2065()); return m_numRefCszs; } inline ItemAddress64::SubzoneAddress const& getRszAddress(RefSubzoneOffset_t refSubzoneOffset) const { REQUIRE(___2065()); REQUIRE(refSubzoneOffset<getNumRszs()); return m_refCszs[refSubzoneOffset]; } inline bool getRszAddresses(___3267<ItemAddress64::SubzoneAddress>& rszAddresses) const { REQUIRE(___2065()); REQUIRE(rszAddresses.empty()); bool ___2037 = true; try { ___476(m_numRefCszs>0); rszAddresses.reserve(m_numRefCszs); rszAddresses.___3501(m_numRefCszs); memcpy(rszAddresses.data(), m_refCszs.data(), m_numRefCszs*sizeof(ItemAddress64::SubzoneAddress)); } catch (...) { ___2037 = ___1184("Out of memory in getRefCszAddresses"); } return ___2037; } }; typedef ___2238<CszConnectivity>             CszConnectivityArray; typedef ___2238<CszConnectivityArray>        PtnCszConnectivity; typedef ___2238<PtnCszConnectivity>          SecPtnCszConnectivity; typedef ___2238<SecPtnCszConnectivity>       ZoneSecPtnCszConnectivity; typedef ___2238<RefSubzoneOffsetArray>       PtnRefSubzoneOffsetArray; typedef ___2238<PtnRefSubzoneOffsetArray>    SecPtnRefSubzoneOffsetArray; typedef ___2238<SecPtnRefSubzoneOffsetArray> ZoneSecPtnRefSubzoneOffsetArray; typedef ___2238<NszConnectivity>             NszConnectivityArray; typedef ___2238<NszConnectivityArray>        PtnNszConnectivity; typedef ___2238<PtnNszConnectivity>          ZonePtnNszConnectivity; typedef ___2238<ItemOffsetArray>             ZoneSzSizeArray; typedef ___2238<___463>                 CellSubzoneFirstItemArray;
typedef ___2238<CellSubzoneFirstItemArray>   ZoneCszFirstItemArray; typedef ___2238<___2716>                 NodeSubzoneFirstItemArray; typedef ___2238<NodeSubzoneFirstItemArray>   ZoneNszFirstItemArray; typedef ___2238<___81>                  AnySzFirstItemArray; typedef ___2238<AnySzFirstItemArray>         ZoneAnySzFirstItemArray; typedef ___2238<___2477>                      ___2479; typedef ___2238<___2479>                 VarZoneMinMaxArray; }}
