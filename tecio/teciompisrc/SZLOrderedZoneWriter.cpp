#include "SZLOrderedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <sstream>
#include <stdexcept>
#include <boost/assign.hpp>
#include "ThirdPartyHeadersEnd.h"
 #if !defined TECIOMPI
#include "AtomicMinMax.h"
 #endif
#include "checkPercentDone.h"
#include "FieldData.h"
#include "fileStuff.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3931 {
 #if !defined TECIOMPI
namespace { int const MINMAX_MAX_TASKS_PER_CORE = 2; int const MINMAX_MIN_CSZ_TASK_SIZE  = 16; }
 #endif
SZLOrderedZoneWriter::SZLOrderedZoneWriter( uint32_t                                    fileVersion, ItemSetIterator&                            varIter, ___4633                                 zone, ___4633                                 ___341, std::vector<___372> const&               ___4561, ___372                                   ___4496, ___37&                                 ___36, boost::shared_ptr<___1879 const> const& ijkZoneInfo) : ___4706(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36) , m_headerWriter(fileVersion, varIter, zone, ___341, ___36, *ijkZoneInfo, ___2671) , m_ijkZoneInfo(ijkZoneInfo) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) { ___4349 const numVarsToWrite = m_varIter.___2810(); if (!___2671.alloc(numVarsToWrite, ___330)) { std::ostringstream ___2890; ___2890 << "Unable to allocate arrays for outputting zone " << zone; throw std::runtime_error(___2890.str()); } } SZLOrderedZoneWriter::~SZLOrderedZoneWriter() {} void SZLOrderedZoneWriter::setZoneNumberLabel(std::string const& zoneNumberLabel) { REQUIRE(!zoneNumberLabel.empty()); m_zoneNumberLabel = zoneNumberLabel; } namespace { struct CellMinMaxData { ItemAddress64::SubzoneOffset_t cellSubzoneStart; ItemAddress64::SubzoneOffset_t cellSubzoneEnd; ___1879 const& ijkZoneInfo; ___1350 const& nlFieldData; ___1350 const& ccFieldData;
 #if defined TECIOMPI
___2479& cszMinMaxArray; ___2479& ___2760;
 #else
___2238<___225<double> >& cszMinMaxArray; ___2238<___225<double> >& ___2760;
 #endif
CellMinMaxData( ItemAddress64::SubzoneOffset_t cellSubzoneStart, ItemAddress64::SubzoneOffset_t cellSubzoneEnd, ___1879 const& ijkZoneInfo, ___1350 const& nlFieldData, ___1350 const& ccFieldData,
 #if defined TECIOMPI
___2479& cszMinMaxArray, ___2479& ___2760)
 #else
___2238<___225<double> >& cszMinMaxArray, ___2238<___225<double> >& ___2760)
 #endif
: cellSubzoneStart(cellSubzoneStart) , cellSubzoneEnd(cellSubzoneEnd) , ijkZoneInfo(ijkZoneInfo) , nlFieldData(nlFieldData) , ccFieldData(ccFieldData) , cszMinMaxArray(cszMinMaxArray) , ___2760(___2760) {} }; ___1842 calculateStoredNodeIJK(___1879 const& ijkZoneInfo) { ___1842 ___3356 = ijkZoneInfo.___2712(); if (!ijkZoneInfo.includeIMaxNodesInSubzones()) ___3356.setI(___3356.i() + 1); if (!ijkZoneInfo.includeJMaxNodesInSubzones()) ___3356.setJ(___3356.___2103() + 1); if (!ijkZoneInfo.includeKMaxNodesInSubzones()) ___3356.___3495(___3356.___2132() + 1); return ___3356; } void calculateAndApplyCellMinMaxes(___90 ___2121) { CellMinMaxData* cellMinMaxData = reinterpret_cast<CellMinMaxData*>(___2121); REQUIRE(cellMinMaxData->nlFieldData.___2065()); ___1842 outputIJK = cellMinMaxData->ijkZoneInfo.___2712(); ___1842 storedIJK = calculateStoredNodeIJK(cellMinMaxData->ijkZoneInfo); ___81 cellCorners[] = { 0, 1, storedIJK.i(), storedIJK.i() + 1, storedIJK.i() * storedIJK.___2103(), storedIJK.i() * storedIJK.___2103() + 1, storedIJK.i() * storedIJK.___2103() + storedIJK.i(), storedIJK.i() * storedIJK.___2103() + storedIJK.i() + 1 }; ___81 nodes[8]; ___3267<___81> nodeArray(nodes, 8); for (ItemAddress64::SubzoneOffset_t ___467 = cellMinMaxData->cellSubzoneStart; ___467 < cellMinMaxData->cellSubzoneEnd; ++___467) { ___1842 ___1878 = cellMinMaxData->ijkZoneInfo.___688(___467); ___1842 ___1850 = cellMinMaxData->ijkZoneInfo.___687(___467); for (___81 i = ___1878.i(); i <= ___1850.i(); ++i) { for (___81 ___2103 = ___1878.___2103(); ___2103 <= ___1850.___2103(); ++___2103) { for (___81 ___2132 = ___1878.___2132(); ___2132 <= ___1850.___2132(); ++___2132) { ___2477 cellMinMax; ___81 const datasetPt = (___2132 * storedIJK.___2103() + ___2103) * storedIJK.i() + i; for (int n = 0; n < 8; ++n) cellMinMax.include(cellMinMaxData->nlFieldData.___1778(datasetPt + cellCorners[n] + 1)); nodeArray.clear(); nodeArray.push_back((___2132 * outputIJK.___2103() + ___2103) * outputIJK.i() + i); if (i < outputIJK.i() - 1) nodeArray.push_back(nodeArray[0] + 1); if (___2103 < outputIJK.___2103() - 1) { size_t ___2819 = nodeArray.size(); for (size_t n = 0; n < ___2819; ++n) nodeArray.push_back(nodeArray[n] + outputIJK.i()); } if (___2132 < outputIJK.___2132() - 1) { size_t ___2819 = nodeArray.size(); for (size_t n = 0; n < ___2819; ++n) nodeArray.push_back(nodeArray[n] + outputIJK.i() * outputIJK.___2103()); } for (size_t n = 0; n < nodeArray.size(); ++n) { ItemAddress64::SubzoneOffset_t ___2732 = cellMinMaxData->ijkZoneInfo.nodeSubzoneOffsetAtNodeIndex(nodeArray[n]); cellMinMaxData->___2760[___2732].include(cellMinMax); } if (cellMinMaxData->ccFieldData.___2065()) cellMinMax.include(cellMinMaxData->ccFieldData.___1778(datasetPt + 1)); cellMinMaxData->cszMinMaxArray[___467].include(cellMinMax); } } } } delete cellMinMaxData; } ___372 getIJKCellAndNodeSubzoneMinMaxes( ___37& ___36, ___1879 const& ijkZoneInfo, ___4349 fileVar, ___1350 const& nlFieldData, ___1350 const& ccFieldData, ___2479& cszMinMaxArray, ___2479& ___2760)
{ REQUIRE(fileVar >= 0); REQUIRE(nlFieldData.___2065()); REQUIRE("ccFieldData might be invalid if not CC data"); ___372 ___2037 = ___4224; ItemAddress64::SubzoneOffset_t const ___2781 = ijkZoneInfo.getNumCszs();
 #if !defined NO_ASSERTS || !defined TECIOMPI
ItemAddress64::SubzoneOffset_t const ___2821 = ijkZoneInfo.getNumNszs();
 #endif
 #ifndef NO_ASSERTS
for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) ___476(!___2760[___2732].___2065()); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) ___476(!cszMinMaxArray[___467].___2065());
 #endif
 #if defined TECIOMPI
___4276(___36); CellMinMaxData* cellMinMaxData = new CellMinMaxData(0, ___2781, ijkZoneInfo, nlFieldData, ccFieldData, cszMinMaxArray, ___2760); calculateAndApplyCellMinMaxes(reinterpret_cast<___90>(cellMinMaxData));
 #else
___2238<___225<double> > atomicCszMinMaxArray; ___2238<___225<double> > atomicNszMinMaxArray; ___2037 = atomicCszMinMaxArray.alloc(___2781) && atomicNszMinMaxArray.alloc(___2821); if (___2037) { size_t const maxNumTasks = static_cast<size_t>(___36.___4155() * MINMAX_MAX_TASKS_PER_CORE); size_t const numCszTasksAtMinJobSize = static_cast<size_t>(___2781 + MINMAX_MIN_CSZ_TASK_SIZE - 1) / MINMAX_MIN_CSZ_TASK_SIZE; size_t const numCszTasks = std::min(numCszTasksAtMinJobSize, maxNumTasks); ___2118 ___2117 = ___36.___4156(); ItemAddress64::SubzoneOffset_t cellSubzoneStart = 0; for (size_t task = 1; task <= numCszTasks; ++task) { ItemAddress64::SubzoneOffset_t const cellSubzoneEnd = static_cast<ItemAddress64::SubzoneOffset_t>(___2781 * task / numCszTasks); ___476(cellSubzoneStart < cellSubzoneEnd); CellMinMaxData* cellMinMaxData = new CellMinMaxData(cellSubzoneStart, cellSubzoneEnd, ijkZoneInfo, nlFieldData, ccFieldData, atomicCszMinMaxArray, atomicNszMinMaxArray); ___36.___4154(calculateAndApplyCellMinMaxes, (___90)cellMinMaxData, ___2117); cellSubzoneStart = cellSubzoneEnd; } ___36.___4159(___2117); ___36.___4157(&___2117); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ++___467) { ENSURE(atomicCszMinMaxArray[___467].___2065()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].minValue()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].maxValue()); } for (ItemAddress64::SubzoneOffset_t ___2732 = 0; ___2037 && ___2732 < ___2821; ++___2732) { ENSURE(atomicNszMinMaxArray[___2732].___2065()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].minValue()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].maxValue()); } atomicCszMinMaxArray.___935(); atomicNszMinMaxArray.___935(); }
 #endif
if (___2037) { ___1879::NszMinMaxMap const& nszMinMaxes = ijkZoneInfo.getNszMinMaxes(); for (___1879::NszMinMaxMap::const_iterator valuePair = nszMinMaxes.begin(); valuePair != nszMinMaxes.end(); ++valuePair) { ___2760[valuePair->first].include(valuePair->second[fileVar]); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 SZLOrderedZoneWriter::calculateVarSubzoneMinMaxes( ___4349   datasetVar, ___2479& ___2760, ___2479& cszMinMaxArray) { REQUIRE(cszMinMaxArray.empty()); REQUIRE(___2760.empty()); REQUIRE(m_writeVariables[datasetVar - m_varIter.baseItem()]); ___372 ___2037 = ___4224; ___2037 = ___2037 && cszMinMaxArray.alloc(m_ijkZoneInfo->getNumCszs(), ___2477()); ___2037 = ___2037 && ___2760.alloc(m_ijkZoneInfo->getNumNszs(), ___2477()); if (___2037) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4327) { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___1350 ccFieldData; ___2037 = nlFieldData.___2065() && getIJKCellAndNodeSubzoneMinMaxes(___2335, *m_ijkZoneInfo, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2760); } else { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , true/*___962*/); ___1350 ccFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___2037 = nlFieldData.___2065() && ccFieldData.___2065() && getIJKCellAndNodeSubzoneMinMaxes(___2335, *m_ijkZoneInfo, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2760); } } return ___2037; } ___372 SZLOrderedZoneWriter::___4509( FileWriterInterface&           file, ValueLocation_e                ___4323, ___4349                     datasetVar, ItemAddress64::SubzoneOffset_t ___3878) { REQUIRE(file.___2039()); REQUIRE(___4323 == ___4325 || ___4323 == ___4327); ___372 ___2037 = ___4224; if (file.___2000()) { if (___4323 == ___4325) ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, SZPLT_CSZ_FIELD_DATA_MARKER_DESCRIPTION, SZPLT_CSZ_FIELD_DATA_MARKER); else ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, SZPLT_NSZ_FIELD_DATA_MARKER_DESCRIPTION, SZPLT_NSZ_FIELD_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, SZPLT_VARIABLE_NUM_DESCRIPTION, (datasetVar - m_varIter.baseItem()) + 1); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), ___2675 - m_baseZone + 1); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZPLT_SUBZONE_NUM_DESCRIPTION, ___3878 + 1); ___1842 const ___1878 = (___4323 == ___4325) ? m_ijkZoneInfo->___688(___3878) : m_ijkZoneInfo->___2759(___3878); ___1842 const ___1850 = (___4323 == ___4325) ? m_ijkZoneInfo->___687(___3878) : m_ijkZoneInfo->___2758(___3878); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_ISTART_DESCRIPTION, ___1878.i()+1);
___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_IEND_DESCRIPTION, ___1850.i()+1); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_JSTART_DESCRIPTION, ___1878.___2103()+1); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_JEND_DESCRIPTION, ___1850.___2103()+1); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_KSTART_DESCRIPTION, ___1878.___2132()+1); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, SZL_KEND_DESCRIPTION, ___1850.___2132()+1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template<typename T, bool isBitArray  > ___372 SZLOrderedZoneWriter::___1777( ___1350 const& ___1349, ___1842 const&       ___1878, ___1842 const&       ___1850, ___1842 const&       ___1859, ___2238<T>& ___4297) { ___372 ___2037 = ___4224; REQUIRE(___1349.___2065()); REQUIRE(___1859.i() >=2 && ___1859.___2103() >= 2); REQUIRE(0<=___1878 && ___1878 <= ___1850 && ___1850 < ___1859); size_t const ___3266 = size_t(___1875(___1878, ___1850)); ___476(___4297.empty()); ___2037 = ___2037 && ___4297.alloc(___3266); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2037) { ___81 const ijMax = ___1859.i()*___1859.___2103(); ___81 ___4298 = 0; for ( ___81 ___2156 = ___1878.___2132(); ___2156 <= ___1850.___2132(); ___2156++ ) { ___81 const ___2162 = ___2156*ijMax; for ( ___81 ___2111 = ___1878.___2103(); ___2111 <= ___1850.___2103(); ___2111++ ) { ___81 const jkOffset = ___2162 + ___2111*___1859.i(); for ( ___81 ___1839 = ___1878.i(); ___1839 <= ___1850.i(); ___1839++ ) { ___81 const datasetPt = jkOffset + ___1839; if (rawPointer) ___4297[___4298] = rawPointer[datasetPt]; else ___4297[___4298] = static_cast<T>(___1349.___1778(datasetPt + 1)); ___4298++; } } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template<> ___372 SZLOrderedZoneWriter::___1777<uint8_t, true>( ___1350 const& ___1349, ___1842 const&       ___1878, ___1842 const&       ___1850, ___1842 const&       ___1859, ___2238<uint8_t>& ___4297) { ___372 ___2037 = ___4224; REQUIRE(___1349.___2065()); REQUIRE(___1859>=2); REQUIRE(0<=___1878 && ___1878 <= ___1850 && ___1850 < ___1859); size_t const ___3266 = size_t(numBytesForNumBits(___1875(___1878, ___1850))); ___476(___4297.empty()); ___2037 = ___2037 && ___4297.alloc(___3266); memset(___4297.data(), 0, ___3266); if (___2037) { ___81 const ijMax = ___1859.i()*___1859.___2103(); ___81 ___4298 = 0; for ( ___81 ___2156 = ___1878.___2132(); ___2156 <= ___1850.___2132(); ___2156++ ) { ___81 const ___2162 = ___2156*ijMax; for ( ___81 ___2111 = ___1878.___2103(); ___2111 <= ___1850.___2103(); ___2111++ ) { ___81 const jkOffset = ___2162 + ___2111*___1859.i(); for ( ___81 ___1839 = ___1878.i(); ___1839 <= ___1850.i(); ___1839++ ) { ___81 const datasetPt = jkOffset + ___1839 + 1; double const ___4296 = ___1349.___1778(datasetPt); if (___4296 < 1.0) clearBit(___4297, ___4298); else setBit(___4297, ___4298); ___4298++; } } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::___4493(
FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4325); ___2238<T> valueArray; ItemAddress64::ItemOffset_t ___2780 = m_ijkZoneInfo->getNumCellsInCsz(___467); ___1842 const cellIJKStart = m_ijkZoneInfo->___688(___467); ___1842 const cellIJKEnd   = m_ijkZoneInfo->___687(___467); ___2037 = ___2037 && ___1777<T, isBitArray>( ___1349, cellIJKStart, cellIJKEnd, m_ijkZoneInfo->___2893(), valueArray); if (isBitArray) ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "cszFieldData", ___2743, numBytesForNumBits(___2780), valueArray.data()); else ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "cszFieldData", ___2743, ___2780, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::___4528( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ___1842 const&                     storedIJK, ItemAddress64::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4327); ___2238<T> valueArray; ItemAddress64::ItemOffset_t ___2820 = m_ijkZoneInfo->getNumNodesInNsz(___2732); ___1842 const nodeIJKStart = m_ijkZoneInfo->___2759(___2732); ___1842 const nodeIJKEnd   = m_ijkZoneInfo->___2758(___2732); ___2037 = ___2037 && ___1777<T, isBitArray>( ___1349, nodeIJKStart, nodeIJKEnd, storedIJK, valueArray); if (isBitArray) ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "nszFieldData", ___2743, numBytesForNumBits(___2820), valueArray.data()); else ___2037 = ___2037 && ___4560<T, false, 0>(szpltFile, "nszFieldData", ___2743, ___2820, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::writeVariable( FileWriterInterface&     szpltFile, ___4349 const         datasetVar, ___2479 const&       nszDataMinMax, ___2479 const&       cszDataMinMax) { ItemAddress64::SubzoneOffset_t const ___2781 = m_ijkZoneInfo->getNumCszs(); ItemAddress64::SubzoneOffset_t const ___2821 = m_ijkZoneInfo->getNumNszs(); ___4349 const fileVar = datasetVar - m_varIter.baseItem(); ___372 ___2037 = ___4525<T>(szpltFile, NODE_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2821, nszDataMinMax.data(), ___944 / 2) && ___4525<T>(szpltFile, CELL_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2781, cszDataMinMax.data(), ___944 / 2);
___1350 ___1349(&___2335, ___2675 + 1, datasetVar + 1); ___2037 = ___2037 && ___1349.___2065(); ValueLocation_e const ___4323 = ___1349.___1784(); ItemAddress64::SubzoneOffset_t const numDataSubzones = (___4323 == ___4325) ? ___2781 : ___2821; ___1842 storedNodeIJK = calculateStoredNodeIJK(*m_ijkZoneInfo); for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___2037 && ___3921 < numDataSubzones; ___3921++) { ___2037 = ___4509(szpltFile, ___4323, datasetVar, ___3921); if (___4323 == ___4325) ___2037 = ___2037 && ___4493<T, isBitArray>(szpltFile, ___1349, ___3921); else ___2037 = ___2037 && ___4528<T, isBitArray>(szpltFile, ___1349, storedNodeIJK, ___3921); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 SZLOrderedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) {
 #if defined OUTPUT_TIMES
uint64_t ___3685 = ___715(); uint64_t minMaxTime = 0; uint64_t ___4546 = 0;
 #endif
___372 ___2037 = ___4224; ___2479 ___2760; ___2479 cszMinMaxArray; m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (___2037 && m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; ___2335.___856(); ___2037 = ___483(SzPltWriteOperation_WriteFieldData, ___2335, datasetVar, ___2675); ___2037 = ___2037 && calculateVarSubzoneMinMaxes(datasetVar, ___2760, cszMinMaxArray);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); minMaxTime += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2671[fileVar] = szpltFile.fileLoc(); if (___2037) { switch (___2335.___921(___2675 + 1, datasetVar + 1)) { case FieldDataType_Float: ___2037 = writeVariable<float, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Double: ___2037 = writeVariable<double, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Int32: ___2037 = writeVariable<int32_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Int16: ___2037 = writeVariable<int16_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Byte: ___2037 = writeVariable<uint8_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case ___1363: ___2037 = writeVariable<uint8_t, true>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; default: ___476(___1303); break; } } ___2760.___935(); cszMinMaxArray.___935();
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4546 += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2335.___857(); }
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds calculating variable ranges.", (double)(minMaxTime) / 1000.0); ___1929(NULL, "%g seconds writing zone data.", (double)(___4546) / 1000.0);
 #endif
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLOrderedZoneWriter::fieldDataSubzoneHeaderFileSize(bool ___2000) { if (___2000) return 3 * valueSizeInFile<uint32_t, false>(___2000) + 7 * valueSizeInFile<uint64_t, false>(___2000); else return 0; } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::cellSubzoneFieldDataFileSize(bool ___2000, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_ijkZoneInfo->getNumCellsInCsz(___467)); return arraySizeInFile<T, false>(___2780, ___2000); } template <> uint64_t SZLOrderedZoneWriter::cellSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_ijkZoneInfo->getNumCellsInCsz(___467)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2780), ___2000); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::nodeSubzoneFieldDataFileSize(bool ___2000, ItemAddress64::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_ijkZoneInfo->getNumNodesInNsz(___2732)); return arraySizeInFile<T, false>(___2820, ___2000); } template <> uint64_t SZLOrderedZoneWriter::nodeSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ItemAddress64::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_ijkZoneInfo->getNumNodesInNsz(___2732)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2820), ___2000); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::subzoneFieldDataFileSize(bool ___2000, ItemAddress64::SubzoneOffset_t ___3878, ValueLocation_e ___4323) const { if (___4323 == ___4325) return cellSubzoneFieldDataFileSize<T, isBitArray>(___2000, ___3878); else return nodeSubzoneFieldDataFileSize<T, isBitArray>(___2000, ___3878); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::variableFileSize(bool ___2000, ValueLocation_e ___4323) { uint64_t ___3356 = 0; ItemAddress64::SubzoneOffset_t const ___2821 = m_ijkZoneInfo->getNumNszs(); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2821), ___2000); ItemAddress64::SubzoneOffset_t const ___2781 = m_ijkZoneInfo->getNumCszs(); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2781), ___2000); ItemAddress64::SubzoneOffset_t const numDataSubzones = (___4323 == ___4325) ? ___2781 : ___2821; for (ItemAddress64::SubzoneOffset_t ___3921 = 0; ___3921 < numDataSubzones; ___3921++) { ___3356 += fieldDataSubzoneHeaderFileSize(___2000); ___3356 += subzoneFieldDataFileSize<T, isBitArray>(___2000, ___3921, ___4323); } return ___3356; } uint64_t SZLOrderedZoneWriter::zoneDataFileSize(bool ___2000) { uint64_t ___3356 = 0; m_varIter.reset(); ___4349 const firstVarToWrite = m_varIter.baseItem();
while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - firstVarToWrite; if (!m_writeVariables[fileVar]) continue; FieldDataType_e const ___1361 = ___2335.___921(___2675 + 1, datasetVar + 1); ValueLocation_e const ___4323 = ___2335.___908(___2675 + 1, datasetVar + 1); switch (___1361) { case FieldDataType_Float: ___3356 += variableFileSize<float, false>(___2000, ___4323); break; case FieldDataType_Double: ___3356 += variableFileSize<double, false>(___2000, ___4323); break; case FieldDataType_Int32: ___3356 += variableFileSize<int32_t, false>(___2000, ___4323); break; case FieldDataType_Int16: ___3356 += variableFileSize<int16_t, false>(___2000, ___4323); break; case FieldDataType_Byte: ___3356 += variableFileSize<uint8_t, false>(___2000, ___4323); break; case ___1363: ___3356 += variableFileSize<uint8_t, true>(___2000, ___4323); break; default: ___476(___1303); break; } } return ___3356; } ___372 SZLOrderedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4224; } uint64_t SZLOrderedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } uint64_t SZLOrderedZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } ___372 SZLOrderedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { return m_headerWriter.write(szpltFile); } }}
