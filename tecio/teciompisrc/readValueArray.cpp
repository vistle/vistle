#include "readValueArray.h"
#include "ThirdPartyHeadersBegin.h"
#include <utility>
#include <boost/algorithm/string.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "fileStuff.h"
#include "MinMax.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3931 { template <typename T, bool ___2023> struct ___198; template <> struct ___198 < char, false >     { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint8_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int16_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint16_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int32_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint32_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint64_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int64_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < float, false >    { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < double, false >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint8_t, true >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint16_t, true >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint64_t, true >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int64_t, true >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < std::pair<uint8_t, uint8_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<int16_t, int16_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<int32_t, int32_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<float, float>, false >     { static char const* typeName; }; template <> struct ___198 < std::pair<double, double>, false >   { static char const* typeName; }; char const* ___198<char, false>::___1472 = "%c"; char const* ___198<uint8_t, false>::___1472 = "%" PRIu32; char const* ___198<int16_t, false>::___1472 = "%" PRId32; char const* ___198<uint16_t, false>::___1472 = "%" PRIu32; char const* ___198<int32_t, false>::___1472 = "%" PRId32; char const* ___198<uint32_t, false>::___1472 = "%" PRIu32; char const* ___198<uint64_t, false>::___1472 = "%" PRIu64; char const* ___198<int64_t, false>::___1472 = "%" PRId64; char const* ___198<float, false>::___1472 = "%f";
char const* ___198<double, false>::___1472 = "%lf"; char const* ___198<uint8_t, true>::___1472 = "%" PRIx32; char const* ___198<uint16_t, true>::___1472 = "%" PRIx32; char const* ___198<uint64_t, true>::___1472 = "%" PRIx64; char const* ___198<int64_t, true>::___1472 = "%" PRIx64; char const* ___198<char, false>::typeName = "single character"; char const* ___198<uint8_t, false>::typeName = "1-byte unsigned integer"; char const* ___198<int16_t, false>::typeName = "2-byte unsigned integer"; char const* ___198<uint16_t, false>::typeName = "2-byte signed integer"; char const* ___198<int32_t, false>::typeName = "4-byte signed integer"; char const* ___198<uint32_t, false>::typeName = "4-byte unsigned integer"; char const* ___198<uint64_t, false>::typeName = "8-byte unsigned integer"; char const* ___198<int64_t, false>::typeName = "8-byte unsigned integer"; char const* ___198<float, false>::typeName = "float"; char const* ___198<double, false>::typeName = "double"; char const* ___198<uint8_t, true>::typeName = "1-byte unsigned integer"; char const* ___198<uint16_t, true>::typeName = "2-byte unsigned integer"; char const* ___198<uint64_t, true>::typeName = "8-byte hexadecimal"; char const* ___198<int64_t, true>::typeName = "8-byte hexadecimal"; char const* ___198<std::pair<uint8_t, uint8_t>, false >::typeName = "MinMax<uint8_t>"; char const* ___198<std::pair<int16_t, int16_t>, false >::typeName = "MinMax<int16_t>"; char const* ___198<std::pair<int32_t, int32_t>, false >::typeName = "MinMax<int32_t>"; char const* ___198<std::pair<float, float>, false >::typeName = "MinMax<float>"; char const* ___198<std::pair<double, double>, false >::typeName = "MinMax<double>"; template <typename T, bool ___2023, int baseValue> ___372 readAsciiValue( ___1397& file, T&                   ___4296) { char const* ___1472 = ___198<T, ___2023>::___1472; ___372 ___2037 = (file.fscanf(___1472, &___4296) == 1); if (___2037 && baseValue) ___4296 -= baseValue; ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #define INSTANTIATE_READ_ASCII_UINT_VALUE(T, ___2023) \
 template <> \
 ___372 readAsciiValue < T, ___2023, 0 >(___1397& file, T& ___4296) \
 { \
 char const* ___1472 = ___198<T, ___2023>::___1472; \
 uint32_t valFromFile; \
 ___372 ___2037 = (file.fscanf(___1472, &valFromFile) == 1); \
 if (___2037) \
 ___2037 = (valFromFile <= T(-1));    \
 if (___2037) \
 ___4296 = static_cast<T>(valFromFile); \
 ENSURE(VALID_BOOLEAN(___2037)); \
 return ___2037; \
 }
INSTANTIATE_READ_ASCII_UINT_VALUE(uint8_t, false) INSTANTIATE_READ_ASCII_UINT_VALUE(uint8_t, true) INSTANTIATE_READ_ASCII_UINT_VALUE(uint16_t, false) INSTANTIATE_READ_ASCII_UINT_VALUE(uint16_t, true) template <> ___372 readAsciiValue < int16_t, false, 0 >( ___1397& file, int16_t&             ___4296) { char const* ___1472 = ___198<int16_t, false>::___1472; int32_t valFromFile; ___372 ___2037 = (file.fscanf(___1472, &valFromFile) == 1); if (___2037) ___2037 = (-std::numeric_limits<int16_t>::max() <= valFromFile && valFromFile <= std::numeric_limits<int16_t>::max()); if (___2037) ___4296 = static_cast<int16_t>(valFromFile); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #define INSTANTIATE_READ_ASCII_VALUE_PAIR(T) \
 template <> \
 ___372 readAsciiValue<std::pair<T, T>, false, 0 >(___1397& file, std::pair<T, T>& minMax) \
 { \
 ___372 ___2037 = (readAsciiValue<T, false, 0>(file, minMax.first) == 1 && \
 readAsciiValue<T, false, 0>(file, minMax.second) == 1); \
 ENSURE(VALID_BOOLEAN(___2037)); \
 return ___2037; \
 }
INSTANTIATE_READ_ASCII_VALUE_PAIR(uint8_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(int16_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(int32_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(float) INSTANTIATE_READ_ASCII_VALUE_PAIR(double) namespace { inline bool isWhitespace(___2716 const ch) { return ch == ' ' || ch == '\n' || ch == '\r'; } } namespace { ___372 consumeWhitespace(___1397& file) { REQUIRE(file.___2039()); while (!file.feof()) { int ch = file.getc(); if (!isWhitespace(ch)) { file.ungetc(ch); break; } } return ___4224; } } namespace { ___372 checkDescription( char const*          stringToCheck, IODescription const& ___970) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___372 const ___2037 = (boost::iequals(stringToCheck, formattedDescription) ? ___4224 : ___1303); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readAndVerifyDescription( ___1397& file, IODescription const& ___970) { REQUIRE(file.___2039()); char encounteredString[STRING_SIZE]; ___372 ___2037 = (file.fscanf(STRING_FORMAT, encounteredString) == 1); ___2037 = ___2037 && consumeWhitespace(file); if (!___2037) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot read description for %s.", formattedDescription); } else { if (!checkDescription(encounteredString, ___970)) { static TagDescriptionToDescriptionMap altTagDescriptions = ALT_TAG_DESCRIPTIONS_MAP_INITIALIZER; char const* nameToCheck = ___970.___2683(); ___476(VALID_REF(nameToCheck)); while (___2037) { TagDescriptionToDescriptionMap::const_iterator altTagDescIter = altTagDescriptions.find(nameToCheck); if (altTagDescIter == altTagDescriptions.end()) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___2037 = ___1184("Mismatched descriptions: looking for '%s', found '%s' instead.", formattedDescription, encounteredString); } else { nameToCheck = altTagDescIter->second.c_str(); IODescription altDescription(nameToCheck, ___970.___4333(), ___970.zone(), ___970.___2975(), ___970.segment(), ___970.suffix()); if (checkDescription(encounteredString, altDescription)) break; } } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } template<typename T, bool ___2023  > ___372 readValue( ___1397& file, T&                   ___4296, IODescription const& ___970) { REQUIRE(file.___2039()); REQUIRE(___970.___2065()); ___372 ___2037 = ___4224; if (file.___2000()) { ___2037 = ___2037 && readAndVerifyDescription(file, ___970); ___2037 = ___2037 && readAsciiValue<T, ___2023, 0>(file, ___4296); ___2037 = ___2037 && consumeWhitespace(file); } else { ___2037 = (file.fread(&___4296, sizeof(T), 1) == 1); } if (!___2037) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot read %s value.", formattedDescription); } ENSURE(VALID_BOOLEAN(___2037));
return ___2037; }
 #define INSTANTIATE_READ_VALUE_FOR_TYPE(T, ___2023) \
 template ___372 readValue<T, ___2023>( \
 ___1397& file, \
 T&                   ___4296, \
 IODescription const& ___970);
INSTANTIATE_READ_VALUE_FOR_TYPE(uint8_t,  false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint16_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(int32_t,  false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint32_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint64_t, true) INSTANTIATE_READ_VALUE_FOR_TYPE(uint64_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(float,    false) INSTANTIATE_READ_VALUE_FOR_TYPE(double,   false) template<typename T, bool ___2023, int baseValue> ___372 readValues( ___1397& file, size_t               ___2794, T*                   ___4297, IODescription const& ___970) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(___2794>0); REQUIRE(VALID_REF(___4297)); REQUIRE(___970.___2065()); if (file.___2000()) { if (!___970.isEmpty()) ___2037 = readAndVerifyDescription(file, ___970); for (size_t ___1839 = 0; ___2037 && ___1839 < ___2794; ___1839++) { ___2037 = readAsciiValue<T, ___2023, baseValue>(file, ___4297[___1839]); ___2037 = ___2037 && consumeWhitespace(file); } } else { ___2037 = (file.fread(&___4297[0], sizeof(T), ___2794) == ___2794); } if ( !___2037 && !___970.isEmpty() ) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Error reading %" PRIu64 " %s values for %s data block.", uint64_t(___2794), ___198<T, ___2023>::typeName, formattedDescription); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #define INSTANTIATE_READ_VALUES_FOR_TYPE(T, ___2023, baseValue) \
 template ___372 readValues<T, ___2023, baseValue>( \
 ___1397& file, \
 size_t               ___2794, \
 T*                   ___4297, \
 IODescription const& ___970);
INSTANTIATE_READ_VALUES_FOR_TYPE(char,     false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint8_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint8_t,  true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int16_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint16_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint16_t, true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int32_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint32_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint32_t, false, 1) INSTANTIATE_READ_VALUES_FOR_TYPE(uint64_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint64_t, true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int64_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(int64_t,  true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(float,    false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(double,   false, 0) template<typename T, bool ___2023, int baseValue> ___372 readValueArray( ___1397&  file, size_t                ___2863, size_t                ___2793, ___2238<T>& ___4297, IODescription const&  ___970) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(IMPLICATION(___4297.empty(), ___2863 == 0)); REQUIRE(IMPLICATION(!___4297.empty(), ___2863 + ___2793 <= ___4297.size())); REQUIRE(___2793 > 0); REQUIRE(___970.___2065()); if (___4297.empty()) { ___2037 = ___4297.alloc(___2793); if (!___2037) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot allocate memory for %s data block of %" PRIu64 " %s values.", formattedDescription, uint64_t(___2793), ___198<T, ___2023>::typeName); } } ___2037 = ___2037 && readValues<T, ___2023, baseValue>(file, ___2793, &___4297[___2863], ___970); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #define INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(T, ___2023, baseValue) \
 template ___372 readValueArray<T, ___2023, baseValue>( \
 ___1397&  file, \
 size_t                ___2863, \
 size_t                ___2793, \
 ___2238<T>& ___4297, \
 IODescription const&  ___970);
INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(char,     false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint8_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint8_t,  true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int16_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint16_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint16_t, true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int32_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint32_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint32_t, false, 1) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint64_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint64_t, true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int64_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int64_t,  true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(float,    false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(double,   false, 0) template<typename T> ___372 readMinMaxArray( ___1397& file, size_t               ___2863, size_t               ___2793, ___2479&         ___2478, IODescription const& ___970) { REQUIRE(file.___2039()); REQUIRE(___970.___2065()); REQUIRE(___2793>0); REQUIRE(IMPLICATION(___2478.empty(), ___2863 == 0)); REQUIRE(IMPLICATION(!___2478.empty(), ___2863 + ___2793 <= ___2478.size())); ___372 ___2037 = ___4224; char const* typeName = "min-max value"; if (___2478.empty()) { ___2037 = ___2478.alloc(___2793); if (!___2037) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot allocate memory for %s data block (%" PRIu64 " %s values).", formattedDescription, uint64_t(___2793), typeName); } } if (file.___2000() && !___970.isEmpty()) ___2037 = readAndVerifyDescription(file, ___970); IODescription emptyDescription; size_t const maxValsPerChunk = 1024; std::pair<T, T> valsFromFile[maxValsPerChunk]; INVARIANT(sizeof(valsFromFile[0]) == 2 * sizeof(T)); size_t numValsRead = 0; while (___2037 && numValsRead < ___2793) { size_t const numChunkedValsToRead = std::min(maxValsPerChunk, ___2793 - numValsRead); ___2037 = readValues<std::pair<T, T>, false, 0>(file, numChunkedValsToRead, valsFromFile, emptyDescription); if (___2037) { for (size_t ___1839 = 0; ___1839 < numChunkedValsToRead; ++___1839) ___2478[___2863 + numValsRead + ___1839].___3497(static_cast<double>(valsFromFile[___1839].first), static_cast<double>(valsFromFile[___1839].second)); numValsRead += numChunkedValsToRead; } else { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Error reading %" PRIu64 " %s values for %s data block.", uint64_t(___2793), ___198<std::pair<T, T>, false>::typeName, formattedDescription); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #define INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(T) \
 template \
 ___372 readMinMaxArray<T>( \
 ___1397& file, \
 size_t               ___2863, \
 size_t               ___2793, \
 ___2479&         ___2478, \
 IODescription const& ___970);
INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(uint8_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(int16_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(int32_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(float) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(double) template<typename T, bool ___2023> ___372 readAndVerifyValue( ___1397& file, T const              expectedVal, IODescription const& ___970) { REQUIRE(file.___2039()); REQUIRE(___970.___2065()); T ___4296 = 0; ___372 ___2037 = readValue<T, ___2023>(file, ___4296, ___970); if (___2037 && ___4296 != expectedVal) { ___2037 = ___1303; char expectedValStr[STRING_SIZE]; char valStr[STRING_SIZE]; if (encodeAsciiValue<T, ___2023, 0>(expectedValStr, STRING_SIZE, expectedVal) && encodeAsciiValue<T, ___2023, 0>(valStr, STRING_SIZE, ___4296)) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Expected value mismatch for %s %s (expecting %s, found %s).", ___198<T, ___2023>::typeName, formattedDescription, expectedValStr, valStr); } else { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Expected value mismatch for %s %s.", ___198<T, ___2023>::typeName, formattedDescription); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template ___372 readAndVerifyValue<unsigned int, false>( ___1397& file, unsigned int const   expectedVal, IODescription const& ___970); ___372 readString( ___1397& file, size_t               length, ___471&           ___4296, IODescription const& ___970) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(___970.___2065() && !___970.isEmpty()); REQUIRE(length > 0); REQUIRE(___4296.size() == length); if (file.___2000()) ___2037 = ___2037 && readAndVerifyDescription(file, ___970); ___2037 = ___2037 && (file.fread(___4296.data(), 1, length) == length); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readStringArray( ___1397& file, size_t               ___2863, size_t               ___2810, ___3814&         itemNameArray, IODescription const& ___970) { REQUIRE(file.___2039()); REQUIRE(IMPLICATION(itemNameArray.empty(), ___2863 == 0)); REQUIRE(IMPLICATION(!itemNameArray.empty(), ___2863 + ___2810 <= itemNameArray.size())); REQUIRE(___2810 > 0); REQUIRE(___970.___2065() && !___970.isEmpty()); ___372 ___2037 = ___4224; if (itemNameArray.empty()) { if (!itemNameArray.alloc(___2810)) ___2037 = ___1184("Cannot resize string array."); } uint64_t totalStringListSize = 0; IODescription totalSizeDescription(___970.___2683(), ___970.___4333(), ___970.zone(), ___970.___2975(), ___970.segment(), "TotalSize" ); ___2037 = ___2037 && readValue<uint64_t, false>(file, totalStringListSize, totalSizeDescription); ASSERT_ONLY(___1391 startFileLoc = ___2037 ? file.fileLoc() : 0;) if (file.___2000()) ___2037 = ___2037 && readAndVerifyDescription(file, ___970); for (size_t ___2083 = 0; ___2037 && ___2083 < ___2810; ___2083++)
{ char ___2683[500]; for (size_t pos = 0; ___2037 && pos < sizeof(___2683); pos++) { int ch = file.getc(); if (ch == EOF) { ___2037 = ___1184("Unexpected end of file reading string array."); break; } else if (ch == '\r') { ___2683[pos] = '\0'; ___476(strlen(___2683) < sizeof(___2683)); itemNameArray[___2863 + ___2083] = ___2683; break; } else { ___2683[pos] = char(ch); } } if (___2037 && file.___2000()) if (file.getc() != '\n') ___2037 = ___1184("Problem with end of line in ascii string array."); } ASSERT_ONLY(___1391 curFileLoc = ___2037 ? file.fileLoc() : 0;) ___476(IMPLICATION(___2037, curFileLoc - startFileLoc == totalStringListSize)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
