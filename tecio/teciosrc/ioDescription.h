 #pragma once
#include "ThirdPartyHeadersBegin.h"
#  include <string>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "stringformat.h"
namespace tecplot { namespace ___3931 { class IODescription { public: typedef uint32_t SegmentIndex_t; static ___4349 const                 NO_VAR = BAD_VAR_INDEX; static ___4633 const                NO_ZONE = BAD_ZONE_INDEX; static ItemAddress64::___2978 const NO_PARTITION = ItemAddress64::INVALID_PARTITION; static SegmentIndex_t const             NO_SEGMENT = SegmentIndex_t(-1); private: char const*                ___2493; ___4349                 m_var; ___4633                ___2675; ItemAddress64::___2978 m_partition; SegmentIndex_t             m_segment; char const*                m_suffix; public: explicit IODescription( char const*                ___2683 = NULL, ___4349                 ___4333 = NO_VAR, ___4633                zone = NO_ZONE, ItemAddress64::___2978 ___2975 = NO_PARTITION, SegmentIndex_t             segment = NO_SEGMENT, char const*                suffix = NULL) : ___2493(___2683) , m_var(___4333) , ___2675(zone) , m_partition(___2975) , m_segment(segment) , m_suffix(suffix) {} char const* ___2683() const { return ___2493; } ___4349 ___4333() const { return m_var; } ___4633 zone() const { return ___2675; } ItemAddress64::___2978 ___2975() const { return m_partition; } SegmentIndex_t segment() const { return m_segment; } char const* suffix() const { return m_suffix; } ___372 ___2065() const { return ___4224; } ___372 isEmpty() const { return ___2493==NULL; } void getFormattedDescription( char*  formattedDescription, size_t formattedDescriptionSize) const { ___372 isAsciiOnly = ___1303; size_t ___2863; if ( ___2493 != NULL ) { ___2863 = snprintf(formattedDescription, formattedDescriptionSize, "%s", ___2493); if ( ___2863 > 0 && formattedDescription[___2863-1] == '*' ) { ___2863--; formattedDescription[___2863] = '\0'; isAsciiOnly = ___4224; } } else ___2863 = snprintf(formattedDescription, formattedDescriptionSize, "unspecified"); if ( m_var != NO_VAR && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sVar%" PRIu64, ___2493 != NULL ? "For" : "", uint64_t(m_var+1)); if ( ___2675 != NO_ZONE && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sZone%" PRIu64, ___2493 != NULL && m_var == NO_VAR ? "For" : "", uint64_t(___2675+1)); if ( m_partition != NO_PARTITION && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sPartition%" PRIu64, ___2493 != NULL && m_var == NO_VAR && ___2675 == NO_ZONE ? "For" : "", uint64_t(m_partition+1)); if ( m_segment != NO_SEGMENT && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sSegment%" PRIu64, ___2493 != NULL && m_var == NO_VAR && ___2675 == NO_ZONE && m_partition == NO_PARTITION ? "For" : "", uint64_t(m_segment+1)); if ( m_suffix != NULL && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%s", m_suffix);
if ( isAsciiOnly && ___2863 < formattedDescriptionSize ) { formattedDescription[___2863] = '*'; if ( ___2863 < formattedDescriptionSize ) ___2863++; formattedDescription[___2863] = '\0'; } } }; }}
