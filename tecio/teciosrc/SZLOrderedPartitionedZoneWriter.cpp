#include "SZLOrderedPartitionedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <new>
#include <sstream>
#include <utility>
#include <vector>
#include <boost/assign.hpp>
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "ItemAddress.h"
#include "ItemSetIterator.h"
#include "SZLOrderedPartitionWriter.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
namespace tecplot { namespace ___3931 { SZLOrderedPartitionedZoneWriter::SZLOrderedPartitionedZoneWriter( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4633                   zone, ___4633                   ___341, std::vector<___372> const& ___4561, ___372                     ___4496, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache) : ___4706(fileVersion, varIter, zone, ___341, ___4561, ___4496, ___36) , m_headerWriter( fileVersion, varIter, zone, ___341, ___36, m_partitionFileNums, m_partitionHeaderFilePositions, m_partitionMinNodeNumbers, m_partitionMaxNodeNumbers, m_varPartitionMinMaxes) , ___2678(zoneInfoCache) , m_partitionTecUtil(___36, zone + 1) { REQUIRE(0 <= zone && ___36.___4635(zone + 1)); REQUIRE(VALID_BOOLEAN(___4496)); REQUIRE(___36.zoneIsPartitioned(zone + 1)); size_t const numVarsToWrite = static_cast<size_t>(m_varIter.___2810()); size_t const numPartitions = static_cast<size_t>(___36.zoneGetNumPartitions(zone + 1)); if (!m_partitionFileNums.alloc(numPartitions, 0) || !m_partitionHeaderFilePositions.alloc(numPartitions, ___330) || !m_partitionMinNodeNumbers.alloc(numPartitions, 0) || !m_partitionMaxNodeNumbers.alloc(numPartitions, 0) || !___3354(m_varPartitionMinMaxes, numVarsToWrite, numPartitions)) throw std::bad_alloc(); } SZLOrderedPartitionedZoneWriter::~SZLOrderedPartitionedZoneWriter() {} void SZLOrderedPartitionedZoneWriter::getCellMinMaxes( std::vector<___2477>& cellMinMaxes, ___2225 ___460, ___1842 const& dimensions, std::vector<___1350> const& fieldDatas) { REQUIRE(cellMinMaxes.size() == fieldDatas.size()); for (size_t ___4333 = 0; ___4333 < fieldDatas.size(); ++___4333) cellMinMaxes[___4333].invalidate(); for (int cellI = 0; cellI <= 1; ++cellI) { for (int cellJ = 0; cellJ <= 1; ++cellJ) { for (int cellK = 0; cellK <= 1; ++cellK) { ___2225 ___2714 = ___460 + (cellK * dimensions.___2103() + cellJ) * dimensions.i() + cellI + 1; for (size_t ___4333 = 0; ___4333 < fieldDatas.size(); ++___4333) { double ___4296 = 0.0; if (fieldDatas[___4333].___2065()) ___4296 = fieldDatas[___4333].___1778(___2714); cellMinMaxes[___4333].include(___4296); } } } } } namespace{ void applyCellMinMaxToNeighborNodeSubzones( ___2225 i, ___2225 ___2103, ___2225 ___2132, std::vector<___2477> const& cellMinMaxes, ___1842 const& partitionOffsetIJK, ___1842 const& neighborOffsetIJK, ___1879& neighborInfo) { for (___2225 ___2156 = 0; ___2156 <= 1; ++___2156) { ___2225 neighborK = ___2156 + ___2132 + partitionOffsetIJK.___2132() - neighborOffsetIJK.___2132(); if (0 <= neighborK && neighborK < neighborInfo.___2712().___2132()) { for (___2225 ___2111 = 0; ___2111 <= 1; ++___2111) { ___2225 neighborJ = ___2111 + ___2103 + partitionOffsetIJK.___2103() - neighborOffsetIJK.___2103(); if (0 <= neighborJ && neighborJ < neighborInfo.___2712().___2103()) { for (___2225 ___1839 = 0; ___1839 <= 1; ++___1839) { ___2225 neighborI = ___1839 + i + partitionOffsetIJK.i() - neighborOffsetIJK.i(); if (0 <= neighborI && neighborI < neighborInfo.___2712().i())
{ ___1842 neighborNodeIJK((___81)neighborI, (___81)neighborJ, (___81)neighborK); ItemAddress64::SubzoneOffset_t ___2732 = neighborInfo.nszAtNodeIJK(neighborNodeIJK).subzoneOffset(); neighborInfo.includeNszVarMinMax(___2732, cellMinMaxes); } } } } } } } } void SZLOrderedPartitionedZoneWriter::applyCellMinMaxesToNeighborsInRange( std::vector<___1862> const& neighborItems, ItemAddress64::___2978 ___2975, ___1853 const& partitionRange, ___1842 const& partitionOffsetIJK, ___1842 const& partitionDimensionsIJK, std::vector<___1350> const& fieldDatas, std::vector<boost::shared_ptr<___1879> >& partitionInfos) { for (std::vector<___1862>::const_iterator neighborItem = neighborItems.begin(); neighborItem != neighborItems.end(); ++neighborItem) { ItemAddress64::___2978 neighborPartition = neighborItem->second; if (neighborPartition == ___2975) continue; ___1853 intersectionRange = ___1853(); ___1853 neighborRange = neighborItem->first; boost::geometry::intersection(partitionRange, neighborRange, intersectionRange); throwIfBadIntersectionRange(intersectionRange, ___2975, neighborPartition); ___2225 cellIMin = std::max((___2225)0, (___2225)(intersectionRange.min_corner().get<0>() - partitionOffsetIJK.i() - 1)); ___2225 ___459 = std::min((___2225)(partitionDimensionsIJK.i() - 2), (___2225)(intersectionRange.max_corner().get<0>() - partitionOffsetIJK.i())); ___2225 cellJMin = std::max((___2225)0, (___2225)(intersectionRange.min_corner().get<1>() - partitionOffsetIJK.___2103() - 1)); ___2225 ___464 = std::min((___2225)(partitionDimensionsIJK.___2103() - 2), (___2225)(intersectionRange.max_corner().get<1>() - partitionOffsetIJK.___2103())); ___2225 cellKMin = std::max((___2225)0, intersectionRange.min_corner().get<2>() - partitionOffsetIJK.___2132() - 1); ___2225 ___465 = std::min((___2225)(partitionDimensionsIJK.___2132() - 2), (___2225)(intersectionRange.max_corner().get<2>() - partitionOffsetIJK.___2132())); ___1842 neighborOffsetIJK((___81)neighborRange.min_corner().get<0>(), (___81)neighborRange.min_corner().get<1>(), (___81)neighborRange.min_corner().get<2>()); for (___2225 ___2132 = cellKMin; ___2132 <= ___465; ++___2132) { for (___2225 ___2103 = cellJMin; ___2103 <= ___464; ++___2103) { for (___2225 i = cellIMin; i <= ___459; ++i) { std::vector<___2477> cellMinMaxes(fieldDatas.size()); ___2225 ___460 = (___2132 * partitionDimensionsIJK.___2103() + ___2103) * partitionDimensionsIJK.i() + i; getCellMinMaxes(cellMinMaxes, ___460, partitionDimensionsIJK, fieldDatas); applyCellMinMaxToNeighborNodeSubzones(i, ___2103, ___2132, cellMinMaxes, partitionOffsetIJK, neighborOffsetIJK, *partitionInfos[neighborPartition]); } } } } } void SZLOrderedPartitionedZoneWriter::applyCellMinMaxesToNeighborNodeSubzones( ItemAddress64::___2978 ___2975, std::vector<___1350> const& nodalFieldDatas, std::vector<boost::shared_ptr<___1879> >& partitionInfos, ___1861 const& partitionTree) { ___1842 partitionOffsetIJK; ___2335.zonePartitionGetIJKOffset(___2675 + 1, ___2975 + 1, partitionOffsetIJK);
___1851 ___2472(partitionOffsetIJK.i(), partitionOffsetIJK.___2103(), partitionOffsetIJK.___2132()); ___1842 partitionDimensionsIJK; ___2335.zonePartitionGetIJK(___2675 + 1, ___2975 + 1, partitionDimensionsIJK); ___1842 partitionMaxIJK = partitionOffsetIJK + partitionDimensionsIJK - 1; ___1851 ___2362(partitionMaxIJK.i(), partitionMaxIJK.___2103(), partitionMaxIJK.___2132()); std::vector<___1862> neighborItems; ___1851 iFaceMinCorner(partitionMaxIJK.i(), partitionOffsetIJK.___2103(), partitionOffsetIJK.___2132()); ___1853 iFaceRange(iFaceMinCorner, ___2362); partitionTree.query(boost::geometry::index::intersects(iFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2975, iFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); neighborItems.clear(); ___1851 jFaceMinCorner(partitionOffsetIJK.i(), partitionMaxIJK.___2103(), partitionOffsetIJK.___2132()); ___1853 jFaceRange(jFaceMinCorner, ___2362); partitionTree.query(boost::geometry::index::intersects(jFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2975, jFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); neighborItems.clear(); ___1851 kFaceMinCorner(partitionOffsetIJK.i(), partitionOffsetIJK.___2103(), partitionMaxIJK.___2132()); ___1853 kFaceRange(kFaceMinCorner, ___2362); partitionTree.query(boost::geometry::index::intersects(kFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2975, kFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); } void SZLOrderedPartitionedZoneWriter::retrieveNodalFieldDataPtrsForPartition( ___37& partitionTecUtilDecorator, ItemAddress64::___2978 ___2975, std::vector<___1350> &nodalFieldDatas) { m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; if (___2335.___4350(datasetVar + 1) && !___2335.___924(___2675 + 1, datasetVar + 1)) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4327) nodalFieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, false); else nodalFieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, true); } } } void SZLOrderedPartitionedZoneWriter::throwIfBadIntersectionRange( ___1853 const& intersectionRange, ItemAddress64::___2978 ___2975, ItemAddress64::___2978 neighborPartition) { if (intersectionRange.min_corner().get<0>() != intersectionRange.max_corner().get<0>() && intersectionRange.min_corner().get<1>() != intersectionRange.max_corner().get<1>() && intersectionRange.min_corner().get<2>() != intersectionRange.max_corner().get<2>()) { std::ostringstream ___2890; ___2890 << "Error writing zone " << ___2675 + 1 << ": partition " << ___2975 + 1 <<
" overlaps partition " << neighborPartition << " by more than one node layer. The overlap is (" << intersectionRange.min_corner().get<0>() << '-' << intersectionRange.max_corner().get<0>() << ", " << intersectionRange.min_corner().get<1>() << '-' << intersectionRange.max_corner().get<1>() << ", " << intersectionRange.min_corner().get<2>() << '-' << intersectionRange.max_corner().get<2>() << ")." << " Ghost cells cannot be output for ordered zones. Please correct the partition index ranges in your calls to tecijkptn."; throw std::runtime_error(___2890.str()); } } void SZLOrderedPartitionedZoneWriter::exchangeGhostInfo( std::vector<boost::shared_ptr<___1879> >& partitionInfos, std::vector<___1862> const& ___2979) { ___1861 partitionTree(___2979); PartitionTecUtilDecorator partitionTecUtilDecorator(___2335, ___2675 + 1); ___4349 const numVarsToWrite = m_varIter.___2810(); ItemAddress64::___2978 const numPartitions = static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1)); std::vector<___1862> neighborPartitions; for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { std::vector<___1350> nodalFieldDatas(numVarsToWrite); retrieveNodalFieldDataPtrsForPartition(partitionTecUtilDecorator, ___2975, nodalFieldDatas); applyCellMinMaxesToNeighborNodeSubzones(___2975, nodalFieldDatas, partitionInfos, partitionTree); } } void SZLOrderedPartitionedZoneWriter::getPartitionExtentsWithGhostNodes( ItemAddress64::___2978 ___2975, ___1842& partitionMinIJK, ___1842& partitionMaxIJK) { REQUIRE(___2975 < static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1))); ___1842 partitionSize; ___2335.zonePartitionGetIJK(___2675 + 1, ___2975 + 1, partitionSize); ___2335.zonePartitionGetIJKOffset(___2675 + 1, ___2975 + 1, partitionMinIJK); partitionMaxIJK = partitionMinIJK + partitionSize - 1; } void SZLOrderedPartitionedZoneWriter::trimGhostNodes(___1842 &partitionMaxIJK) { ___1842 zoneSize; ___2335.___4612(___2675 + 1, zoneSize); if (partitionMaxIJK.i() < zoneSize.i() - 1) partitionMaxIJK.setI(partitionMaxIJK.i() - 1); if (partitionMaxIJK.___2103() < zoneSize.___2103() - 1) partitionMaxIJK.setJ(partitionMaxIJK.___2103() - 1); if (partitionMaxIJK.___2132() < zoneSize.___2132() - 1) partitionMaxIJK.___3495(partitionMaxIJK.___2132() - 1); } void SZLOrderedPartitionedZoneWriter::getPartitionExtentsWithoutGhostNodes( ItemAddress64::___2978 ___2975, ___1842& partitionMinIJK, ___1842& partitionMaxIJK) { REQUIRE(___2975 < static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1))); getPartitionExtentsWithGhostNodes(___2975, partitionMinIJK, partitionMaxIJK); trimGhostNodes(partitionMaxIJK); } void SZLOrderedPartitionedZoneWriter::createPartitionWriters() { std::vector<boost::shared_ptr<___1879> > partitionInfos; ItemAddress64::___2978 numPartitions = static_cast<ItemAddress64::___2978>(___2335.zoneGetNumPartitions(___2675 + 1));
std::vector<___1862> ___2979; ___2979.reserve((size_t)numPartitions); ___1842 zoneSize; ___2335.___4612(___2675 + 1, zoneSize); for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { partitionInfos.push_back(___2678.getIJKZonePartitionInfo(___2675, ___2975)); ___1842 partitionMinIJK; ___1842 partitionMaxIJK; getPartitionExtentsWithoutGhostNodes(___2975, partitionMinIJK, partitionMaxIJK); m_partitionMinNodeNumbers[___2975] = zoneSize.offsetAtIJK(partitionMinIJK); m_partitionMaxNodeNumbers[___2975] = zoneSize.offsetAtIJK(partitionMaxIJK); ___1851 ___2476(partitionMinIJK.i(), partitionMinIJK.___2103(), partitionMinIJK.___2132()); ___1851 ___2370(partitionMaxIJK.i(), partitionMaxIJK.___2103(), partitionMaxIJK.___2132()); ___2979.push_back(std::make_pair(___1853(___2476, ___2370), ___2975)); } exchangeGhostInfo(partitionInfos, ___2979); for (ItemAddress64::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { m_partitionWriters[___2975] = boost::make_shared<SZLOrderedPartitionWriter> ( m_fileVersion, boost::ref(m_varIter), ___2675, m_baseZone, ___2975, boost::ref(m_writeVariables), m_writeConnectivity, boost::ref(m_partitionTecUtil), partitionInfos[___2975]); } } ___372 SZLOrderedPartitionedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) { if (m_partitionWriters.empty()) createPartitionWriters(); for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { m_partitionWriters[___2975]->writeZone(szpltFile, szpltFile.fileLoc()); m_partitionHeaderFilePositions[___2975] = m_partitionWriters[___2975]->getZoneHeaderFilePosition(); m_varIter.reset(); ___4349 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4349 const datasetVar = m_varIter.next(); ___4349 const fileVar = datasetVar - baseVar; m_varPartitionMinMaxes[fileVar][___2975] = m_partitionWriters[___2975]->varMinMax(datasetVar); } } return ___4224; } uint64_t SZLOrderedPartitionedZoneWriter::zoneDataFileSize(bool ___2000) { if (m_partitionWriters.empty()) createPartitionWriters(); uint64_t ___3356 = 0; for(___4633 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) ___3356 += m_partitionWriters[___2975]->zoneFileSize(___2000); return ___3356; } ___372 SZLOrderedPartitionedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4224; } uint64_t SZLOrderedPartitionedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } ___372 SZLOrderedPartitionedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2039()); return m_headerWriter.write(szpltFile); } uint64_t SZLOrderedPartitionedZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } }}
